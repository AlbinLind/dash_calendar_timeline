/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["react"], factory);
	else if(typeof exports === 'object')
		exports["dash_calendar_timeline"] = factory(require("react"));
	else
		root["dash_calendar_timeline"] = factory(root["React"]);
})(self, (__WEBPACK_EXTERNAL_MODULE_react__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/react-calendar-timeline/dist/style.css":
/*!***************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/react-calendar-timeline/dist/style.css ***!
  \***************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.react-calendar-timeline *{box-sizing:border-box}.react-calendar-timeline .rct-outer{display:block;overflow:hidden;white-space:nowrap}.react-calendar-timeline .rct-scroll{display:inline-block;white-space:normal;vertical-align:top;overflow-x:scroll;overflow-y:hidden;-ms-touch-action:none;touch-action:none}.react-calendar-timeline .rct-item:hover{z-index:88}.react-calendar-timeline .rct-item .rct-item-content{position:sticky;position:-webkit-sticky;left:0;overflow:hidden;display:inline-block;border-radius:2px;padding:0 6px;height:100%}.react-calendar-timeline .rct-sidebar{overflow:hidden;white-space:normal;display:inline-block;vertical-align:top;position:relative;box-sizing:border-box;border-right:1px solid #bbb}.react-calendar-timeline .rct-sidebar.rct-sidebar-right{border-right:0;border-left:1px solid #bbb}.react-calendar-timeline .rct-sidebar .rct-sidebar-row{padding:0 4px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;box-sizing:border-box;margin:0;border-bottom:1px solid #bbb}.react-calendar-timeline .rct-sidebar .rct-sidebar-row.rct-sidebar-row-odd{background:#0000000d}.react-calendar-timeline .rct-sidebar .rct-sidebar-row.rct-sidebar-row-even{background:transparent}.react-calendar-timeline .rct-vertical-lines .rct-vl{position:absolute;border-left:1px solid #bbb;z-index:30}.react-calendar-timeline .rct-vertical-lines .rct-vl.rct-vl-first{border-left-width:2px}.react-calendar-timeline .rct-vertical-lines .rct-vl.rct-day-6,.react-calendar-timeline .rct-vertical-lines .rct-vl.rct-day-0{background:#faf6e180}.react-calendar-timeline .rct-horizontal-lines{-webkit-user-select:none;-moz-user-select:-moz-none;-ms-user-select:none;user-select:none}.react-calendar-timeline .rct-horizontal-lines .rct-hl-even,.react-calendar-timeline .rct-horizontal-lines .rct-hl-odd{border-bottom:1px solid #bbb;box-sizing:border-box;z-index:40}.react-calendar-timeline .rct-horizontal-lines .rct-hl-odd{background:#0000000d}.react-calendar-timeline .rct-horizontal-lines .rct-hl-even{background:transparent}.react-calendar-timeline .rct-cursor-line{position:absolute;width:2px;background:#2196f3;z-index:51}.react-calendar-timeline .rct-dateHeader{display:flex;align-items:center;justify-content:center;height:100%;border-bottom:1px solid #bbb;cursor:pointer;font-size:14px;background-color:#f0f0f0;border-left:2px solid #bbb}.react-calendar-timeline .rct-dateHeader-primary{background-color:initial;border-left:1px solid #bbb;border-right:1px solid #bbb;color:#fff}.react-calendar-timeline .rct-header-root{background:#c52020;border-bottom:1px solid #bbb}.react-calendar-timeline .rct-calendar-header{border:1px solid #bbb}\n`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://dash_calendar_timeline/./node_modules/react-calendar-timeline/dist/style.css?./node_modules/css-loader/dist/cjs.js\n}");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/ts/styles/base.css":
/*!**********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/ts/styles/base.css ***!
  \**********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.rct-item:hover {\n  .rct-item-handler-right {\n    cursor: e-resize !important;\n  }\n  .rct-item-handler-left {\n    cursor: w-resize !important;\n  }\n}\n`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://dash_calendar_timeline/./src/ts/styles/base.css?./node_modules/css-loader/dist/cjs.js\n}");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/ts/styles/selected-item.css":
/*!*******************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/ts/styles/selected-item.css ***!
  \*******************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.selected-item-info {\n  border: 1px solid black;\n  background-color: white;\n  padding: 5px;\n  z-index: 1000;\n}\n\n.selected-item-info-inputs {\n  display: flex;\n  flex-direction: column;\n  gap: 5px;\n}\n`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://dash_calendar_timeline/./src/ts/styles/selected-item.css?./node_modules/css-loader/dist/cjs.js\n}");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("{\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://dash_calendar_timeline/./node_modules/css-loader/dist/runtime/api.js?\n}");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("{\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://dash_calendar_timeline/./node_modules/css-loader/dist/runtime/noSourceMaps.js?\n}");

/***/ }),

/***/ "./node_modules/react-calendar-timeline/dist/react-calendar-timeline.es.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/react-calendar-timeline/dist/react-calendar-timeline.es.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CursorMarker: () => (/* binding */ vf),\n/* harmony export */   CustomHeader: () => (/* binding */ tf),\n/* harmony export */   CustomMarker: () => (/* binding */ df),\n/* harmony export */   DateHeader: () => (/* binding */ Ti),\n/* harmony export */   GroupRow: () => (/* binding */ wd),\n/* harmony export */   RowItems: () => (/* binding */ md),\n/* harmony export */   SidebarHeader: () => (/* binding */ zt),\n/* harmony export */   Timeline: () => (/* binding */ oo),\n/* harmony export */   TimelineHeaders: () => (/* binding */ $r),\n/* harmony export */   TimelineMarkers: () => (/* binding */ Sf),\n/* harmony export */   TodayMarker: () => (/* binding */ pf),\n/* harmony export */   calendarUtils: () => (/* binding */ bf),\n/* harmony export */   \"default\": () => (/* binding */ oo)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction Hn(s) {\n  let i = 0, a = 0, u = !0;\n  for (; s; )\n    !s.offsetParent && s.tagName === \"BODY\" && s.scrollLeft === 0 && s.scrollTop === 0 && (s = document.scrollingElement || s), i += s.offsetLeft - (u ? 0 : s.scrollLeft) + s.clientLeft, a += s.offsetTop - (u ? 0 : s.scrollTop) + s.clientTop, s = s.offsetParent, u = !1;\n  return { x: i, y: a };\n}\nfunction jt(s) {\n  if (s === document.body)\n    return { scrollLeft: 0, scrollTop: 0 };\n  {\n    const i = jt(s.parentNode);\n    return {\n      scrollLeft: s.scrollLeft + i.scrollLeft,\n      scrollTop: s.scrollTop + i.scrollTop\n    };\n  }\n}\nfunction At(s) {\n  if (s === document.body || !s.offsetParent)\n    return { offsetLeft: 0, offsetTop: 0 };\n  {\n    const i = At(s.offsetParent);\n    return {\n      offsetLeft: s.offsetLeft + i.offsetLeft,\n      offsetTop: s.offsetTop + i.offsetTop\n    };\n  }\n}\nvar We = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof __webpack_require__.g < \"u\" ? __webpack_require__.g : typeof self < \"u\" ? self : {};\nfunction Ze(s) {\n  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, \"default\") ? s.default : s;\n}\nvar Lt = { exports: {} };\nLt.exports;\n(function(s, i) {\n  (function(a, u) {\n    s.exports = u();\n  })(We, function() {\n    function a(t, e) {\n      var r = Object.keys(t);\n      if (Object.getOwnPropertySymbols) {\n        var n = Object.getOwnPropertySymbols(t);\n        e && (n = n.filter(function(o) {\n          return Object.getOwnPropertyDescriptor(t, o).enumerable;\n        })), r.push.apply(r, n);\n      }\n      return r;\n    }\n    function u(t) {\n      for (var e = 1; e < arguments.length; e++) {\n        var r = arguments[e] != null ? arguments[e] : {};\n        e % 2 ? a(Object(r), !0).forEach(function(n) {\n          x(t, n, r[n]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : a(Object(r)).forEach(function(n) {\n          Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));\n        });\n      }\n      return t;\n    }\n    function f(t) {\n      return f = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(e) {\n        return typeof e;\n      } : function(e) {\n        return e && typeof Symbol == \"function\" && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n      }, f(t);\n    }\n    function v(t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n    function m(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var n = e[r];\n        n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, C(n.key), n);\n      }\n    }\n    function y(t, e, r) {\n      return e && m(t.prototype, e), Object.defineProperty(t, \"prototype\", { writable: !1 }), t;\n    }\n    function x(t, e, r) {\n      return (e = C(e)) in t ? Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = r, t;\n    }\n    function O(t, e) {\n      if (typeof e != \"function\" && e !== null) throw new TypeError(\"Super expression must either be null or a function\");\n      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && P(t, e);\n    }\n    function $(t) {\n      return $ = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {\n        return e.__proto__ || Object.getPrototypeOf(e);\n      }, $(t);\n    }\n    function P(t, e) {\n      return P = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, n) {\n        return r.__proto__ = n, r;\n      }, P(t, e);\n    }\n    function T(t) {\n      if (t === void 0) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return t;\n    }\n    function _(t) {\n      var e = function() {\n        if (typeof Reflect > \"u\" || !Reflect.construct || Reflect.construct.sham) return !1;\n        if (typeof Proxy == \"function\") return !0;\n        try {\n          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n          })), !0;\n        } catch {\n          return !1;\n        }\n      }();\n      return function() {\n        var r, n = $(t);\n        if (e) {\n          var o = $(this).constructor;\n          r = Reflect.construct(n, arguments, o);\n        } else r = n.apply(this, arguments);\n        return function(l, c) {\n          if (c && (typeof c == \"object\" || typeof c == \"function\")) return c;\n          if (c !== void 0) throw new TypeError(\"Derived constructors may only return object or undefined\");\n          return T(l);\n        }(this, r);\n      };\n    }\n    function M() {\n      return M = typeof Reflect < \"u\" && Reflect.get ? Reflect.get.bind() : function(t, e, r) {\n        var n = function(l, c) {\n          for (; !Object.prototype.hasOwnProperty.call(l, c) && (l = $(l)) !== null; ) ;\n          return l;\n        }(t, e);\n        if (n) {\n          var o = Object.getOwnPropertyDescriptor(n, e);\n          return o.get ? o.get.call(arguments.length < 3 ? t : r) : o.value;\n        }\n      }, M.apply(this, arguments);\n    }\n    function C(t) {\n      var e = function(r, n) {\n        if (typeof r != \"object\" || r === null) return r;\n        var o = r[Symbol.toPrimitive];\n        if (o !== void 0) {\n          var l = o.call(r, n);\n          if (typeof l != \"object\") return l;\n          throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n        }\n        return String(r);\n      }(t, \"string\");\n      return typeof e == \"symbol\" ? e : e + \"\";\n    }\n    var z = function(t) {\n      return !(!t || !t.Window) && t instanceof t.Window;\n    }, N = void 0, G = void 0;\n    function Q(t) {\n      N = t;\n      var e = t.document.createTextNode(\"\");\n      e.ownerDocument !== t.document && typeof t.wrap == \"function\" && t.wrap(e) === e && (t = t.wrap(t)), G = t;\n    }\n    function te(t) {\n      return z(t) ? t : (t.ownerDocument || t).defaultView || G.window;\n    }\n    typeof window < \"u\" && window && Q(window);\n    var re = function(t) {\n      return !!t && f(t) === \"object\";\n    }, ue = function(t) {\n      return typeof t == \"function\";\n    }, S = { window: function(t) {\n      return t === G || z(t);\n    }, docFrag: function(t) {\n      return re(t) && t.nodeType === 11;\n    }, object: re, func: ue, number: function(t) {\n      return typeof t == \"number\";\n    }, bool: function(t) {\n      return typeof t == \"boolean\";\n    }, string: function(t) {\n      return typeof t == \"string\";\n    }, element: function(t) {\n      if (!t || f(t) !== \"object\") return !1;\n      var e = te(t) || G;\n      return /object|function/.test(typeof Element > \"u\" ? \"undefined\" : f(Element)) ? t instanceof Element || t instanceof e.Element : t.nodeType === 1 && typeof t.nodeName == \"string\";\n    }, plainObject: function(t) {\n      return re(t) && !!t.constructor && /function Object\\b/.test(t.constructor.toString());\n    }, array: function(t) {\n      return re(t) && t.length !== void 0 && ue(t.splice);\n    } };\n    function be(t) {\n      var e = t.interaction;\n      if (e.prepared.name === \"drag\") {\n        var r = e.prepared.axis;\n        r === \"x\" ? (e.coords.cur.page.y = e.coords.start.page.y, e.coords.cur.client.y = e.coords.start.client.y, e.coords.velocity.client.y = 0, e.coords.velocity.page.y = 0) : r === \"y\" && (e.coords.cur.page.x = e.coords.start.page.x, e.coords.cur.client.x = e.coords.start.client.x, e.coords.velocity.client.x = 0, e.coords.velocity.page.x = 0);\n      }\n    }\n    function we(t) {\n      var e = t.iEvent, r = t.interaction;\n      if (r.prepared.name === \"drag\") {\n        var n = r.prepared.axis;\n        if (n === \"x\" || n === \"y\") {\n          var o = n === \"x\" ? \"y\" : \"x\";\n          e.page[o] = r.coords.start.page[o], e.client[o] = r.coords.start.client[o], e.delta[o] = 0;\n        }\n      }\n    }\n    var ce = { id: \"actions/drag\", install: function(t) {\n      var e = t.actions, r = t.Interactable, n = t.defaults;\n      r.prototype.draggable = ce.draggable, e.map.drag = ce, e.methodDict.drag = \"draggable\", n.actions.drag = ce.defaults;\n    }, listeners: { \"interactions:before-action-move\": be, \"interactions:action-resume\": be, \"interactions:action-move\": we, \"auto-start:check\": function(t) {\n      var e = t.interaction, r = t.interactable, n = t.buttons, o = r.options.drag;\n      if (o && o.enabled && (!e.pointerIsDown || !/mouse|pointer/.test(e.pointerType) || n & r.options.drag.mouseButtons)) return t.action = { name: \"drag\", axis: o.lockAxis === \"start\" ? o.startAxis : o.lockAxis }, !1;\n    } }, draggable: function(t) {\n      return S.object(t) ? (this.options.drag.enabled = t.enabled !== !1, this.setPerAction(\"drag\", t), this.setOnEvents(\"drag\", t), /^(xy|x|y|start)$/.test(t.lockAxis) && (this.options.drag.lockAxis = t.lockAxis), /^(xy|x|y)$/.test(t.startAxis) && (this.options.drag.startAxis = t.startAxis), this) : S.bool(t) ? (this.options.drag.enabled = t, this) : this.options.drag;\n    }, beforeMove: be, move: we, defaults: { startAxis: \"xy\", lockAxis: \"xy\" }, getCursor: function() {\n      return \"move\";\n    }, filterEventType: function(t) {\n      return t.search(\"drag\") === 0;\n    } }, ne = ce, de = { init: function(t) {\n      var e = t;\n      de.document = e.document, de.DocumentFragment = e.DocumentFragment || Ee, de.SVGElement = e.SVGElement || Ee, de.SVGSVGElement = e.SVGSVGElement || Ee, de.SVGElementInstance = e.SVGElementInstance || Ee, de.Element = e.Element || Ee, de.HTMLElement = e.HTMLElement || de.Element, de.Event = e.Event, de.Touch = e.Touch || Ee, de.PointerEvent = e.PointerEvent || e.MSPointerEvent;\n    }, document: null, DocumentFragment: null, SVGElement: null, SVGSVGElement: null, SVGElementInstance: null, Element: null, HTMLElement: null, Event: null, Touch: null, PointerEvent: null };\n    function Ee() {\n    }\n    var W = de, k = { init: function(t) {\n      var e = W.Element, r = t.navigator || {};\n      k.supportsTouch = \"ontouchstart\" in t || S.func(t.DocumentTouch) && W.document instanceof t.DocumentTouch, k.supportsPointerEvent = r.pointerEnabled !== !1 && !!W.PointerEvent, k.isIOS = /iP(hone|od|ad)/.test(r.platform), k.isIOS7 = /iP(hone|od|ad)/.test(r.platform) && /OS 7[^\\d]/.test(r.appVersion), k.isIe9 = /MSIE 9/.test(r.userAgent), k.isOperaMobile = r.appName === \"Opera\" && k.supportsTouch && /Presto/.test(r.userAgent), k.prefixedMatchesSelector = \"matches\" in e.prototype ? \"matches\" : \"webkitMatchesSelector\" in e.prototype ? \"webkitMatchesSelector\" : \"mozMatchesSelector\" in e.prototype ? \"mozMatchesSelector\" : \"oMatchesSelector\" in e.prototype ? \"oMatchesSelector\" : \"msMatchesSelector\", k.pEventTypes = k.supportsPointerEvent ? W.PointerEvent === t.MSPointerEvent ? { up: \"MSPointerUp\", down: \"MSPointerDown\", over: \"mouseover\", out: \"mouseout\", move: \"MSPointerMove\", cancel: \"MSPointerCancel\" } : { up: \"pointerup\", down: \"pointerdown\", over: \"pointerover\", out: \"pointerout\", move: \"pointermove\", cancel: \"pointercancel\" } : null, k.wheelEvent = W.document && \"onmousewheel\" in W.document ? \"mousewheel\" : \"wheel\";\n    }, supportsTouch: null, supportsPointerEvent: null, isIOS7: null, isIOS: null, isIe9: null, isOperaMobile: null, prefixedMatchesSelector: null, pEventTypes: null, wheelEvent: null }, R = k;\n    function F(t, e) {\n      if (t.contains) return t.contains(e);\n      for (; e; ) {\n        if (e === t) return !0;\n        e = e.parentNode;\n      }\n      return !1;\n    }\n    function A(t, e) {\n      for (; S.element(t); ) {\n        if (X(t, e)) return t;\n        t = K(t);\n      }\n      return null;\n    }\n    function K(t) {\n      var e = t.parentNode;\n      if (S.docFrag(e)) {\n        for (; (e = e.host) && S.docFrag(e); ) ;\n        return e;\n      }\n      return e;\n    }\n    function X(t, e) {\n      return G !== N && (e = e.replace(/\\/deep\\//g, \" \")), t[R.prefixedMatchesSelector](e);\n    }\n    var ie = function(t) {\n      return t.parentNode || t.host;\n    };\n    function ae(t, e) {\n      for (var r, n = [], o = t; (r = ie(o)) && o !== e && r !== o.ownerDocument; ) n.unshift(o), o = r;\n      return n;\n    }\n    function pe(t, e, r) {\n      for (; S.element(t); ) {\n        if (X(t, e)) return !0;\n        if ((t = K(t)) === r) return X(t, e);\n      }\n      return !1;\n    }\n    function he(t) {\n      return t.correspondingUseElement || t;\n    }\n    function ve(t) {\n      var e = t instanceof W.SVGElement ? t.getBoundingClientRect() : t.getClientRects()[0];\n      return e && { left: e.left, right: e.right, top: e.top, bottom: e.bottom, width: e.width || e.right - e.left, height: e.height || e.bottom - e.top };\n    }\n    function Oe(t) {\n      var e, r = ve(t);\n      if (!R.isIOS7 && r) {\n        var n = { x: (e = (e = te(t)) || G).scrollX || e.document.documentElement.scrollLeft, y: e.scrollY || e.document.documentElement.scrollTop };\n        r.left += n.x, r.right += n.x, r.top += n.y, r.bottom += n.y;\n      }\n      return r;\n    }\n    function Ce(t) {\n      for (var e = []; t; ) e.push(t), t = K(t);\n      return e;\n    }\n    function ke(t) {\n      return !!S.string(t) && (W.document.querySelector(t), !0);\n    }\n    function H(t, e) {\n      for (var r in e) t[r] = e[r];\n      return t;\n    }\n    function fe(t, e, r) {\n      return t === \"parent\" ? K(r) : t === \"self\" ? e.getRect(r) : A(r, t);\n    }\n    function ye(t, e, r, n) {\n      var o = t;\n      return S.string(o) ? o = fe(o, e, r) : S.func(o) && (o = o.apply(void 0, n)), S.element(o) && (o = Oe(o)), o;\n    }\n    function _e(t) {\n      return t && { x: \"x\" in t ? t.x : t.left, y: \"y\" in t ? t.y : t.top };\n    }\n    function ze(t) {\n      return !t || \"x\" in t && \"y\" in t || ((t = H({}, t)).x = t.left || 0, t.y = t.top || 0, t.width = t.width || (t.right || 0) - t.x, t.height = t.height || (t.bottom || 0) - t.y), t;\n    }\n    function mt(t, e, r) {\n      t.left && (e.left += r.x), t.right && (e.right += r.x), t.top && (e.top += r.y), t.bottom && (e.bottom += r.y), e.width = e.right - e.left, e.height = e.bottom - e.top;\n    }\n    function it(t, e, r) {\n      var n = r && t.options[r];\n      return _e(ye(n && n.origin || t.options.origin, t, e, [t && e])) || { x: 0, y: 0 };\n    }\n    function Ue(t, e) {\n      var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function(h) {\n        return !0;\n      }, n = arguments.length > 3 ? arguments[3] : void 0;\n      if (n = n || {}, S.string(t) && t.search(\" \") !== -1 && (t = Br(t)), S.array(t)) return t.forEach(function(h) {\n        return Ue(h, e, r, n);\n      }), n;\n      if (S.object(t) && (e = t, t = \"\"), S.func(e) && r(t)) n[t] = n[t] || [], n[t].push(e);\n      else if (S.array(e)) for (var o = 0, l = e; o < l.length; o++) {\n        var c = l[o];\n        Ue(t, c, r, n);\n      }\n      else if (S.object(e)) for (var p in e)\n        Ue(Br(p).map(function(h) {\n          return \"\".concat(t).concat(h);\n        }), e[p], r, n);\n      return n;\n    }\n    function Br(t) {\n      return t.trim().split(/ +/);\n    }\n    var ot = function(t, e) {\n      return Math.sqrt(t * t + e * e);\n    }, ao = [\"webkit\", \"moz\"];\n    function bt(t, e) {\n      t.__set || (t.__set = {});\n      var r = function(o) {\n        if (ao.some(function(l) {\n          return o.indexOf(l) === 0;\n        })) return 1;\n        typeof t[o] != \"function\" && o !== \"__set\" && Object.defineProperty(t, o, { get: function() {\n          return o in t.__set ? t.__set[o] : t.__set[o] = e[o];\n        }, set: function(l) {\n          t.__set[o] = l;\n        }, configurable: !0 });\n      };\n      for (var n in e) r(n);\n      return t;\n    }\n    function yt(t, e) {\n      t.page = t.page || {}, t.page.x = e.page.x, t.page.y = e.page.y, t.client = t.client || {}, t.client.x = e.client.x, t.client.y = e.client.y, t.timeStamp = e.timeStamp;\n    }\n    function Vr(t) {\n      t.page.x = 0, t.page.y = 0, t.client.x = 0, t.client.y = 0;\n    }\n    function qr(t) {\n      return t instanceof W.Event || t instanceof W.Touch;\n    }\n    function Tt(t, e, r) {\n      return t = t || \"page\", (r = r || {}).x = e[t + \"X\"], r.y = e[t + \"Y\"], r;\n    }\n    function Zr(t, e) {\n      return e = e || { x: 0, y: 0 }, R.isOperaMobile && qr(t) ? (Tt(\"screen\", t, e), e.x += window.scrollX, e.y += window.scrollY) : Tt(\"page\", t, e), e;\n    }\n    function st(t) {\n      return S.number(t.pointerId) ? t.pointerId : t.identifier;\n    }\n    function lo(t, e, r) {\n      var n = e.length > 1 ? Jr(e) : e[0];\n      Zr(n, t.page), function(o, l) {\n        l = l || {}, R.isOperaMobile && qr(o) ? Tt(\"screen\", o, l) : Tt(\"client\", o, l);\n      }(n, t.client), t.timeStamp = r;\n    }\n    function Jt(t) {\n      var e = [];\n      return S.array(t) ? (e[0] = t[0], e[1] = t[1]) : t.type === \"touchend\" ? t.touches.length === 1 ? (e[0] = t.touches[0], e[1] = t.changedTouches[0]) : t.touches.length === 0 && (e[0] = t.changedTouches[0], e[1] = t.changedTouches[1]) : (e[0] = t.touches[0], e[1] = t.touches[1]), e;\n    }\n    function Jr(t) {\n      for (var e = { pageX: 0, pageY: 0, clientX: 0, clientY: 0, screenX: 0, screenY: 0 }, r = 0; r < t.length; r++) {\n        var n = t[r];\n        for (var o in e) e[o] += n[o];\n      }\n      for (var l in e) e[l] /= t.length;\n      return e;\n    }\n    function Qt(t) {\n      if (!t.length) return null;\n      var e = Jt(t), r = Math.min(e[0].pageX, e[1].pageX), n = Math.min(e[0].pageY, e[1].pageY), o = Math.max(e[0].pageX, e[1].pageX), l = Math.max(e[0].pageY, e[1].pageY);\n      return { x: r, y: n, left: r, top: n, right: o, bottom: l, width: o - r, height: l - n };\n    }\n    function er(t, e) {\n      var r = e + \"X\", n = e + \"Y\", o = Jt(t), l = o[0][r] - o[1][r], c = o[0][n] - o[1][n];\n      return ot(l, c);\n    }\n    function tr(t, e) {\n      var r = e + \"X\", n = e + \"Y\", o = Jt(t), l = o[1][r] - o[0][r], c = o[1][n] - o[0][n];\n      return 180 * Math.atan2(c, l) / Math.PI;\n    }\n    function Qr(t) {\n      return S.string(t.pointerType) ? t.pointerType : S.number(t.pointerType) ? [void 0, void 0, \"touch\", \"pen\", \"mouse\"][t.pointerType] : /touch/.test(t.type || \"\") || t instanceof W.Touch ? \"touch\" : \"mouse\";\n    }\n    function en(t) {\n      var e = S.func(t.composedPath) ? t.composedPath() : t.path;\n      return [he(e ? e[0] : t.target), he(t.currentTarget)];\n    }\n    var wt = function() {\n      function t(e) {\n        v(this, t), this.immediatePropagationStopped = !1, this.propagationStopped = !1, this._interaction = e;\n      }\n      return y(t, [{ key: \"preventDefault\", value: function() {\n      } }, { key: \"stopPropagation\", value: function() {\n        this.propagationStopped = !0;\n      } }, { key: \"stopImmediatePropagation\", value: function() {\n        this.immediatePropagationStopped = this.propagationStopped = !0;\n      } }]), t;\n    }();\n    Object.defineProperty(wt.prototype, \"interaction\", { get: function() {\n      return this._interaction._proxy;\n    }, set: function() {\n    } });\n    var tn = function(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var n = e[r];\n        t.push(n);\n      }\n      return t;\n    }, rn = function(t) {\n      return tn([], t);\n    }, at = function(t, e) {\n      for (var r = 0; r < t.length; r++) if (e(t[r], r, t)) return r;\n      return -1;\n    }, lt = function(t, e) {\n      return t[at(t, e)];\n    }, Xe = function(t) {\n      O(r, t);\n      var e = _(r);\n      function r(n, o, l) {\n        var c;\n        v(this, r), (c = e.call(this, o._interaction)).dropzone = void 0, c.dragEvent = void 0, c.relatedTarget = void 0, c.draggable = void 0, c.propagationStopped = !1, c.immediatePropagationStopped = !1;\n        var p = l === \"dragleave\" ? n.prev : n.cur, h = p.element, g = p.dropzone;\n        return c.type = l, c.target = h, c.currentTarget = h, c.dropzone = g, c.dragEvent = o, c.relatedTarget = o.target, c.draggable = o.interactable, c.timeStamp = o.timeStamp, c;\n      }\n      return y(r, [{ key: \"reject\", value: function() {\n        var n = this, o = this._interaction.dropState;\n        if (this.type === \"dropactivate\" || this.dropzone && o.cur.dropzone === this.dropzone && o.cur.element === this.target) if (o.prev.dropzone = this.dropzone, o.prev.element = this.target, o.rejected = !0, o.events.enter = null, this.stopImmediatePropagation(), this.type === \"dropactivate\") {\n          var l = o.activeDrops, c = at(l, function(h) {\n            var g = h.dropzone, d = h.element;\n            return g === n.dropzone && d === n.target;\n          });\n          o.activeDrops.splice(c, 1);\n          var p = new r(o, this.dragEvent, \"dropdeactivate\");\n          p.dropzone = this.dropzone, p.target = this.target, this.dropzone.fire(p);\n        } else this.dropzone.fire(new r(o, this.dragEvent, \"dragleave\"));\n      } }, { key: \"preventDefault\", value: function() {\n      } }, { key: \"stopPropagation\", value: function() {\n        this.propagationStopped = !0;\n      } }, { key: \"stopImmediatePropagation\", value: function() {\n        this.immediatePropagationStopped = this.propagationStopped = !0;\n      } }]), r;\n    }(wt);\n    function nn(t, e) {\n      for (var r = 0, n = t.slice(); r < n.length; r++) {\n        var o = n[r], l = o.dropzone, c = o.element;\n        e.dropzone = l, e.target = c, l.fire(e), e.propagationStopped = e.immediatePropagationStopped = !1;\n      }\n    }\n    function rr(t, e) {\n      for (var r = function(l, c) {\n        for (var p = [], h = 0, g = l.interactables.list; h < g.length; h++) {\n          var d = g[h];\n          if (d.options.drop.enabled) {\n            var b = d.options.drop.accept;\n            if (!(S.element(b) && b !== c || S.string(b) && !X(c, b) || S.func(b) && !b({ dropzone: d, draggableElement: c }))) for (var w = 0, I = d.getAllElements(); w < I.length; w++) {\n              var E = I[w];\n              E !== c && p.push({ dropzone: d, element: E, rect: d.getRect(E) });\n            }\n          }\n        }\n        return p;\n      }(t, e), n = 0; n < r.length; n++) {\n        var o = r[n];\n        o.rect = o.dropzone.getRect(o.element);\n      }\n      return r;\n    }\n    function on(t, e, r) {\n      for (var n = t.dropState, o = t.interactable, l = t.element, c = [], p = 0, h = n.activeDrops; p < h.length; p++) {\n        var g = h[p], d = g.dropzone, b = g.element, w = g.rect, I = d.dropCheck(e, r, o, l, b, w);\n        c.push(I ? b : null);\n      }\n      var E = function(D) {\n        for (var L, j, Y, q = [], ee = 0; ee < D.length; ee++) {\n          var B = D[ee], Z = D[L];\n          if (B && ee !== L) if (Z) {\n            var me = ie(B), le = ie(Z);\n            if (me !== B.ownerDocument) if (le !== B.ownerDocument) if (me !== le) {\n              q = q.length ? q : ae(Z);\n              var Te = void 0;\n              if (Z instanceof W.HTMLElement && B instanceof W.SVGElement && !(B instanceof W.SVGSVGElement)) {\n                if (B === le) continue;\n                Te = B.ownerSVGElement;\n              } else Te = B;\n              for (var Se = ae(Te, Z.ownerDocument), De = 0; Se[De] && Se[De] === q[De]; ) De++;\n              var Pt = [Se[De - 1], Se[De], q[De]];\n              if (Pt[0]) for (var ft = Pt[0].lastChild; ft; ) {\n                if (ft === Pt[1]) {\n                  L = ee, q = Se;\n                  break;\n                }\n                if (ft === Pt[2]) break;\n                ft = ft.previousSibling;\n              }\n            } else Y = Z, (parseInt(te(j = B).getComputedStyle(j).zIndex, 10) || 0) >= (parseInt(te(Y).getComputedStyle(Y).zIndex, 10) || 0) && (L = ee);\n            else L = ee;\n          } else L = ee;\n        }\n        return L;\n      }(c);\n      return n.activeDrops[E] || null;\n    }\n    function nr(t, e, r) {\n      var n = t.dropState, o = { enter: null, leave: null, activate: null, deactivate: null, move: null, drop: null };\n      return r.type === \"dragstart\" && (o.activate = new Xe(n, r, \"dropactivate\"), o.activate.target = null, o.activate.dropzone = null), r.type === \"dragend\" && (o.deactivate = new Xe(n, r, \"dropdeactivate\"), o.deactivate.target = null, o.deactivate.dropzone = null), n.rejected || (n.cur.element !== n.prev.element && (n.prev.dropzone && (o.leave = new Xe(n, r, \"dragleave\"), r.dragLeave = o.leave.target = n.prev.element, r.prevDropzone = o.leave.dropzone = n.prev.dropzone), n.cur.dropzone && (o.enter = new Xe(n, r, \"dragenter\"), r.dragEnter = n.cur.element, r.dropzone = n.cur.dropzone)), r.type === \"dragend\" && n.cur.dropzone && (o.drop = new Xe(n, r, \"drop\"), r.dropzone = n.cur.dropzone, r.relatedTarget = n.cur.element), r.type === \"dragmove\" && n.cur.dropzone && (o.move = new Xe(n, r, \"dropmove\"), r.dropzone = n.cur.dropzone)), o;\n    }\n    function ir(t, e) {\n      var r = t.dropState, n = r.activeDrops, o = r.cur, l = r.prev;\n      e.leave && l.dropzone.fire(e.leave), e.enter && o.dropzone.fire(e.enter), e.move && o.dropzone.fire(e.move), e.drop && o.dropzone.fire(e.drop), e.deactivate && nn(n, e.deactivate), r.prev.dropzone = o.dropzone, r.prev.element = o.element;\n    }\n    function sn(t, e) {\n      var r = t.interaction, n = t.iEvent, o = t.event;\n      if (n.type === \"dragmove\" || n.type === \"dragend\") {\n        var l = r.dropState;\n        e.dynamicDrop && (l.activeDrops = rr(e, r.element));\n        var c = n, p = on(r, c, o);\n        l.rejected = l.rejected && !!p && p.dropzone === l.cur.dropzone && p.element === l.cur.element, l.cur.dropzone = p && p.dropzone, l.cur.element = p && p.element, l.events = nr(r, 0, c);\n      }\n    }\n    var an = { id: \"actions/drop\", install: function(t) {\n      var e = t.actions, r = t.interactStatic, n = t.Interactable, o = t.defaults;\n      t.usePlugin(ne), n.prototype.dropzone = function(l) {\n        return function(c, p) {\n          if (S.object(p)) {\n            if (c.options.drop.enabled = p.enabled !== !1, p.listeners) {\n              var h = Ue(p.listeners), g = Object.keys(h).reduce(function(b, w) {\n                return b[/^(enter|leave)/.test(w) ? \"drag\".concat(w) : /^(activate|deactivate|move)/.test(w) ? \"drop\".concat(w) : w] = h[w], b;\n              }, {}), d = c.options.drop.listeners;\n              d && c.off(d), c.on(g), c.options.drop.listeners = g;\n            }\n            return S.func(p.ondrop) && c.on(\"drop\", p.ondrop), S.func(p.ondropactivate) && c.on(\"dropactivate\", p.ondropactivate), S.func(p.ondropdeactivate) && c.on(\"dropdeactivate\", p.ondropdeactivate), S.func(p.ondragenter) && c.on(\"dragenter\", p.ondragenter), S.func(p.ondragleave) && c.on(\"dragleave\", p.ondragleave), S.func(p.ondropmove) && c.on(\"dropmove\", p.ondropmove), /^(pointer|center)$/.test(p.overlap) ? c.options.drop.overlap = p.overlap : S.number(p.overlap) && (c.options.drop.overlap = Math.max(Math.min(1, p.overlap), 0)), \"accept\" in p && (c.options.drop.accept = p.accept), \"checker\" in p && (c.options.drop.checker = p.checker), c;\n          }\n          return S.bool(p) ? (c.options.drop.enabled = p, c) : c.options.drop;\n        }(this, l);\n      }, n.prototype.dropCheck = function(l, c, p, h, g, d) {\n        return function(b, w, I, E, D, L, j) {\n          var Y = !1;\n          if (!(j = j || b.getRect(L))) return !!b.options.drop.checker && b.options.drop.checker(w, I, Y, b, L, E, D);\n          var q = b.options.drop.overlap;\n          if (q === \"pointer\") {\n            var ee = it(E, D, \"drag\"), B = Zr(w);\n            B.x += ee.x, B.y += ee.y;\n            var Z = B.x > j.left && B.x < j.right, me = B.y > j.top && B.y < j.bottom;\n            Y = Z && me;\n          }\n          var le = E.getRect(D);\n          if (le && q === \"center\") {\n            var Te = le.left + le.width / 2, Se = le.top + le.height / 2;\n            Y = Te >= j.left && Te <= j.right && Se >= j.top && Se <= j.bottom;\n          }\n          return le && S.number(q) && (Y = Math.max(0, Math.min(j.right, le.right) - Math.max(j.left, le.left)) * Math.max(0, Math.min(j.bottom, le.bottom) - Math.max(j.top, le.top)) / (le.width * le.height) >= q), b.options.drop.checker && (Y = b.options.drop.checker(w, I, Y, b, L, E, D)), Y;\n        }(this, l, c, p, h, g, d);\n      }, r.dynamicDrop = function(l) {\n        return S.bool(l) ? (t.dynamicDrop = l, r) : t.dynamicDrop;\n      }, H(e.phaselessTypes, { dragenter: !0, dragleave: !0, dropactivate: !0, dropdeactivate: !0, dropmove: !0, drop: !0 }), e.methodDict.drop = \"dropzone\", t.dynamicDrop = !1, o.actions.drop = an.defaults;\n    }, listeners: { \"interactions:before-action-start\": function(t) {\n      var e = t.interaction;\n      e.prepared.name === \"drag\" && (e.dropState = { cur: { dropzone: null, element: null }, prev: { dropzone: null, element: null }, rejected: null, events: null, activeDrops: [] });\n    }, \"interactions:after-action-start\": function(t, e) {\n      var r = t.interaction, n = (t.event, t.iEvent);\n      if (r.prepared.name === \"drag\") {\n        var o = r.dropState;\n        o.activeDrops = [], o.events = {}, o.activeDrops = rr(e, r.element), o.events = nr(r, 0, n), o.events.activate && (nn(o.activeDrops, o.events.activate), e.fire(\"actions/drop:start\", { interaction: r, dragEvent: n }));\n      }\n    }, \"interactions:action-move\": sn, \"interactions:after-action-move\": function(t, e) {\n      var r = t.interaction, n = t.iEvent;\n      if (r.prepared.name === \"drag\") {\n        var o = r.dropState;\n        ir(r, o.events), e.fire(\"actions/drop:move\", { interaction: r, dragEvent: n }), o.events = {};\n      }\n    }, \"interactions:action-end\": function(t, e) {\n      if (t.interaction.prepared.name === \"drag\") {\n        var r = t.interaction, n = t.iEvent;\n        sn(t, e), ir(r, r.dropState.events), e.fire(\"actions/drop:end\", { interaction: r, dragEvent: n });\n      }\n    }, \"interactions:stop\": function(t) {\n      var e = t.interaction;\n      if (e.prepared.name === \"drag\") {\n        var r = e.dropState;\n        r && (r.activeDrops = null, r.events = null, r.cur.dropzone = null, r.cur.element = null, r.prev.dropzone = null, r.prev.element = null, r.rejected = !1);\n      }\n    } }, getActiveDrops: rr, getDrop: on, getDropEvents: nr, fireDropEvents: ir, filterEventType: function(t) {\n      return t.search(\"drag\") === 0 || t.search(\"drop\") === 0;\n    }, defaults: { enabled: !1, accept: null, overlap: \"pointer\" } }, co = an;\n    function or(t) {\n      var e = t.interaction, r = t.iEvent, n = t.phase;\n      if (e.prepared.name === \"gesture\") {\n        var o = e.pointers.map(function(g) {\n          return g.pointer;\n        }), l = n === \"start\", c = n === \"end\", p = e.interactable.options.deltaSource;\n        if (r.touches = [o[0], o[1]], l) r.distance = er(o, p), r.box = Qt(o), r.scale = 1, r.ds = 0, r.angle = tr(o, p), r.da = 0, e.gesture.startDistance = r.distance, e.gesture.startAngle = r.angle;\n        else if (c || e.pointers.length < 2) {\n          var h = e.prevEvent;\n          r.distance = h.distance, r.box = h.box, r.scale = h.scale, r.ds = 0, r.angle = h.angle, r.da = 0;\n        } else r.distance = er(o, p), r.box = Qt(o), r.scale = r.distance / e.gesture.startDistance, r.angle = tr(o, p), r.ds = r.scale - e.gesture.scale, r.da = r.angle - e.gesture.angle;\n        e.gesture.distance = r.distance, e.gesture.angle = r.angle, S.number(r.scale) && r.scale !== 1 / 0 && !isNaN(r.scale) && (e.gesture.scale = r.scale);\n      }\n    }\n    var sr = { id: \"actions/gesture\", before: [\"actions/drag\", \"actions/resize\"], install: function(t) {\n      var e = t.actions, r = t.Interactable, n = t.defaults;\n      r.prototype.gesturable = function(o) {\n        return S.object(o) ? (this.options.gesture.enabled = o.enabled !== !1, this.setPerAction(\"gesture\", o), this.setOnEvents(\"gesture\", o), this) : S.bool(o) ? (this.options.gesture.enabled = o, this) : this.options.gesture;\n      }, e.map.gesture = sr, e.methodDict.gesture = \"gesturable\", n.actions.gesture = sr.defaults;\n    }, listeners: { \"interactions:action-start\": or, \"interactions:action-move\": or, \"interactions:action-end\": or, \"interactions:new\": function(t) {\n      t.interaction.gesture = { angle: 0, distance: 0, scale: 1, startAngle: 0, startDistance: 0 };\n    }, \"auto-start:check\": function(t) {\n      if (!(t.interaction.pointers.length < 2)) {\n        var e = t.interactable.options.gesture;\n        if (e && e.enabled) return t.action = { name: \"gesture\" }, !1;\n      }\n    } }, defaults: {}, getCursor: function() {\n      return \"\";\n    }, filterEventType: function(t) {\n      return t.search(\"gesture\") === 0;\n    } }, uo = sr;\n    function po(t, e, r, n, o, l, c) {\n      if (!e) return !1;\n      if (e === !0) {\n        var p = S.number(l.width) ? l.width : l.right - l.left, h = S.number(l.height) ? l.height : l.bottom - l.top;\n        if (c = Math.min(c, Math.abs((t === \"left\" || t === \"right\" ? p : h) / 2)), p < 0 && (t === \"left\" ? t = \"right\" : t === \"right\" && (t = \"left\")), h < 0 && (t === \"top\" ? t = \"bottom\" : t === \"bottom\" && (t = \"top\")), t === \"left\") {\n          var g = p >= 0 ? l.left : l.right;\n          return r.x < g + c;\n        }\n        if (t === \"top\") {\n          var d = h >= 0 ? l.top : l.bottom;\n          return r.y < d + c;\n        }\n        if (t === \"right\") return r.x > (p >= 0 ? l.right : l.left) - c;\n        if (t === \"bottom\") return r.y > (h >= 0 ? l.bottom : l.top) - c;\n      }\n      return !!S.element(n) && (S.element(e) ? e === n : pe(n, e, o));\n    }\n    function ln(t) {\n      var e = t.iEvent, r = t.interaction;\n      if (r.prepared.name === \"resize\" && r.resizeAxes) {\n        var n = e;\n        r.interactable.options.resize.square ? (r.resizeAxes === \"y\" ? n.delta.x = n.delta.y : n.delta.y = n.delta.x, n.axes = \"xy\") : (n.axes = r.resizeAxes, r.resizeAxes === \"x\" ? n.delta.y = 0 : r.resizeAxes === \"y\" && (n.delta.x = 0));\n      }\n    }\n    var Ie, Ne, Pe = { id: \"actions/resize\", before: [\"actions/drag\"], install: function(t) {\n      var e = t.actions, r = t.browser, n = t.Interactable, o = t.defaults;\n      Pe.cursors = function(l) {\n        return l.isIe9 ? { x: \"e-resize\", y: \"s-resize\", xy: \"se-resize\", top: \"n-resize\", left: \"w-resize\", bottom: \"s-resize\", right: \"e-resize\", topleft: \"se-resize\", bottomright: \"se-resize\", topright: \"ne-resize\", bottomleft: \"ne-resize\" } : { x: \"ew-resize\", y: \"ns-resize\", xy: \"nwse-resize\", top: \"ns-resize\", left: \"ew-resize\", bottom: \"ns-resize\", right: \"ew-resize\", topleft: \"nwse-resize\", bottomright: \"nwse-resize\", topright: \"nesw-resize\", bottomleft: \"nesw-resize\" };\n      }(r), Pe.defaultMargin = r.supportsTouch || r.supportsPointerEvent ? 20 : 10, n.prototype.resizable = function(l) {\n        return function(c, p, h) {\n          return S.object(p) ? (c.options.resize.enabled = p.enabled !== !1, c.setPerAction(\"resize\", p), c.setOnEvents(\"resize\", p), S.string(p.axis) && /^x$|^y$|^xy$/.test(p.axis) ? c.options.resize.axis = p.axis : p.axis === null && (c.options.resize.axis = h.defaults.actions.resize.axis), S.bool(p.preserveAspectRatio) ? c.options.resize.preserveAspectRatio = p.preserveAspectRatio : S.bool(p.square) && (c.options.resize.square = p.square), c) : S.bool(p) ? (c.options.resize.enabled = p, c) : c.options.resize;\n        }(this, l, t);\n      }, e.map.resize = Pe, e.methodDict.resize = \"resizable\", o.actions.resize = Pe.defaults;\n    }, listeners: { \"interactions:new\": function(t) {\n      t.interaction.resizeAxes = \"xy\";\n    }, \"interactions:action-start\": function(t) {\n      (function(e) {\n        var r = e.iEvent, n = e.interaction;\n        if (n.prepared.name === \"resize\" && n.prepared.edges) {\n          var o = r, l = n.rect;\n          n._rects = { start: H({}, l), corrected: H({}, l), previous: H({}, l), delta: { left: 0, right: 0, width: 0, top: 0, bottom: 0, height: 0 } }, o.edges = n.prepared.edges, o.rect = n._rects.corrected, o.deltaRect = n._rects.delta;\n        }\n      })(t), ln(t);\n    }, \"interactions:action-move\": function(t) {\n      (function(e) {\n        var r = e.iEvent, n = e.interaction;\n        if (n.prepared.name === \"resize\" && n.prepared.edges) {\n          var o = r, l = n.interactable.options.resize.invert, c = l === \"reposition\" || l === \"negate\", p = n.rect, h = n._rects, g = h.start, d = h.corrected, b = h.delta, w = h.previous;\n          if (H(w, d), c) {\n            if (H(d, p), l === \"reposition\") {\n              if (d.top > d.bottom) {\n                var I = d.top;\n                d.top = d.bottom, d.bottom = I;\n              }\n              if (d.left > d.right) {\n                var E = d.left;\n                d.left = d.right, d.right = E;\n              }\n            }\n          } else d.top = Math.min(p.top, g.bottom), d.bottom = Math.max(p.bottom, g.top), d.left = Math.min(p.left, g.right), d.right = Math.max(p.right, g.left);\n          for (var D in d.width = d.right - d.left, d.height = d.bottom - d.top, d) b[D] = d[D] - w[D];\n          o.edges = n.prepared.edges, o.rect = d, o.deltaRect = b;\n        }\n      })(t), ln(t);\n    }, \"interactions:action-end\": function(t) {\n      var e = t.iEvent, r = t.interaction;\n      if (r.prepared.name === \"resize\" && r.prepared.edges) {\n        var n = e;\n        n.edges = r.prepared.edges, n.rect = r._rects.corrected, n.deltaRect = r._rects.delta;\n      }\n    }, \"auto-start:check\": function(t) {\n      var e = t.interaction, r = t.interactable, n = t.element, o = t.rect, l = t.buttons;\n      if (o) {\n        var c = H({}, e.coords.cur.page), p = r.options.resize;\n        if (p && p.enabled && (!e.pointerIsDown || !/mouse|pointer/.test(e.pointerType) || l & p.mouseButtons)) {\n          if (S.object(p.edges)) {\n            var h = { left: !1, right: !1, top: !1, bottom: !1 };\n            for (var g in h) h[g] = po(g, p.edges[g], c, e._latestPointer.eventTarget, n, o, p.margin || Pe.defaultMargin);\n            h.left = h.left && !h.right, h.top = h.top && !h.bottom, (h.left || h.right || h.top || h.bottom) && (t.action = { name: \"resize\", edges: h });\n          } else {\n            var d = p.axis !== \"y\" && c.x > o.right - Pe.defaultMargin, b = p.axis !== \"x\" && c.y > o.bottom - Pe.defaultMargin;\n            (d || b) && (t.action = { name: \"resize\", axes: (d ? \"x\" : \"\") + (b ? \"y\" : \"\") });\n          }\n          return !t.action && void 0;\n        }\n      }\n    } }, defaults: { square: !1, preserveAspectRatio: !1, axis: \"xy\", margin: NaN, edges: null, invert: \"none\" }, cursors: null, getCursor: function(t) {\n      var e = t.edges, r = t.axis, n = t.name, o = Pe.cursors, l = null;\n      if (r) l = o[n + r];\n      else if (e) {\n        for (var c = \"\", p = 0, h = [\"top\", \"bottom\", \"left\", \"right\"]; p < h.length; p++) {\n          var g = h[p];\n          e[g] && (c += g);\n        }\n        l = o[c];\n      }\n      return l;\n    }, filterEventType: function(t) {\n      return t.search(\"resize\") === 0;\n    }, defaultMargin: null }, ho = Pe, fo = { id: \"actions\", install: function(t) {\n      t.usePlugin(uo), t.usePlugin(ho), t.usePlugin(ne), t.usePlugin(co);\n    } }, cn = 0, je = { request: function(t) {\n      return Ie(t);\n    }, cancel: function(t) {\n      return Ne(t);\n    }, init: function(t) {\n      if (Ie = t.requestAnimationFrame, Ne = t.cancelAnimationFrame, !Ie) for (var e = [\"ms\", \"moz\", \"webkit\", \"o\"], r = 0; r < e.length; r++) {\n        var n = e[r];\n        Ie = t[\"\".concat(n, \"RequestAnimationFrame\")], Ne = t[\"\".concat(n, \"CancelAnimationFrame\")] || t[\"\".concat(n, \"CancelRequestAnimationFrame\")];\n      }\n      Ie = Ie && Ie.bind(t), Ne = Ne && Ne.bind(t), Ie || (Ie = function(o) {\n        var l = Date.now(), c = Math.max(0, 16 - (l - cn)), p = t.setTimeout(function() {\n          o(l + c);\n        }, c);\n        return cn = l + c, p;\n      }, Ne = function(o) {\n        return clearTimeout(o);\n      });\n    } }, V = { defaults: { enabled: !1, margin: 60, container: null, speed: 300 }, now: Date.now, interaction: null, i: 0, x: 0, y: 0, isScrolling: !1, prevTime: 0, margin: 0, speed: 0, start: function(t) {\n      V.isScrolling = !0, je.cancel(V.i), t.autoScroll = V, V.interaction = t, V.prevTime = V.now(), V.i = je.request(V.scroll);\n    }, stop: function() {\n      V.isScrolling = !1, V.interaction && (V.interaction.autoScroll = null), je.cancel(V.i);\n    }, scroll: function() {\n      var t = V.interaction, e = t.interactable, r = t.element, n = t.prepared.name, o = e.options[n].autoScroll, l = un(o.container, e, r), c = V.now(), p = (c - V.prevTime) / 1e3, h = o.speed * p;\n      if (h >= 1) {\n        var g = { x: V.x * h, y: V.y * h };\n        if (g.x || g.y) {\n          var d = pn(l);\n          S.window(l) ? l.scrollBy(g.x, g.y) : l && (l.scrollLeft += g.x, l.scrollTop += g.y);\n          var b = pn(l), w = { x: b.x - d.x, y: b.y - d.y };\n          (w.x || w.y) && e.fire({ type: \"autoscroll\", target: r, interactable: e, delta: w, interaction: t, container: l });\n        }\n        V.prevTime = c;\n      }\n      V.isScrolling && (je.cancel(V.i), V.i = je.request(V.scroll));\n    }, check: function(t, e) {\n      var r;\n      return (r = t.options[e].autoScroll) == null ? void 0 : r.enabled;\n    }, onInteractionMove: function(t) {\n      var e = t.interaction, r = t.pointer;\n      if (e.interacting() && V.check(e.interactable, e.prepared.name)) if (e.simulation) V.x = V.y = 0;\n      else {\n        var n, o, l, c, p = e.interactable, h = e.element, g = e.prepared.name, d = p.options[g].autoScroll, b = un(d.container, p, h);\n        if (S.window(b)) c = r.clientX < V.margin, n = r.clientY < V.margin, o = r.clientX > b.innerWidth - V.margin, l = r.clientY > b.innerHeight - V.margin;\n        else {\n          var w = ve(b);\n          c = r.clientX < w.left + V.margin, n = r.clientY < w.top + V.margin, o = r.clientX > w.right - V.margin, l = r.clientY > w.bottom - V.margin;\n        }\n        V.x = o ? 1 : c ? -1 : 0, V.y = l ? 1 : n ? -1 : 0, V.isScrolling || (V.margin = d.margin, V.speed = d.speed, V.start(e));\n      }\n    } };\n    function un(t, e, r) {\n      return (S.string(t) ? fe(t, e, r) : t) || te(r);\n    }\n    function pn(t) {\n      return S.window(t) && (t = window.document.body), { x: t.scrollLeft, y: t.scrollTop };\n    }\n    var vo = { id: \"auto-scroll\", install: function(t) {\n      var e = t.defaults, r = t.actions;\n      t.autoScroll = V, V.now = function() {\n        return t.now();\n      }, r.phaselessTypes.autoscroll = !0, e.perAction.autoScroll = V.defaults;\n    }, listeners: { \"interactions:new\": function(t) {\n      t.interaction.autoScroll = null;\n    }, \"interactions:destroy\": function(t) {\n      t.interaction.autoScroll = null, V.stop(), V.interaction && (V.interaction = null);\n    }, \"interactions:stop\": V.stop, \"interactions:action-move\": function(t) {\n      return V.onInteractionMove(t);\n    } } }, go = vo;\n    function ct(t, e) {\n      var r = !1;\n      return function() {\n        return r || (G.console.warn(e), r = !0), t.apply(this, arguments);\n      };\n    }\n    function ar(t, e) {\n      return t.name = e.name, t.axis = e.axis, t.edges = e.edges, t;\n    }\n    function mo(t) {\n      return S.bool(t) ? (this.options.styleCursor = t, this) : t === null ? (delete this.options.styleCursor, this) : this.options.styleCursor;\n    }\n    function bo(t) {\n      return S.func(t) ? (this.options.actionChecker = t, this) : t === null ? (delete this.options.actionChecker, this) : this.options.actionChecker;\n    }\n    var yo = { id: \"auto-start/interactableMethods\", install: function(t) {\n      var e = t.Interactable;\n      e.prototype.getAction = function(r, n, o, l) {\n        var c = function(p, h, g, d, b) {\n          var w = p.getRect(d), I = h.buttons || { 0: 1, 1: 4, 3: 8, 4: 16 }[h.button], E = { action: null, interactable: p, interaction: g, element: d, rect: w, buttons: I };\n          return b.fire(\"auto-start:check\", E), E.action;\n        }(this, n, o, l, t);\n        return this.options.actionChecker ? this.options.actionChecker(r, n, c, this, l, o) : c;\n      }, e.prototype.ignoreFrom = ct(function(r) {\n        return this._backCompatOption(\"ignoreFrom\", r);\n      }, \"Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).\"), e.prototype.allowFrom = ct(function(r) {\n        return this._backCompatOption(\"allowFrom\", r);\n      }, \"Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).\"), e.prototype.actionChecker = bo, e.prototype.styleCursor = mo;\n    } };\n    function hn(t, e, r, n, o) {\n      return e.testIgnoreAllow(e.options[t.name], r, n) && e.options[t.name].enabled && St(e, r, t, o) ? t : null;\n    }\n    function To(t, e, r, n, o, l, c) {\n      for (var p = 0, h = n.length; p < h; p++) {\n        var g = n[p], d = o[p], b = g.getAction(e, r, t, d);\n        if (b) {\n          var w = hn(b, g, d, l, c);\n          if (w) return { action: w, interactable: g, element: d };\n        }\n      }\n      return { action: null, interactable: null, element: null };\n    }\n    function dn(t, e, r, n, o) {\n      var l = [], c = [], p = n;\n      function h(d) {\n        l.push(d), c.push(p);\n      }\n      for (; S.element(p); ) {\n        l = [], c = [], o.interactables.forEachMatch(p, h);\n        var g = To(t, e, r, l, c, n, o);\n        if (g.action && !g.interactable.options[g.action.name].manualStart) return g;\n        p = K(p);\n      }\n      return { action: null, interactable: null, element: null };\n    }\n    function fn(t, e, r) {\n      var n = e.action, o = e.interactable, l = e.element;\n      n = n || { name: null }, t.interactable = o, t.element = l, ar(t.prepared, n), t.rect = o && n.name ? o.getRect(l) : null, gn(t, r), r.fire(\"autoStart:prepared\", { interaction: t });\n    }\n    function St(t, e, r, n) {\n      var o = t.options, l = o[r.name].max, c = o[r.name].maxPerElement, p = n.autoStart.maxInteractions, h = 0, g = 0, d = 0;\n      if (!(l && c && p)) return !1;\n      for (var b = 0, w = n.interactions.list; b < w.length; b++) {\n        var I = w[b], E = I.prepared.name;\n        if (I.interacting() && (++h >= p || I.interactable === t && ((g += E === r.name ? 1 : 0) >= l || I.element === e && (d++, E === r.name && d >= c))))\n          return !1;\n      }\n      return p > 0;\n    }\n    function vn(t, e) {\n      return S.number(t) ? (e.autoStart.maxInteractions = t, this) : e.autoStart.maxInteractions;\n    }\n    function lr(t, e, r) {\n      var n = r.autoStart.cursorElement;\n      n && n !== t && (n.style.cursor = \"\"), t.ownerDocument.documentElement.style.cursor = e, t.style.cursor = e, r.autoStart.cursorElement = e ? t : null;\n    }\n    function gn(t, e) {\n      var r = t.interactable, n = t.element, o = t.prepared;\n      if (t.pointerType === \"mouse\" && r && r.options.styleCursor) {\n        var l = \"\";\n        if (o.name) {\n          var c = r.options[o.name].cursorChecker;\n          l = S.func(c) ? c(o, r, n, t._interacting) : e.actions.map[o.name].getCursor(o);\n        }\n        lr(t.element, l || \"\", e);\n      } else e.autoStart.cursorElement && lr(e.autoStart.cursorElement, \"\", e);\n    }\n    var wo = { id: \"auto-start/base\", before: [\"actions\"], install: function(t) {\n      var e = t.interactStatic, r = t.defaults;\n      t.usePlugin(yo), r.base.actionChecker = null, r.base.styleCursor = !0, H(r.perAction, { manualStart: !1, max: 1 / 0, maxPerElement: 1, allowFrom: null, ignoreFrom: null, mouseButtons: 1 }), e.maxInteractions = function(n) {\n        return vn(n, t);\n      }, t.autoStart = { maxInteractions: 1 / 0, withinInteractionLimit: St, cursorElement: null };\n    }, listeners: { \"interactions:down\": function(t, e) {\n      var r = t.interaction, n = t.pointer, o = t.event, l = t.eventTarget;\n      r.interacting() || fn(r, dn(r, n, o, l, e), e);\n    }, \"interactions:move\": function(t, e) {\n      (function(r, n) {\n        var o = r.interaction, l = r.pointer, c = r.event, p = r.eventTarget;\n        o.pointerType !== \"mouse\" || o.pointerIsDown || o.interacting() || fn(o, dn(o, l, c, p, n), n);\n      })(t, e), function(r, n) {\n        var o = r.interaction;\n        if (o.pointerIsDown && !o.interacting() && o.pointerWasMoved && o.prepared.name) {\n          n.fire(\"autoStart:before-start\", r);\n          var l = o.interactable, c = o.prepared.name;\n          c && l && (l.options[c].manualStart || !St(l, o.element, o.prepared, n) ? o.stop() : (o.start(o.prepared, l, o.element), gn(o, n)));\n        }\n      }(t, e);\n    }, \"interactions:stop\": function(t, e) {\n      var r = t.interaction, n = r.interactable;\n      n && n.options.styleCursor && lr(r.element, \"\", e);\n    } }, maxInteractions: vn, withinInteractionLimit: St, validateAction: hn }, cr = wo, So = { id: \"auto-start/dragAxis\", listeners: { \"autoStart:before-start\": function(t, e) {\n      var r = t.interaction, n = t.eventTarget, o = t.dx, l = t.dy;\n      if (r.prepared.name === \"drag\") {\n        var c = Math.abs(o), p = Math.abs(l), h = r.interactable.options.drag, g = h.startAxis, d = c > p ? \"x\" : c < p ? \"y\" : \"xy\";\n        if (r.prepared.axis = h.lockAxis === \"start\" ? d[0] : h.lockAxis, d !== \"xy\" && g !== \"xy\" && g !== d) {\n          r.prepared.name = null;\n          for (var b = n, w = function(E) {\n            if (E !== r.interactable) {\n              var D = r.interactable.options.drag;\n              if (!D.manualStart && E.testIgnoreAllow(D, b, n)) {\n                var L = E.getAction(r.downPointer, r.downEvent, r, b);\n                if (L && L.name === \"drag\" && function(j, Y) {\n                  if (!Y) return !1;\n                  var q = Y.options.drag.startAxis;\n                  return j === \"xy\" || q === \"xy\" || q === j;\n                }(d, E) && cr.validateAction(L, E, b, n, e)) return E;\n              }\n            }\n          }; S.element(b); ) {\n            var I = e.interactables.forEachMatch(b, w);\n            if (I) {\n              r.prepared.name = \"drag\", r.interactable = I, r.element = b;\n              break;\n            }\n            b = K(b);\n          }\n        }\n      }\n    } } };\n    function ur(t) {\n      var e = t.prepared && t.prepared.name;\n      if (!e) return null;\n      var r = t.interactable.options;\n      return r[e].hold || r[e].delay;\n    }\n    var xo = { id: \"auto-start/hold\", install: function(t) {\n      var e = t.defaults;\n      t.usePlugin(cr), e.perAction.hold = 0, e.perAction.delay = 0;\n    }, listeners: { \"interactions:new\": function(t) {\n      t.interaction.autoStartHoldTimer = null;\n    }, \"autoStart:prepared\": function(t) {\n      var e = t.interaction, r = ur(e);\n      r > 0 && (e.autoStartHoldTimer = setTimeout(function() {\n        e.start(e.prepared, e.interactable, e.element);\n      }, r));\n    }, \"interactions:move\": function(t) {\n      var e = t.interaction, r = t.duplicate;\n      e.autoStartHoldTimer && e.pointerWasMoved && !r && (clearTimeout(e.autoStartHoldTimer), e.autoStartHoldTimer = null);\n    }, \"autoStart:before-start\": function(t) {\n      var e = t.interaction;\n      ur(e) > 0 && (e.prepared.name = null);\n    } }, getHoldDuration: ur }, Oo = xo, Co = { id: \"auto-start\", install: function(t) {\n      t.usePlugin(cr), t.usePlugin(Oo), t.usePlugin(So);\n    } }, _o = function(t) {\n      return /^(always|never|auto)$/.test(t) ? (this.options.preventDefault = t, this) : S.bool(t) ? (this.options.preventDefault = t ? \"always\" : \"never\", this) : this.options.preventDefault;\n    };\n    function Mo(t) {\n      var e = t.interaction, r = t.event;\n      e.interactable && e.interactable.checkAndPreventDefault(r);\n    }\n    var mn = { id: \"core/interactablePreventDefault\", install: function(t) {\n      var e = t.Interactable;\n      e.prototype.preventDefault = _o, e.prototype.checkAndPreventDefault = function(r) {\n        return function(n, o, l) {\n          var c = n.options.preventDefault;\n          if (c !== \"never\") if (c !== \"always\") {\n            if (o.events.supportsPassive && /^touch(start|move)$/.test(l.type)) {\n              var p = te(l.target).document, h = o.getDocOptions(p);\n              if (!h || !h.events || h.events.passive !== !1) return;\n            }\n            /^(mouse|pointer|touch)*(down|start)/i.test(l.type) || S.element(l.target) && X(l.target, \"input,select,textarea,[contenteditable=true],[contenteditable=true] *\") || l.preventDefault();\n          } else l.preventDefault();\n        }(this, t, r);\n      }, t.interactions.docEvents.push({ type: \"dragstart\", listener: function(r) {\n        for (var n = 0, o = t.interactions.list; n < o.length; n++) {\n          var l = o[n];\n          if (l.element && (l.element === r.target || F(l.element, r.target))) return void l.interactable.checkAndPreventDefault(r);\n        }\n      } });\n    }, listeners: [\"down\", \"move\", \"up\", \"cancel\"].reduce(function(t, e) {\n      return t[\"interactions:\".concat(e)] = Mo, t;\n    }, {}) };\n    function xt(t, e) {\n      if (e.phaselessTypes[t]) return !0;\n      for (var r in e.map) if (t.indexOf(r) === 0 && t.substr(r.length) in e.phases) return !0;\n      return !1;\n    }\n    function Be(t) {\n      var e = {};\n      for (var r in t) {\n        var n = t[r];\n        S.plainObject(n) ? e[r] = Be(n) : S.array(n) ? e[r] = rn(n) : e[r] = n;\n      }\n      return e;\n    }\n    var pr = function() {\n      function t(e) {\n        v(this, t), this.states = [], this.startOffset = { left: 0, right: 0, top: 0, bottom: 0 }, this.startDelta = void 0, this.result = void 0, this.endResult = void 0, this.startEdges = void 0, this.edges = void 0, this.interaction = void 0, this.interaction = e, this.result = Ot(), this.edges = { left: !1, right: !1, top: !1, bottom: !1 };\n      }\n      return y(t, [{ key: \"start\", value: function(e, r) {\n        var n, o, l = e.phase, c = this.interaction, p = function(g) {\n          var d = g.interactable.options[g.prepared.name], b = d.modifiers;\n          return b && b.length ? b : [\"snap\", \"snapSize\", \"snapEdges\", \"restrict\", \"restrictEdges\", \"restrictSize\"].map(function(w) {\n            var I = d[w];\n            return I && I.enabled && { options: I, methods: I._methods };\n          }).filter(function(w) {\n            return !!w;\n          });\n        }(c);\n        this.prepareStates(p), this.startEdges = H({}, c.edges), this.edges = H({}, this.startEdges), this.startOffset = (n = c.rect, o = r, n ? { left: o.x - n.left, top: o.y - n.top, right: n.right - o.x, bottom: n.bottom - o.y } : { left: 0, top: 0, right: 0, bottom: 0 }), this.startDelta = { x: 0, y: 0 };\n        var h = this.fillArg({ phase: l, pageCoords: r, preEnd: !1 });\n        return this.result = Ot(), this.startAll(h), this.result = this.setAll(h);\n      } }, { key: \"fillArg\", value: function(e) {\n        var r = this.interaction;\n        return e.interaction = r, e.interactable = r.interactable, e.element = r.element, e.rect || (e.rect = r.rect), e.edges || (e.edges = this.startEdges), e.startOffset = this.startOffset, e;\n      } }, { key: \"startAll\", value: function(e) {\n        for (var r = 0, n = this.states; r < n.length; r++) {\n          var o = n[r];\n          o.methods.start && (e.state = o, o.methods.start(e));\n        }\n      } }, { key: \"setAll\", value: function(e) {\n        var r = e.phase, n = e.preEnd, o = e.skipModifiers, l = e.rect, c = e.edges;\n        e.coords = H({}, e.pageCoords), e.rect = H({}, l), e.edges = H({}, c);\n        for (var p = o ? this.states.slice(o) : this.states, h = Ot(e.coords, e.rect), g = 0; g < p.length; g++) {\n          var d, b = p[g], w = b.options, I = H({}, e.coords), E = null;\n          (d = b.methods) != null && d.set && this.shouldDo(w, n, r) && (e.state = b, E = b.methods.set(e), mt(e.edges, e.rect, { x: e.coords.x - I.x, y: e.coords.y - I.y })), h.eventProps.push(E);\n        }\n        H(this.edges, e.edges), h.delta.x = e.coords.x - e.pageCoords.x, h.delta.y = e.coords.y - e.pageCoords.y, h.rectDelta.left = e.rect.left - l.left, h.rectDelta.right = e.rect.right - l.right, h.rectDelta.top = e.rect.top - l.top, h.rectDelta.bottom = e.rect.bottom - l.bottom;\n        var D = this.result.coords, L = this.result.rect;\n        if (D && L) {\n          var j = h.rect.left !== L.left || h.rect.right !== L.right || h.rect.top !== L.top || h.rect.bottom !== L.bottom;\n          h.changed = j || D.x !== h.coords.x || D.y !== h.coords.y;\n        }\n        return h;\n      } }, { key: \"applyToInteraction\", value: function(e) {\n        var r = this.interaction, n = e.phase, o = r.coords.cur, l = r.coords.start, c = this.result, p = this.startDelta, h = c.delta;\n        n === \"start\" && H(this.startDelta, c.delta);\n        for (var g = 0, d = [[l, p], [o, h]]; g < d.length; g++) {\n          var b = d[g], w = b[0], I = b[1];\n          w.page.x += I.x, w.page.y += I.y, w.client.x += I.x, w.client.y += I.y;\n        }\n        var E = this.result.rectDelta, D = e.rect || r.rect;\n        D.left += E.left, D.right += E.right, D.top += E.top, D.bottom += E.bottom, D.width = D.right - D.left, D.height = D.bottom - D.top;\n      } }, { key: \"setAndApply\", value: function(e) {\n        var r = this.interaction, n = e.phase, o = e.preEnd, l = e.skipModifiers, c = this.setAll(this.fillArg({ preEnd: o, phase: n, pageCoords: e.modifiedCoords || r.coords.cur.page }));\n        if (this.result = c, !c.changed && (!l || l < this.states.length) && r.interacting()) return !1;\n        if (e.modifiedCoords) {\n          var p = r.coords.cur.page, h = { x: e.modifiedCoords.x - p.x, y: e.modifiedCoords.y - p.y };\n          c.coords.x += h.x, c.coords.y += h.y, c.delta.x += h.x, c.delta.y += h.y;\n        }\n        this.applyToInteraction(e);\n      } }, { key: \"beforeEnd\", value: function(e) {\n        var r = e.interaction, n = e.event, o = this.states;\n        if (o && o.length) {\n          for (var l = !1, c = 0; c < o.length; c++) {\n            var p = o[c];\n            e.state = p;\n            var h = p.options, g = p.methods, d = g.beforeEnd && g.beforeEnd(e);\n            if (d) return this.endResult = d, !1;\n            l = l || !l && this.shouldDo(h, !0, e.phase, !0);\n          }\n          l && r.move({ event: n, preEnd: !0 });\n        }\n      } }, { key: \"stop\", value: function(e) {\n        var r = e.interaction;\n        if (this.states && this.states.length) {\n          var n = H({ states: this.states, interactable: r.interactable, element: r.element, rect: null }, e);\n          this.fillArg(n);\n          for (var o = 0, l = this.states; o < l.length; o++) {\n            var c = l[o];\n            n.state = c, c.methods.stop && c.methods.stop(n);\n          }\n          this.states = null, this.endResult = null;\n        }\n      } }, { key: \"prepareStates\", value: function(e) {\n        this.states = [];\n        for (var r = 0; r < e.length; r++) {\n          var n = e[r], o = n.options, l = n.methods, c = n.name;\n          this.states.push({ options: o, methods: l, index: r, name: c });\n        }\n        return this.states;\n      } }, { key: \"restoreInteractionCoords\", value: function(e) {\n        var r = e.interaction, n = r.coords, o = r.rect, l = r.modification;\n        if (l.result) {\n          for (var c = l.startDelta, p = l.result, h = p.delta, g = p.rectDelta, d = 0, b = [[n.start, c], [n.cur, h]]; d < b.length; d++) {\n            var w = b[d], I = w[0], E = w[1];\n            I.page.x -= E.x, I.page.y -= E.y, I.client.x -= E.x, I.client.y -= E.y;\n          }\n          o.left -= g.left, o.right -= g.right, o.top -= g.top, o.bottom -= g.bottom;\n        }\n      } }, { key: \"shouldDo\", value: function(e, r, n, o) {\n        return !(!e || e.enabled === !1 || o && !e.endOnly || e.endOnly && !r || n === \"start\" && !e.setStart);\n      } }, { key: \"copyFrom\", value: function(e) {\n        this.startOffset = e.startOffset, this.startDelta = e.startDelta, this.startEdges = e.startEdges, this.edges = e.edges, this.states = e.states.map(function(r) {\n          return Be(r);\n        }), this.result = Ot(H({}, e.result.coords), H({}, e.result.rect));\n      } }, { key: \"destroy\", value: function() {\n        for (var e in this) this[e] = null;\n      } }]), t;\n    }();\n    function Ot(t, e) {\n      return { rect: e, coords: t, delta: { x: 0, y: 0 }, rectDelta: { left: 0, right: 0, top: 0, bottom: 0 }, eventProps: [], changed: !0 };\n    }\n    function Ae(t, e) {\n      var r = t.defaults, n = { start: t.start, set: t.set, beforeEnd: t.beforeEnd, stop: t.stop }, o = function(l) {\n        var c = l || {};\n        for (var p in c.enabled = c.enabled !== !1, r) p in c || (c[p] = r[p]);\n        var h = { options: c, methods: n, name: e, enable: function() {\n          return c.enabled = !0, h;\n        }, disable: function() {\n          return c.enabled = !1, h;\n        } };\n        return h;\n      };\n      return e && typeof e == \"string\" && (o._defaults = r, o._methods = n), o;\n    }\n    function ut(t) {\n      var e = t.iEvent, r = t.interaction.modification.result;\n      r && (e.modifiers = r.eventProps);\n    }\n    var Eo = { id: \"modifiers/base\", before: [\"actions\"], install: function(t) {\n      t.defaults.perAction.modifiers = [];\n    }, listeners: { \"interactions:new\": function(t) {\n      var e = t.interaction;\n      e.modification = new pr(e);\n    }, \"interactions:before-action-start\": function(t) {\n      var e = t.interaction, r = t.interaction.modification;\n      r.start(t, e.coords.start.page), e.edges = r.edges, r.applyToInteraction(t);\n    }, \"interactions:before-action-move\": function(t) {\n      var e = t.interaction, r = e.modification, n = r.setAndApply(t);\n      return e.edges = r.edges, n;\n    }, \"interactions:before-action-end\": function(t) {\n      var e = t.interaction, r = e.modification, n = r.beforeEnd(t);\n      return e.edges = r.startEdges, n;\n    }, \"interactions:action-start\": ut, \"interactions:action-move\": ut, \"interactions:action-end\": ut, \"interactions:after-action-start\": function(t) {\n      return t.interaction.modification.restoreInteractionCoords(t);\n    }, \"interactions:after-action-move\": function(t) {\n      return t.interaction.modification.restoreInteractionCoords(t);\n    }, \"interactions:stop\": function(t) {\n      return t.interaction.modification.stop(t);\n    } } }, bn = Eo, yn = { base: { preventDefault: \"auto\", deltaSource: \"page\" }, perAction: { enabled: !1, origin: { x: 0, y: 0 } }, actions: {} }, hr = function(t) {\n      O(r, t);\n      var e = _(r);\n      function r(n, o, l, c, p, h, g) {\n        var d;\n        v(this, r), (d = e.call(this, n)).relatedTarget = null, d.screenX = void 0, d.screenY = void 0, d.button = void 0, d.buttons = void 0, d.ctrlKey = void 0, d.shiftKey = void 0, d.altKey = void 0, d.metaKey = void 0, d.page = void 0, d.client = void 0, d.delta = void 0, d.rect = void 0, d.x0 = void 0, d.y0 = void 0, d.t0 = void 0, d.dt = void 0, d.duration = void 0, d.clientX0 = void 0, d.clientY0 = void 0, d.velocity = void 0, d.speed = void 0, d.swipe = void 0, d.axes = void 0, d.preEnd = void 0, p = p || n.element;\n        var b = n.interactable, w = (b && b.options || yn).deltaSource, I = it(b, p, l), E = c === \"start\", D = c === \"end\", L = E ? T(d) : n.prevEvent, j = E ? n.coords.start : D ? { page: L.page, client: L.client, timeStamp: n.coords.cur.timeStamp } : n.coords.cur;\n        return d.page = H({}, j.page), d.client = H({}, j.client), d.rect = H({}, n.rect), d.timeStamp = j.timeStamp, D || (d.page.x -= I.x, d.page.y -= I.y, d.client.x -= I.x, d.client.y -= I.y), d.ctrlKey = o.ctrlKey, d.altKey = o.altKey, d.shiftKey = o.shiftKey, d.metaKey = o.metaKey, d.button = o.button, d.buttons = o.buttons, d.target = p, d.currentTarget = p, d.preEnd = h, d.type = g || l + (c || \"\"), d.interactable = b, d.t0 = E ? n.pointers[n.pointers.length - 1].downTime : L.t0, d.x0 = n.coords.start.page.x - I.x, d.y0 = n.coords.start.page.y - I.y, d.clientX0 = n.coords.start.client.x - I.x, d.clientY0 = n.coords.start.client.y - I.y, d.delta = E || D ? { x: 0, y: 0 } : { x: d[w].x - L[w].x, y: d[w].y - L[w].y }, d.dt = n.coords.delta.timeStamp, d.duration = d.timeStamp - d.t0, d.velocity = H({}, n.coords.velocity[w]), d.speed = ot(d.velocity.x, d.velocity.y), d.swipe = D || c === \"inertiastart\" ? d.getSwipe() : null, d;\n      }\n      return y(r, [{ key: \"getSwipe\", value: function() {\n        var n = this._interaction;\n        if (n.prevEvent.speed < 600 || this.timeStamp - n.prevEvent.timeStamp > 150) return null;\n        var o = 180 * Math.atan2(n.prevEvent.velocityY, n.prevEvent.velocityX) / Math.PI;\n        o < 0 && (o += 360);\n        var l = 112.5 <= o && o < 247.5, c = 202.5 <= o && o < 337.5;\n        return { up: c, down: !c && 22.5 <= o && o < 157.5, left: l, right: !l && (292.5 <= o || o < 67.5), angle: o, speed: n.prevEvent.speed, velocity: { x: n.prevEvent.velocityX, y: n.prevEvent.velocityY } };\n      } }, { key: \"preventDefault\", value: function() {\n      } }, { key: \"stopImmediatePropagation\", value: function() {\n        this.immediatePropagationStopped = this.propagationStopped = !0;\n      } }, { key: \"stopPropagation\", value: function() {\n        this.propagationStopped = !0;\n      } }]), r;\n    }(wt);\n    Object.defineProperties(hr.prototype, { pageX: { get: function() {\n      return this.page.x;\n    }, set: function(t) {\n      this.page.x = t;\n    } }, pageY: { get: function() {\n      return this.page.y;\n    }, set: function(t) {\n      this.page.y = t;\n    } }, clientX: { get: function() {\n      return this.client.x;\n    }, set: function(t) {\n      this.client.x = t;\n    } }, clientY: { get: function() {\n      return this.client.y;\n    }, set: function(t) {\n      this.client.y = t;\n    } }, dx: { get: function() {\n      return this.delta.x;\n    }, set: function(t) {\n      this.delta.x = t;\n    } }, dy: { get: function() {\n      return this.delta.y;\n    }, set: function(t) {\n      this.delta.y = t;\n    } }, velocityX: { get: function() {\n      return this.velocity.x;\n    }, set: function(t) {\n      this.velocity.x = t;\n    } }, velocityY: { get: function() {\n      return this.velocity.y;\n    }, set: function(t) {\n      this.velocity.y = t;\n    } } });\n    var Io = y(function t(e, r, n, o, l) {\n      v(this, t), this.id = void 0, this.pointer = void 0, this.event = void 0, this.downTime = void 0, this.downTarget = void 0, this.id = e, this.pointer = r, this.event = n, this.downTime = o, this.downTarget = l;\n    }), Po = function(t) {\n      return t.interactable = \"\", t.element = \"\", t.prepared = \"\", t.pointerIsDown = \"\", t.pointerWasMoved = \"\", t._proxy = \"\", t;\n    }({}), Tn = function(t) {\n      return t.start = \"\", t.move = \"\", t.end = \"\", t.stop = \"\", t.interacting = \"\", t;\n    }({}), Do = 0, Ro = function() {\n      function t(e) {\n        var r = this, n = e.pointerType, o = e.scopeFire;\n        v(this, t), this.interactable = null, this.element = null, this.rect = null, this._rects = void 0, this.edges = null, this._scopeFire = void 0, this.prepared = { name: null, axis: null, edges: null }, this.pointerType = void 0, this.pointers = [], this.downEvent = null, this.downPointer = {}, this._latestPointer = { pointer: null, event: null, eventTarget: null }, this.prevEvent = null, this.pointerIsDown = !1, this.pointerWasMoved = !1, this._interacting = !1, this._ending = !1, this._stopped = !0, this._proxy = void 0, this.simulation = null, this.doMove = ct(function(d) {\n          this.move(d);\n        }, \"The interaction.doMove() method has been renamed to interaction.move()\"), this.coords = { start: { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 }, prev: { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 }, cur: { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 }, delta: { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 }, velocity: { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 } }, this._id = Do++, this._scopeFire = o, this.pointerType = n;\n        var l = this;\n        this._proxy = {};\n        var c = function(d) {\n          Object.defineProperty(r._proxy, d, { get: function() {\n            return l[d];\n          } });\n        };\n        for (var p in Po) c(p);\n        var h = function(d) {\n          Object.defineProperty(r._proxy, d, { value: function() {\n            return l[d].apply(l, arguments);\n          } });\n        };\n        for (var g in Tn) h(g);\n        this._scopeFire(\"interactions:new\", { interaction: this });\n      }\n      return y(t, [{ key: \"pointerMoveTolerance\", get: function() {\n        return 1;\n      } }, { key: \"pointerDown\", value: function(e, r, n) {\n        var o = this.updatePointer(e, r, n, !0), l = this.pointers[o];\n        this._scopeFire(\"interactions:down\", { pointer: e, event: r, eventTarget: n, pointerIndex: o, pointerInfo: l, type: \"down\", interaction: this });\n      } }, { key: \"start\", value: function(e, r, n) {\n        return !(this.interacting() || !this.pointerIsDown || this.pointers.length < (e.name === \"gesture\" ? 2 : 1) || !r.options[e.name].enabled) && (ar(this.prepared, e), this.interactable = r, this.element = n, this.rect = r.getRect(n), this.edges = this.prepared.edges ? H({}, this.prepared.edges) : { left: !0, right: !0, top: !0, bottom: !0 }, this._stopped = !1, this._interacting = this._doPhase({ interaction: this, event: this.downEvent, phase: \"start\" }) && !this._stopped, this._interacting);\n      } }, { key: \"pointerMove\", value: function(e, r, n) {\n        this.simulation || this.modification && this.modification.endResult || this.updatePointer(e, r, n, !1);\n        var o, l, c = this.coords.cur.page.x === this.coords.prev.page.x && this.coords.cur.page.y === this.coords.prev.page.y && this.coords.cur.client.x === this.coords.prev.client.x && this.coords.cur.client.y === this.coords.prev.client.y;\n        this.pointerIsDown && !this.pointerWasMoved && (o = this.coords.cur.client.x - this.coords.start.client.x, l = this.coords.cur.client.y - this.coords.start.client.y, this.pointerWasMoved = ot(o, l) > this.pointerMoveTolerance);\n        var p, h, g, d = this.getPointerIndex(e), b = { pointer: e, pointerIndex: d, pointerInfo: this.pointers[d], event: r, type: \"move\", eventTarget: n, dx: o, dy: l, duplicate: c, interaction: this };\n        c || (p = this.coords.velocity, h = this.coords.delta, g = Math.max(h.timeStamp / 1e3, 1e-3), p.page.x = h.page.x / g, p.page.y = h.page.y / g, p.client.x = h.client.x / g, p.client.y = h.client.y / g, p.timeStamp = g), this._scopeFire(\"interactions:move\", b), c || this.simulation || (this.interacting() && (b.type = null, this.move(b)), this.pointerWasMoved && yt(this.coords.prev, this.coords.cur));\n      } }, { key: \"move\", value: function(e) {\n        e && e.event || Vr(this.coords.delta), (e = H({ pointer: this._latestPointer.pointer, event: this._latestPointer.event, eventTarget: this._latestPointer.eventTarget, interaction: this }, e || {})).phase = \"move\", this._doPhase(e);\n      } }, { key: \"pointerUp\", value: function(e, r, n, o) {\n        var l = this.getPointerIndex(e);\n        l === -1 && (l = this.updatePointer(e, r, n, !1));\n        var c = /cancel$/i.test(r.type) ? \"cancel\" : \"up\";\n        this._scopeFire(\"interactions:\".concat(c), { pointer: e, pointerIndex: l, pointerInfo: this.pointers[l], event: r, eventTarget: n, type: c, curEventTarget: o, interaction: this }), this.simulation || this.end(r), this.removePointer(e, r);\n      } }, { key: \"documentBlur\", value: function(e) {\n        this.end(e), this._scopeFire(\"interactions:blur\", { event: e, type: \"blur\", interaction: this });\n      } }, { key: \"end\", value: function(e) {\n        var r;\n        this._ending = !0, e = e || this._latestPointer.event, this.interacting() && (r = this._doPhase({ event: e, interaction: this, phase: \"end\" })), this._ending = !1, r === !0 && this.stop();\n      } }, { key: \"currentAction\", value: function() {\n        return this._interacting ? this.prepared.name : null;\n      } }, { key: \"interacting\", value: function() {\n        return this._interacting;\n      } }, { key: \"stop\", value: function() {\n        this._scopeFire(\"interactions:stop\", { interaction: this }), this.interactable = this.element = null, this._interacting = !1, this._stopped = !0, this.prepared.name = this.prevEvent = null;\n      } }, { key: \"getPointerIndex\", value: function(e) {\n        var r = st(e);\n        return this.pointerType === \"mouse\" || this.pointerType === \"pen\" ? this.pointers.length - 1 : at(this.pointers, function(n) {\n          return n.id === r;\n        });\n      } }, { key: \"getPointerInfo\", value: function(e) {\n        return this.pointers[this.getPointerIndex(e)];\n      } }, { key: \"updatePointer\", value: function(e, r, n, o) {\n        var l, c, p, h = st(e), g = this.getPointerIndex(e), d = this.pointers[g];\n        return o = o !== !1 && (o || /(down|start)$/i.test(r.type)), d ? d.pointer = e : (d = new Io(h, e, r, null, null), g = this.pointers.length, this.pointers.push(d)), lo(this.coords.cur, this.pointers.map(function(b) {\n          return b.pointer;\n        }), this._now()), l = this.coords.delta, c = this.coords.prev, p = this.coords.cur, l.page.x = p.page.x - c.page.x, l.page.y = p.page.y - c.page.y, l.client.x = p.client.x - c.client.x, l.client.y = p.client.y - c.client.y, l.timeStamp = p.timeStamp - c.timeStamp, o && (this.pointerIsDown = !0, d.downTime = this.coords.cur.timeStamp, d.downTarget = n, bt(this.downPointer, e), this.interacting() || (yt(this.coords.start, this.coords.cur), yt(this.coords.prev, this.coords.cur), this.downEvent = r, this.pointerWasMoved = !1)), this._updateLatestPointer(e, r, n), this._scopeFire(\"interactions:update-pointer\", { pointer: e, event: r, eventTarget: n, down: o, pointerInfo: d, pointerIndex: g, interaction: this }), g;\n      } }, { key: \"removePointer\", value: function(e, r) {\n        var n = this.getPointerIndex(e);\n        if (n !== -1) {\n          var o = this.pointers[n];\n          this._scopeFire(\"interactions:remove-pointer\", { pointer: e, event: r, eventTarget: null, pointerIndex: n, pointerInfo: o, interaction: this }), this.pointers.splice(n, 1), this.pointerIsDown = !1;\n        }\n      } }, { key: \"_updateLatestPointer\", value: function(e, r, n) {\n        this._latestPointer.pointer = e, this._latestPointer.event = r, this._latestPointer.eventTarget = n;\n      } }, { key: \"destroy\", value: function() {\n        this._latestPointer.pointer = null, this._latestPointer.event = null, this._latestPointer.eventTarget = null;\n      } }, { key: \"_createPreparedEvent\", value: function(e, r, n, o) {\n        return new hr(this, e, this.prepared.name, r, this.element, n, o);\n      } }, { key: \"_fireEvent\", value: function(e) {\n        var r;\n        (r = this.interactable) == null || r.fire(e), (!this.prevEvent || e.timeStamp >= this.prevEvent.timeStamp) && (this.prevEvent = e);\n      } }, { key: \"_doPhase\", value: function(e) {\n        var r = e.event, n = e.phase, o = e.preEnd, l = e.type, c = this.rect;\n        if (c && n === \"move\" && (mt(this.edges, c, this.coords.delta[this.interactable.options.deltaSource]), c.width = c.right - c.left, c.height = c.bottom - c.top), this._scopeFire(\"interactions:before-action-\".concat(n), e) === !1) return !1;\n        var p = e.iEvent = this._createPreparedEvent(r, n, o, l);\n        return this._scopeFire(\"interactions:action-\".concat(n), e), n === \"start\" && (this.prevEvent = p), this._fireEvent(p), this._scopeFire(\"interactions:after-action-\".concat(n), e), !0;\n      } }, { key: \"_now\", value: function() {\n        return Date.now();\n      } }]), t;\n    }();\n    function wn(t) {\n      Sn(t.interaction);\n    }\n    function Sn(t) {\n      if (!function(r) {\n        return !(!r.offset.pending.x && !r.offset.pending.y);\n      }(t)) return !1;\n      var e = t.offset.pending;\n      return dr(t.coords.cur, e), dr(t.coords.delta, e), mt(t.edges, t.rect, e), e.x = 0, e.y = 0, !0;\n    }\n    function $o(t) {\n      var e = t.x, r = t.y;\n      this.offset.pending.x += e, this.offset.pending.y += r, this.offset.total.x += e, this.offset.total.y += r;\n    }\n    function dr(t, e) {\n      var r = t.page, n = t.client, o = e.x, l = e.y;\n      r.x += o, r.y += l, n.x += o, n.y += l;\n    }\n    Tn.offsetBy = \"\";\n    var ko = { id: \"offset\", before: [\"modifiers\", \"pointer-events\", \"actions\", \"inertia\"], install: function(t) {\n      t.Interaction.prototype.offsetBy = $o;\n    }, listeners: { \"interactions:new\": function(t) {\n      t.interaction.offset = { total: { x: 0, y: 0 }, pending: { x: 0, y: 0 } };\n    }, \"interactions:update-pointer\": function(t) {\n      return function(e) {\n        e.pointerIsDown && (dr(e.coords.cur, e.offset.total), e.offset.pending.x = 0, e.offset.pending.y = 0);\n      }(t.interaction);\n    }, \"interactions:before-action-start\": wn, \"interactions:before-action-move\": wn, \"interactions:before-action-end\": function(t) {\n      var e = t.interaction;\n      if (Sn(e)) return e.move({ offset: !0 }), e.end(), !1;\n    }, \"interactions:stop\": function(t) {\n      var e = t.interaction;\n      e.offset.total.x = 0, e.offset.total.y = 0, e.offset.pending.x = 0, e.offset.pending.y = 0;\n    } } }, xn = ko, zo = function() {\n      function t(e) {\n        v(this, t), this.active = !1, this.isModified = !1, this.smoothEnd = !1, this.allowResume = !1, this.modification = void 0, this.modifierCount = 0, this.modifierArg = void 0, this.startCoords = void 0, this.t0 = 0, this.v0 = 0, this.te = 0, this.targetOffset = void 0, this.modifiedOffset = void 0, this.currentOffset = void 0, this.lambda_v0 = 0, this.one_ve_v0 = 0, this.timeout = void 0, this.interaction = void 0, this.interaction = e;\n      }\n      return y(t, [{ key: \"start\", value: function(e) {\n        var r = this.interaction, n = Ct(r);\n        if (!n || !n.enabled) return !1;\n        var o = r.coords.velocity.client, l = ot(o.x, o.y), c = this.modification || (this.modification = new pr(r));\n        if (c.copyFrom(r.modification), this.t0 = r._now(), this.allowResume = n.allowResume, this.v0 = l, this.currentOffset = { x: 0, y: 0 }, this.startCoords = r.coords.cur.page, this.modifierArg = c.fillArg({ pageCoords: this.startCoords, preEnd: !0, phase: \"inertiastart\" }), this.t0 - r.coords.cur.timeStamp < 50 && l > n.minSpeed && l > n.endSpeed) this.startInertia();\n        else {\n          if (c.result = c.setAll(this.modifierArg), !c.result.changed) return !1;\n          this.startSmoothEnd();\n        }\n        return r.modification.result.rect = null, r.offsetBy(this.targetOffset), r._doPhase({ interaction: r, event: e, phase: \"inertiastart\" }), r.offsetBy({ x: -this.targetOffset.x, y: -this.targetOffset.y }), r.modification.result.rect = null, this.active = !0, r.simulation = this, !0;\n      } }, { key: \"startInertia\", value: function() {\n        var e = this, r = this.interaction.coords.velocity.client, n = Ct(this.interaction), o = n.resistance, l = -Math.log(n.endSpeed / this.v0) / o;\n        this.targetOffset = { x: (r.x - l) / o, y: (r.y - l) / o }, this.te = l, this.lambda_v0 = o / this.v0, this.one_ve_v0 = 1 - n.endSpeed / this.v0;\n        var c = this.modification, p = this.modifierArg;\n        p.pageCoords = { x: this.startCoords.x + this.targetOffset.x, y: this.startCoords.y + this.targetOffset.y }, c.result = c.setAll(p), c.result.changed && (this.isModified = !0, this.modifiedOffset = { x: this.targetOffset.x + c.result.delta.x, y: this.targetOffset.y + c.result.delta.y }), this.onNextFrame(function() {\n          return e.inertiaTick();\n        });\n      } }, { key: \"startSmoothEnd\", value: function() {\n        var e = this;\n        this.smoothEnd = !0, this.isModified = !0, this.targetOffset = { x: this.modification.result.delta.x, y: this.modification.result.delta.y }, this.onNextFrame(function() {\n          return e.smoothEndTick();\n        });\n      } }, { key: \"onNextFrame\", value: function(e) {\n        var r = this;\n        this.timeout = je.request(function() {\n          r.active && e();\n        });\n      } }, { key: \"inertiaTick\", value: function() {\n        var e, r, n, o, l, c, p, h = this, g = this.interaction, d = Ct(g).resistance, b = (g._now() - this.t0) / 1e3;\n        if (b < this.te) {\n          var w, I = 1 - (Math.exp(-d * b) - this.lambda_v0) / this.one_ve_v0;\n          this.isModified ? (e = 0, r = 0, n = this.targetOffset.x, o = this.targetOffset.y, l = this.modifiedOffset.x, c = this.modifiedOffset.y, w = { x: On(p = I, e, n, l), y: On(p, r, o, c) }) : w = { x: this.targetOffset.x * I, y: this.targetOffset.y * I };\n          var E = { x: w.x - this.currentOffset.x, y: w.y - this.currentOffset.y };\n          this.currentOffset.x += E.x, this.currentOffset.y += E.y, g.offsetBy(E), g.move(), this.onNextFrame(function() {\n            return h.inertiaTick();\n          });\n        } else g.offsetBy({ x: this.modifiedOffset.x - this.currentOffset.x, y: this.modifiedOffset.y - this.currentOffset.y }), this.end();\n      } }, { key: \"smoothEndTick\", value: function() {\n        var e = this, r = this.interaction, n = r._now() - this.t0, o = Ct(r).smoothEndDuration;\n        if (n < o) {\n          var l = { x: Cn(n, 0, this.targetOffset.x, o), y: Cn(n, 0, this.targetOffset.y, o) }, c = { x: l.x - this.currentOffset.x, y: l.y - this.currentOffset.y };\n          this.currentOffset.x += c.x, this.currentOffset.y += c.y, r.offsetBy(c), r.move({ skipModifiers: this.modifierCount }), this.onNextFrame(function() {\n            return e.smoothEndTick();\n          });\n        } else r.offsetBy({ x: this.targetOffset.x - this.currentOffset.x, y: this.targetOffset.y - this.currentOffset.y }), this.end();\n      } }, { key: \"resume\", value: function(e) {\n        var r = e.pointer, n = e.event, o = e.eventTarget, l = this.interaction;\n        l.offsetBy({ x: -this.currentOffset.x, y: -this.currentOffset.y }), l.updatePointer(r, n, o, !0), l._doPhase({ interaction: l, event: n, phase: \"resume\" }), yt(l.coords.prev, l.coords.cur), this.stop();\n      } }, { key: \"end\", value: function() {\n        this.interaction.move(), this.interaction.end(), this.stop();\n      } }, { key: \"stop\", value: function() {\n        this.active = this.smoothEnd = !1, this.interaction.simulation = null, je.cancel(this.timeout);\n      } }]), t;\n    }();\n    function Ct(t) {\n      var e = t.interactable, r = t.prepared;\n      return e && e.options && r.name && e.options[r.name].inertia;\n    }\n    var jo = { id: \"inertia\", before: [\"modifiers\", \"actions\"], install: function(t) {\n      var e = t.defaults;\n      t.usePlugin(xn), t.usePlugin(bn), t.actions.phases.inertiastart = !0, t.actions.phases.resume = !0, e.perAction.inertia = { enabled: !1, resistance: 10, minSpeed: 100, endSpeed: 10, allowResume: !0, smoothEndDuration: 300 };\n    }, listeners: { \"interactions:new\": function(t) {\n      var e = t.interaction;\n      e.inertia = new zo(e);\n    }, \"interactions:before-action-end\": function(t) {\n      var e = t.interaction, r = t.event;\n      return (!e._interacting || e.simulation || !e.inertia.start(r)) && null;\n    }, \"interactions:down\": function(t) {\n      var e = t.interaction, r = t.eventTarget, n = e.inertia;\n      if (n.active) for (var o = r; S.element(o); ) {\n        if (o === e.element) {\n          n.resume(t);\n          break;\n        }\n        o = K(o);\n      }\n    }, \"interactions:stop\": function(t) {\n      var e = t.interaction.inertia;\n      e.active && e.stop();\n    }, \"interactions:before-action-resume\": function(t) {\n      var e = t.interaction.modification;\n      e.stop(t), e.start(t, t.interaction.coords.cur.page), e.applyToInteraction(t);\n    }, \"interactions:before-action-inertiastart\": function(t) {\n      return t.interaction.modification.setAndApply(t);\n    }, \"interactions:action-resume\": ut, \"interactions:action-inertiastart\": ut, \"interactions:after-action-inertiastart\": function(t) {\n      return t.interaction.modification.restoreInteractionCoords(t);\n    }, \"interactions:after-action-resume\": function(t) {\n      return t.interaction.modification.restoreInteractionCoords(t);\n    } } };\n    function On(t, e, r, n) {\n      var o = 1 - t;\n      return o * o * e + 2 * o * t * r + t * t * n;\n    }\n    function Cn(t, e, r, n) {\n      return -r * (t /= n) * (t - 2) + e;\n    }\n    var Ao = jo;\n    function _n(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var n = e[r];\n        if (t.immediatePropagationStopped) break;\n        n(t);\n      }\n    }\n    var Mn = function() {\n      function t(e) {\n        v(this, t), this.options = void 0, this.types = {}, this.propagationStopped = !1, this.immediatePropagationStopped = !1, this.global = void 0, this.options = H({}, e || {});\n      }\n      return y(t, [{ key: \"fire\", value: function(e) {\n        var r, n = this.global;\n        (r = this.types[e.type]) && _n(e, r), !e.propagationStopped && n && (r = n[e.type]) && _n(e, r);\n      } }, { key: \"on\", value: function(e, r) {\n        var n = Ue(e, r);\n        for (e in n) this.types[e] = tn(this.types[e] || [], n[e]);\n      } }, { key: \"off\", value: function(e, r) {\n        var n = Ue(e, r);\n        for (e in n) {\n          var o = this.types[e];\n          if (o && o.length) for (var l = 0, c = n[e]; l < c.length; l++) {\n            var p = c[l], h = o.indexOf(p);\n            h !== -1 && o.splice(h, 1);\n          }\n        }\n      } }, { key: \"getRect\", value: function(e) {\n        return null;\n      } }]), t;\n    }(), Lo = function() {\n      function t(e) {\n        v(this, t), this.currentTarget = void 0, this.originalEvent = void 0, this.type = void 0, this.originalEvent = e, bt(this, e);\n      }\n      return y(t, [{ key: \"preventOriginalDefault\", value: function() {\n        this.originalEvent.preventDefault();\n      } }, { key: \"stopPropagation\", value: function() {\n        this.originalEvent.stopPropagation();\n      } }, { key: \"stopImmediatePropagation\", value: function() {\n        this.originalEvent.stopImmediatePropagation();\n      } }]), t;\n    }();\n    function pt(t) {\n      return S.object(t) ? { capture: !!t.capture, passive: !!t.passive } : { capture: !!t, passive: !1 };\n    }\n    function _t(t, e) {\n      return t === e || (typeof t == \"boolean\" ? !!e.capture === t && !e.passive : !!t.capture == !!e.capture && !!t.passive == !!e.passive);\n    }\n    var Ho = { id: \"events\", install: function(t) {\n      var e, r = [], n = {}, o = [], l = { add: c, remove: p, addDelegate: function(d, b, w, I, E) {\n        var D = pt(E);\n        if (!n[w]) {\n          n[w] = [];\n          for (var L = 0; L < o.length; L++) {\n            var j = o[L];\n            c(j, w, h), c(j, w, g, !0);\n          }\n        }\n        var Y = n[w], q = lt(Y, function(ee) {\n          return ee.selector === d && ee.context === b;\n        });\n        q || (q = { selector: d, context: b, listeners: [] }, Y.push(q)), q.listeners.push({ func: I, options: D });\n      }, removeDelegate: function(d, b, w, I, E) {\n        var D, L = pt(E), j = n[w], Y = !1;\n        if (j)\n          for (D = j.length - 1; D >= 0; D--) {\n            var q = j[D];\n            if (q.selector === d && q.context === b) {\n              for (var ee = q.listeners, B = ee.length - 1; B >= 0; B--) {\n                var Z = ee[B];\n                if (Z.func === I && _t(Z.options, L)) {\n                  ee.splice(B, 1), ee.length || (j.splice(D, 1), p(b, w, h), p(b, w, g, !0)), Y = !0;\n                  break;\n                }\n              }\n              if (Y) break;\n            }\n          }\n      }, delegateListener: h, delegateUseCapture: g, delegatedEvents: n, documents: o, targets: r, supportsOptions: !1, supportsPassive: !1 };\n      function c(d, b, w, I) {\n        if (d.addEventListener) {\n          var E = pt(I), D = lt(r, function(L) {\n            return L.eventTarget === d;\n          });\n          D || (D = { eventTarget: d, events: {} }, r.push(D)), D.events[b] || (D.events[b] = []), lt(D.events[b], function(L) {\n            return L.func === w && _t(L.options, E);\n          }) || (d.addEventListener(b, w, l.supportsOptions ? E : E.capture), D.events[b].push({ func: w, options: E }));\n        }\n      }\n      function p(d, b, w, I) {\n        if (d.addEventListener && d.removeEventListener) {\n          var E = at(r, function(me) {\n            return me.eventTarget === d;\n          }), D = r[E];\n          if (D && D.events) if (b !== \"all\") {\n            var L = !1, j = D.events[b];\n            if (j) {\n              if (w === \"all\") {\n                for (var Y = j.length - 1; Y >= 0; Y--) {\n                  var q = j[Y];\n                  p(d, b, q.func, q.options);\n                }\n                return;\n              }\n              for (var ee = pt(I), B = 0; B < j.length; B++) {\n                var Z = j[B];\n                if (Z.func === w && _t(Z.options, ee)) {\n                  d.removeEventListener(b, w, l.supportsOptions ? ee : ee.capture), j.splice(B, 1), j.length === 0 && (delete D.events[b], L = !0);\n                  break;\n                }\n              }\n            }\n            L && !Object.keys(D.events).length && r.splice(E, 1);\n          } else for (b in D.events) D.events.hasOwnProperty(b) && p(d, b, \"all\");\n        }\n      }\n      function h(d, b) {\n        for (var w = pt(b), I = new Lo(d), E = n[d.type], D = en(d)[0], L = D; S.element(L); ) {\n          for (var j = 0; j < E.length; j++) {\n            var Y = E[j], q = Y.selector, ee = Y.context;\n            if (X(L, q) && F(ee, D) && F(ee, L)) {\n              var B = Y.listeners;\n              I.currentTarget = L;\n              for (var Z = 0; Z < B.length; Z++) {\n                var me = B[Z];\n                _t(me.options, w) && me.func(I);\n              }\n            }\n          }\n          L = K(L);\n        }\n      }\n      function g(d) {\n        return h(d, !0);\n      }\n      return (e = t.document) == null || e.createElement(\"div\").addEventListener(\"test\", null, { get capture() {\n        return l.supportsOptions = !0;\n      }, get passive() {\n        return l.supportsPassive = !0;\n      } }), t.events = l, l;\n    } }, fr = { methodOrder: [\"simulationResume\", \"mouseOrPen\", \"hasPointer\", \"idle\"], search: function(t) {\n      for (var e = 0, r = fr.methodOrder; e < r.length; e++) {\n        var n = r[e], o = fr[n](t);\n        if (o) return o;\n      }\n      return null;\n    }, simulationResume: function(t) {\n      var e = t.pointerType, r = t.eventType, n = t.eventTarget, o = t.scope;\n      if (!/down|start/i.test(r)) return null;\n      for (var l = 0, c = o.interactions.list; l < c.length; l++) {\n        var p = c[l], h = n;\n        if (p.simulation && p.simulation.allowResume && p.pointerType === e) for (; h; ) {\n          if (h === p.element) return p;\n          h = K(h);\n        }\n      }\n      return null;\n    }, mouseOrPen: function(t) {\n      var e, r = t.pointerId, n = t.pointerType, o = t.eventType, l = t.scope;\n      if (n !== \"mouse\" && n !== \"pen\") return null;\n      for (var c = 0, p = l.interactions.list; c < p.length; c++) {\n        var h = p[c];\n        if (h.pointerType === n) {\n          if (h.simulation && !En(h, r)) continue;\n          if (h.interacting()) return h;\n          e || (e = h);\n        }\n      }\n      if (e) return e;\n      for (var g = 0, d = l.interactions.list; g < d.length; g++) {\n        var b = d[g];\n        if (!(b.pointerType !== n || /down/i.test(o) && b.simulation)) return b;\n      }\n      return null;\n    }, hasPointer: function(t) {\n      for (var e = t.pointerId, r = 0, n = t.scope.interactions.list; r < n.length; r++) {\n        var o = n[r];\n        if (En(o, e)) return o;\n      }\n      return null;\n    }, idle: function(t) {\n      for (var e = t.pointerType, r = 0, n = t.scope.interactions.list; r < n.length; r++) {\n        var o = n[r];\n        if (o.pointers.length === 1) {\n          var l = o.interactable;\n          if (l && (!l.options.gesture || !l.options.gesture.enabled)) continue;\n        } else if (o.pointers.length >= 2) continue;\n        if (!o.interacting() && e === o.pointerType) return o;\n      }\n      return null;\n    } };\n    function En(t, e) {\n      return t.pointers.some(function(r) {\n        return r.id === e;\n      });\n    }\n    var Wo = fr, vr = [\"pointerDown\", \"pointerMove\", \"pointerUp\", \"updatePointer\", \"removePointer\", \"windowBlur\"];\n    function In(t, e) {\n      return function(r) {\n        var n = e.interactions.list, o = Qr(r), l = en(r), c = l[0], p = l[1], h = [];\n        if (/^touch/.test(r.type)) {\n          e.prevTouchTime = e.now();\n          for (var g = 0, d = r.changedTouches; g < d.length; g++) {\n            var b = d[g], w = { pointer: b, pointerId: st(b), pointerType: o, eventType: r.type, eventTarget: c, curEventTarget: p, scope: e }, I = Pn(w);\n            h.push([w.pointer, w.eventTarget, w.curEventTarget, I]);\n          }\n        } else {\n          var E = !1;\n          if (!R.supportsPointerEvent && /mouse/.test(r.type)) {\n            for (var D = 0; D < n.length && !E; D++) E = n[D].pointerType !== \"mouse\" && n[D].pointerIsDown;\n            E = E || e.now() - e.prevTouchTime < 500 || r.timeStamp === 0;\n          }\n          if (!E) {\n            var L = { pointer: r, pointerId: st(r), pointerType: o, eventType: r.type, curEventTarget: p, eventTarget: c, scope: e }, j = Pn(L);\n            h.push([L.pointer, L.eventTarget, L.curEventTarget, j]);\n          }\n        }\n        for (var Y = 0; Y < h.length; Y++) {\n          var q = h[Y], ee = q[0], B = q[1], Z = q[2];\n          q[3][t](ee, r, B, Z);\n        }\n      };\n    }\n    function Pn(t) {\n      var e = t.pointerType, r = t.scope, n = { interaction: Wo.search(t), searchDetails: t };\n      return r.fire(\"interactions:find\", n), n.interaction || r.interactions.new({ pointerType: e });\n    }\n    function gr(t, e) {\n      var r = t.doc, n = t.scope, o = t.options, l = n.interactions.docEvents, c = n.events, p = c[e];\n      for (var h in n.browser.isIOS && !o.events && (o.events = { passive: !1 }), c.delegatedEvents) p(r, h, c.delegateListener), p(r, h, c.delegateUseCapture, !0);\n      for (var g = o && o.events, d = 0; d < l.length; d++) {\n        var b = l[d];\n        p(r, b.type, b.listener, g);\n      }\n    }\n    var Fo = { id: \"core/interactions\", install: function(t) {\n      for (var e = {}, r = 0; r < vr.length; r++) {\n        var n = vr[r];\n        e[n] = In(n, t);\n      }\n      var o, l = R.pEventTypes;\n      function c() {\n        for (var p = 0, h = t.interactions.list; p < h.length; p++) {\n          var g = h[p];\n          if (g.pointerIsDown && g.pointerType === \"touch\" && !g._interacting) for (var d = function() {\n            var I = w[b];\n            t.documents.some(function(E) {\n              return F(E.doc, I.downTarget);\n            }) || g.removePointer(I.pointer, I.event);\n          }, b = 0, w = g.pointers; b < w.length; b++) d();\n        }\n      }\n      (o = W.PointerEvent ? [{ type: l.down, listener: c }, { type: l.down, listener: e.pointerDown }, { type: l.move, listener: e.pointerMove }, { type: l.up, listener: e.pointerUp }, { type: l.cancel, listener: e.pointerUp }] : [{ type: \"mousedown\", listener: e.pointerDown }, { type: \"mousemove\", listener: e.pointerMove }, { type: \"mouseup\", listener: e.pointerUp }, { type: \"touchstart\", listener: c }, { type: \"touchstart\", listener: e.pointerDown }, { type: \"touchmove\", listener: e.pointerMove }, { type: \"touchend\", listener: e.pointerUp }, { type: \"touchcancel\", listener: e.pointerUp }]).push({ type: \"blur\", listener: function(p) {\n        for (var h = 0, g = t.interactions.list; h < g.length; h++)\n          g[h].documentBlur(p);\n      } }), t.prevTouchTime = 0, t.Interaction = function(p) {\n        O(g, p);\n        var h = _(g);\n        function g() {\n          return v(this, g), h.apply(this, arguments);\n        }\n        return y(g, [{ key: \"pointerMoveTolerance\", get: function() {\n          return t.interactions.pointerMoveTolerance;\n        }, set: function(d) {\n          t.interactions.pointerMoveTolerance = d;\n        } }, { key: \"_now\", value: function() {\n          return t.now();\n        } }]), g;\n      }(Ro), t.interactions = { list: [], new: function(p) {\n        p.scopeFire = function(g, d) {\n          return t.fire(g, d);\n        };\n        var h = new t.Interaction(p);\n        return t.interactions.list.push(h), h;\n      }, listeners: e, docEvents: o, pointerMoveTolerance: 1 }, t.usePlugin(mn);\n    }, listeners: { \"scope:add-document\": function(t) {\n      return gr(t, \"add\");\n    }, \"scope:remove-document\": function(t) {\n      return gr(t, \"remove\");\n    }, \"interactable:unset\": function(t, e) {\n      for (var r = t.interactable, n = e.interactions.list.length - 1; n >= 0; n--) {\n        var o = e.interactions.list[n];\n        o.interactable === r && (o.stop(), e.fire(\"interactions:destroy\", { interaction: o }), o.destroy(), e.interactions.list.length > 2 && e.interactions.list.splice(n, 1));\n      }\n    } }, onDocSignal: gr, doOnInteractions: In, methodNames: vr }, Uo = Fo, Le = function(t) {\n      return t[t.On = 0] = \"On\", t[t.Off = 1] = \"Off\", t;\n    }(Le || {}), No = function() {\n      function t(e, r, n, o) {\n        v(this, t), this.target = void 0, this.options = void 0, this._actions = void 0, this.events = new Mn(), this._context = void 0, this._win = void 0, this._doc = void 0, this._scopeEvents = void 0, this._actions = r.actions, this.target = e, this._context = r.context || n, this._win = te(ke(e) ? this._context : e), this._doc = this._win.document, this._scopeEvents = o, this.set(r);\n      }\n      return y(t, [{ key: \"_defaults\", get: function() {\n        return { base: {}, perAction: {}, actions: {} };\n      } }, { key: \"setOnEvents\", value: function(e, r) {\n        return S.func(r.onstart) && this.on(\"\".concat(e, \"start\"), r.onstart), S.func(r.onmove) && this.on(\"\".concat(e, \"move\"), r.onmove), S.func(r.onend) && this.on(\"\".concat(e, \"end\"), r.onend), S.func(r.oninertiastart) && this.on(\"\".concat(e, \"inertiastart\"), r.oninertiastart), this;\n      } }, { key: \"updatePerActionListeners\", value: function(e, r, n) {\n        var o, l = this, c = (o = this._actions.map[e]) == null ? void 0 : o.filterEventType, p = function(h) {\n          return (c == null || c(h)) && xt(h, l._actions);\n        };\n        (S.array(r) || S.object(r)) && this._onOff(Le.Off, e, r, void 0, p), (S.array(n) || S.object(n)) && this._onOff(Le.On, e, n, void 0, p);\n      } }, { key: \"setPerAction\", value: function(e, r) {\n        var n = this._defaults;\n        for (var o in r) {\n          var l = o, c = this.options[e], p = r[l];\n          l === \"listeners\" && this.updatePerActionListeners(e, c.listeners, p), S.array(p) ? c[l] = rn(p) : S.plainObject(p) ? (c[l] = H(c[l] || {}, Be(p)), S.object(n.perAction[l]) && \"enabled\" in n.perAction[l] && (c[l].enabled = p.enabled !== !1)) : S.bool(p) && S.object(n.perAction[l]) ? c[l].enabled = p : c[l] = p;\n        }\n      } }, { key: \"getRect\", value: function(e) {\n        return e = e || (S.element(this.target) ? this.target : null), S.string(this.target) && (e = e || this._context.querySelector(this.target)), Oe(e);\n      } }, { key: \"rectChecker\", value: function(e) {\n        var r = this;\n        return S.func(e) ? (this.getRect = function(n) {\n          var o = H({}, e.apply(r, n));\n          return \"width\" in o || (o.width = o.right - o.left, o.height = o.bottom - o.top), o;\n        }, this) : e === null ? (delete this.getRect, this) : this.getRect;\n      } }, { key: \"_backCompatOption\", value: function(e, r) {\n        if (ke(r) || S.object(r)) {\n          for (var n in this.options[e] = r, this._actions.map) this.options[n][e] = r;\n          return this;\n        }\n        return this.options[e];\n      } }, { key: \"origin\", value: function(e) {\n        return this._backCompatOption(\"origin\", e);\n      } }, { key: \"deltaSource\", value: function(e) {\n        return e === \"page\" || e === \"client\" ? (this.options.deltaSource = e, this) : this.options.deltaSource;\n      } }, { key: \"getAllElements\", value: function() {\n        var e = this.target;\n        return S.string(e) ? Array.from(this._context.querySelectorAll(e)) : S.func(e) && e.getAllElements ? e.getAllElements() : S.element(e) ? [e] : [];\n      } }, { key: \"context\", value: function() {\n        return this._context;\n      } }, { key: \"inContext\", value: function(e) {\n        return this._context === e.ownerDocument || F(this._context, e);\n      } }, { key: \"testIgnoreAllow\", value: function(e, r, n) {\n        return !this.testIgnore(e.ignoreFrom, r, n) && this.testAllow(e.allowFrom, r, n);\n      } }, { key: \"testAllow\", value: function(e, r, n) {\n        return !e || !!S.element(n) && (S.string(e) ? pe(n, e, r) : !!S.element(e) && F(e, n));\n      } }, { key: \"testIgnore\", value: function(e, r, n) {\n        return !(!e || !S.element(n)) && (S.string(e) ? pe(n, e, r) : !!S.element(e) && F(e, n));\n      } }, { key: \"fire\", value: function(e) {\n        return this.events.fire(e), this;\n      } }, { key: \"_onOff\", value: function(e, r, n, o, l) {\n        S.object(r) && !S.array(r) && (o = n, n = null);\n        var c = Ue(r, n, l);\n        for (var p in c) {\n          p === \"wheel\" && (p = R.wheelEvent);\n          for (var h = 0, g = c[p]; h < g.length; h++) {\n            var d = g[h];\n            xt(p, this._actions) ? this.events[e === Le.On ? \"on\" : \"off\"](p, d) : S.string(this.target) ? this._scopeEvents[e === Le.On ? \"addDelegate\" : \"removeDelegate\"](this.target, this._context, p, d, o) : this._scopeEvents[e === Le.On ? \"add\" : \"remove\"](this.target, p, d, o);\n          }\n        }\n        return this;\n      } }, { key: \"on\", value: function(e, r, n) {\n        return this._onOff(Le.On, e, r, n);\n      } }, { key: \"off\", value: function(e, r, n) {\n        return this._onOff(Le.Off, e, r, n);\n      } }, { key: \"set\", value: function(e) {\n        var r = this._defaults;\n        for (var n in S.object(e) || (e = {}), this.options = Be(r.base), this._actions.methodDict) {\n          var o = n, l = this._actions.methodDict[o];\n          this.options[o] = {}, this.setPerAction(o, H(H({}, r.perAction), r.actions[o])), this[l](e[o]);\n        }\n        for (var c in e) c !== \"getRect\" ? S.func(this[c]) && this[c](e[c]) : this.rectChecker(e.getRect);\n        return this;\n      } }, { key: \"unset\", value: function() {\n        if (S.string(this.target)) for (var e in this._scopeEvents.delegatedEvents) for (var r = this._scopeEvents.delegatedEvents[e], n = r.length - 1; n >= 0; n--) {\n          var o = r[n], l = o.selector, c = o.context, p = o.listeners;\n          l === this.target && c === this._context && r.splice(n, 1);\n          for (var h = p.length - 1; h >= 0; h--) this._scopeEvents.removeDelegate(this.target, this._context, e, p[h][0], p[h][1]);\n        }\n        else this._scopeEvents.remove(this.target, \"all\");\n      } }]), t;\n    }(), Yo = function() {\n      function t(e) {\n        var r = this;\n        v(this, t), this.list = [], this.selectorMap = {}, this.scope = void 0, this.scope = e, e.addListeners({ \"interactable:unset\": function(n) {\n          var o = n.interactable, l = o.target, c = S.string(l) ? r.selectorMap[l] : l[r.scope.id], p = at(c, function(h) {\n            return h === o;\n          });\n          c.splice(p, 1);\n        } });\n      }\n      return y(t, [{ key: \"new\", value: function(e, r) {\n        r = H(r || {}, { actions: this.scope.actions });\n        var n = new this.scope.Interactable(e, r, this.scope.document, this.scope.events);\n        return this.scope.addDocument(n._doc), this.list.push(n), S.string(e) ? (this.selectorMap[e] || (this.selectorMap[e] = []), this.selectorMap[e].push(n)) : (n.target[this.scope.id] || Object.defineProperty(e, this.scope.id, { value: [], configurable: !0 }), e[this.scope.id].push(n)), this.scope.fire(\"interactable:new\", { target: e, options: r, interactable: n, win: this.scope._win }), n;\n      } }, { key: \"getExisting\", value: function(e, r) {\n        var n = r && r.context || this.scope.document, o = S.string(e), l = o ? this.selectorMap[e] : e[this.scope.id];\n        if (l) return lt(l, function(c) {\n          return c._context === n && (o || c.inContext(e));\n        });\n      } }, { key: \"forEachMatch\", value: function(e, r) {\n        for (var n = 0, o = this.list; n < o.length; n++) {\n          var l = o[n], c = void 0;\n          if ((S.string(l.target) ? S.element(e) && X(e, l.target) : e === l.target) && l.inContext(e) && (c = r(l)), c !== void 0) return c;\n        }\n      } }]), t;\n    }(), Go = function() {\n      function t() {\n        var e = this;\n        v(this, t), this.id = \"__interact_scope_\".concat(Math.floor(100 * Math.random())), this.isInitialized = !1, this.listenerMaps = [], this.browser = R, this.defaults = Be(yn), this.Eventable = Mn, this.actions = { map: {}, phases: { start: !0, move: !0, end: !0 }, methodDict: {}, phaselessTypes: {} }, this.interactStatic = function(n) {\n          var o = function l(c, p) {\n            var h = n.interactables.getExisting(c, p);\n            return h || ((h = n.interactables.new(c, p)).events.global = l.globalEvents), h;\n          };\n          return o.getPointerAverage = Jr, o.getTouchBBox = Qt, o.getTouchDistance = er, o.getTouchAngle = tr, o.getElementRect = Oe, o.getElementClientRect = ve, o.matchesSelector = X, o.closest = A, o.globalEvents = {}, o.version = \"1.10.27\", o.scope = n, o.use = function(l, c) {\n            return this.scope.usePlugin(l, c), this;\n          }, o.isSet = function(l, c) {\n            return !!this.scope.interactables.get(l, c && c.context);\n          }, o.on = ct(function(l, c, p) {\n            if (S.string(l) && l.search(\" \") !== -1 && (l = l.trim().split(/ +/)), S.array(l)) {\n              for (var h = 0, g = l; h < g.length; h++) {\n                var d = g[h];\n                this.on(d, c, p);\n              }\n              return this;\n            }\n            if (S.object(l)) {\n              for (var b in l) this.on(b, l[b], c);\n              return this;\n            }\n            return xt(l, this.scope.actions) ? this.globalEvents[l] ? this.globalEvents[l].push(c) : this.globalEvents[l] = [c] : this.scope.events.add(this.scope.document, l, c, { options: p }), this;\n          }, \"The interact.on() method is being deprecated\"), o.off = ct(function(l, c, p) {\n            if (S.string(l) && l.search(\" \") !== -1 && (l = l.trim().split(/ +/)), S.array(l)) {\n              for (var h = 0, g = l; h < g.length; h++) {\n                var d = g[h];\n                this.off(d, c, p);\n              }\n              return this;\n            }\n            if (S.object(l)) {\n              for (var b in l) this.off(b, l[b], c);\n              return this;\n            }\n            var w;\n            return xt(l, this.scope.actions) ? l in this.globalEvents && (w = this.globalEvents[l].indexOf(c)) !== -1 && this.globalEvents[l].splice(w, 1) : this.scope.events.remove(this.scope.document, l, c, p), this;\n          }, \"The interact.off() method is being deprecated\"), o.debug = function() {\n            return this.scope;\n          }, o.supportsTouch = function() {\n            return R.supportsTouch;\n          }, o.supportsPointerEvent = function() {\n            return R.supportsPointerEvent;\n          }, o.stop = function() {\n            for (var l = 0, c = this.scope.interactions.list; l < c.length; l++) c[l].stop();\n            return this;\n          }, o.pointerMoveTolerance = function(l) {\n            return S.number(l) ? (this.scope.interactions.pointerMoveTolerance = l, this) : this.scope.interactions.pointerMoveTolerance;\n          }, o.addDocument = function(l, c) {\n            this.scope.addDocument(l, c);\n          }, o.removeDocument = function(l) {\n            this.scope.removeDocument(l);\n          }, o;\n        }(this), this.InteractEvent = hr, this.Interactable = void 0, this.interactables = new Yo(this), this._win = void 0, this.document = void 0, this.window = void 0, this.documents = [], this._plugins = { list: [], map: {} }, this.onWindowUnload = function(n) {\n          return e.removeDocument(n.target);\n        };\n        var r = this;\n        this.Interactable = function(n) {\n          O(l, n);\n          var o = _(l);\n          function l() {\n            return v(this, l), o.apply(this, arguments);\n          }\n          return y(l, [{ key: \"_defaults\", get: function() {\n            return r.defaults;\n          } }, { key: \"set\", value: function(c) {\n            return M($(l.prototype), \"set\", this).call(this, c), r.fire(\"interactable:set\", { options: c, interactable: this }), this;\n          } }, { key: \"unset\", value: function() {\n            M($(l.prototype), \"unset\", this).call(this);\n            var c = r.interactables.list.indexOf(this);\n            c < 0 || (r.interactables.list.splice(c, 1), r.fire(\"interactable:unset\", { interactable: this }));\n          } }]), l;\n        }(No);\n      }\n      return y(t, [{ key: \"addListeners\", value: function(e, r) {\n        this.listenerMaps.push({ id: r, map: e });\n      } }, { key: \"fire\", value: function(e, r) {\n        for (var n = 0, o = this.listenerMaps; n < o.length; n++) {\n          var l = o[n].map[e];\n          if (l && l(r, this, e) === !1) return !1;\n        }\n      } }, { key: \"init\", value: function(e) {\n        return this.isInitialized ? this : function(r, n) {\n          return r.isInitialized = !0, S.window(n) && Q(n), W.init(n), R.init(n), je.init(n), r.window = n, r.document = n.document, r.usePlugin(Uo), r.usePlugin(Ho), r;\n        }(this, e);\n      } }, { key: \"pluginIsInstalled\", value: function(e) {\n        var r = e.id;\n        return r ? !!this._plugins.map[r] : this._plugins.list.indexOf(e) !== -1;\n      } }, { key: \"usePlugin\", value: function(e, r) {\n        if (!this.isInitialized) return this;\n        if (this.pluginIsInstalled(e)) return this;\n        if (e.id && (this._plugins.map[e.id] = e), this._plugins.list.push(e), e.install && e.install(this, r), e.listeners && e.before) {\n          for (var n = 0, o = this.listenerMaps.length, l = e.before.reduce(function(p, h) {\n            return p[h] = !0, p[Dn(h)] = !0, p;\n          }, {}); n < o; n++) {\n            var c = this.listenerMaps[n].id;\n            if (c && (l[c] || l[Dn(c)])) break;\n          }\n          this.listenerMaps.splice(n, 0, { id: e.id, map: e.listeners });\n        } else e.listeners && this.listenerMaps.push({ id: e.id, map: e.listeners });\n        return this;\n      } }, { key: \"addDocument\", value: function(e, r) {\n        if (this.getDocIndex(e) !== -1) return !1;\n        var n = te(e);\n        r = r ? H({}, r) : {}, this.documents.push({ doc: e, options: r }), this.events.documents.push(e), e !== this.document && this.events.add(n, \"unload\", this.onWindowUnload), this.fire(\"scope:add-document\", { doc: e, window: n, scope: this, options: r });\n      } }, { key: \"removeDocument\", value: function(e) {\n        var r = this.getDocIndex(e), n = te(e), o = this.documents[r].options;\n        this.events.remove(n, \"unload\", this.onWindowUnload), this.documents.splice(r, 1), this.events.documents.splice(r, 1), this.fire(\"scope:remove-document\", { doc: e, window: n, scope: this, options: o });\n      } }, { key: \"getDocIndex\", value: function(e) {\n        for (var r = 0; r < this.documents.length; r++) if (this.documents[r].doc === e) return r;\n        return -1;\n      } }, { key: \"getDocOptions\", value: function(e) {\n        var r = this.getDocIndex(e);\n        return r === -1 ? null : this.documents[r].options;\n      } }, { key: \"now\", value: function() {\n        return (this.window.Date || Date).now();\n      } }]), t;\n    }();\n    function Dn(t) {\n      return t && t.replace(/\\/.*$/, \"\");\n    }\n    var Rn = new Go(), ge = Rn.interactStatic, Ko = typeof globalThis < \"u\" ? globalThis : window;\n    Rn.init(Ko);\n    var Xo = Object.freeze({ __proto__: null, edgeTarget: function() {\n    }, elements: function() {\n    }, grid: function(t) {\n      var e = [[\"x\", \"y\"], [\"left\", \"top\"], [\"right\", \"bottom\"], [\"width\", \"height\"]].filter(function(n) {\n        var o = n[0], l = n[1];\n        return o in t || l in t;\n      }), r = function(n, o) {\n        for (var l = t.range, c = t.limits, p = c === void 0 ? { left: -1 / 0, right: 1 / 0, top: -1 / 0, bottom: 1 / 0 } : c, h = t.offset, g = h === void 0 ? { x: 0, y: 0 } : h, d = { range: l, grid: t, x: null, y: null }, b = 0; b < e.length; b++) {\n          var w = e[b], I = w[0], E = w[1], D = Math.round((n - g.x) / t[I]), L = Math.round((o - g.y) / t[E]);\n          d[I] = Math.max(p.left, Math.min(p.right, D * t[I] + g.x)), d[E] = Math.max(p.top, Math.min(p.bottom, L * t[E] + g.y));\n        }\n        return d;\n      };\n      return r.grid = t, r.coordFields = e, r;\n    } }), Bo = { id: \"snappers\", install: function(t) {\n      var e = t.interactStatic;\n      e.snappers = H(e.snappers || {}, Xo), e.createSnapGrid = e.snappers.grid;\n    } }, Vo = Bo, qo = { start: function(t) {\n      var e = t.state, r = t.rect, n = t.edges, o = t.pageCoords, l = e.options, c = l.ratio, p = l.enabled, h = e.options, g = h.equalDelta, d = h.modifiers;\n      c === \"preserve\" && (c = r.width / r.height), e.startCoords = H({}, o), e.startRect = H({}, r), e.ratio = c, e.equalDelta = g;\n      var b = e.linkedEdges = { top: n.top || n.left && !n.bottom, left: n.left || n.top && !n.right, bottom: n.bottom || n.right && !n.top, right: n.right || n.bottom && !n.left };\n      if (e.xIsPrimaryAxis = !(!n.left && !n.right), e.equalDelta) {\n        var w = (b.left ? 1 : -1) * (b.top ? 1 : -1);\n        e.edgeSign = { x: w, y: w };\n      } else e.edgeSign = { x: b.left ? -1 : 1, y: b.top ? -1 : 1 };\n      if (p !== !1 && H(n, b), d != null && d.length) {\n        var I = new pr(t.interaction);\n        I.copyFrom(t.interaction.modification), I.prepareStates(d), e.subModification = I, I.startAll(u({}, t));\n      }\n    }, set: function(t) {\n      var e = t.state, r = t.rect, n = t.coords, o = e.linkedEdges, l = H({}, n), c = e.equalDelta ? Zo : Jo;\n      if (H(t.edges, o), c(e, e.xIsPrimaryAxis, n, r), !e.subModification) return null;\n      var p = H({}, r);\n      mt(o, p, { x: n.x - l.x, y: n.y - l.y });\n      var h = e.subModification.setAll(u(u({}, t), {}, { rect: p, edges: o, pageCoords: n, prevCoords: n, prevRect: p })), g = h.delta;\n      return h.changed && (c(e, Math.abs(g.x) > Math.abs(g.y), h.coords, h.rect), H(n, h.coords)), h.eventProps;\n    }, defaults: { ratio: \"preserve\", equalDelta: !1, modifiers: [], enabled: !1 } };\n    function Zo(t, e, r) {\n      var n = t.startCoords, o = t.edgeSign;\n      e ? r.y = n.y + (r.x - n.x) * o.y : r.x = n.x + (r.y - n.y) * o.x;\n    }\n    function Jo(t, e, r, n) {\n      var o = t.startRect, l = t.startCoords, c = t.ratio, p = t.edgeSign;\n      if (e) {\n        var h = n.width / c;\n        r.y = l.y + (h - o.height) * p.y;\n      } else {\n        var g = n.height * c;\n        r.x = l.x + (g - o.width) * p.x;\n      }\n    }\n    var Qo = Ae(qo, \"aspectRatio\"), $n = function() {\n    };\n    $n._defaults = {};\n    var Mt = $n;\n    function Ye(t, e, r) {\n      return S.func(t) ? ye(t, e.interactable, e.element, [r.x, r.y, e]) : ye(t, e.interactable, e.element);\n    }\n    var Et = { start: function(t) {\n      var e = t.rect, r = t.startOffset, n = t.state, o = t.interaction, l = t.pageCoords, c = n.options, p = c.elementRect, h = H({ left: 0, top: 0, right: 0, bottom: 0 }, c.offset || {});\n      if (e && p) {\n        var g = Ye(c.restriction, o, l);\n        if (g) {\n          var d = g.right - g.left - e.width, b = g.bottom - g.top - e.height;\n          d < 0 && (h.left += d, h.right += d), b < 0 && (h.top += b, h.bottom += b);\n        }\n        h.left += r.left - e.width * p.left, h.top += r.top - e.height * p.top, h.right += r.right - e.width * (1 - p.right), h.bottom += r.bottom - e.height * (1 - p.bottom);\n      }\n      n.offset = h;\n    }, set: function(t) {\n      var e = t.coords, r = t.interaction, n = t.state, o = n.options, l = n.offset, c = Ye(o.restriction, r, e);\n      if (c) {\n        var p = function(h) {\n          return !h || \"left\" in h && \"top\" in h || ((h = H({}, h)).left = h.x || 0, h.top = h.y || 0, h.right = h.right || h.left + h.width, h.bottom = h.bottom || h.top + h.height), h;\n        }(c);\n        e.x = Math.max(Math.min(p.right - l.right, e.x), p.left + l.left), e.y = Math.max(Math.min(p.bottom - l.bottom, e.y), p.top + l.top);\n      }\n    }, defaults: { restriction: null, elementRect: null, offset: null, endOnly: !1, enabled: !1 } }, es = Ae(Et, \"restrict\"), kn = { top: 1 / 0, left: 1 / 0, bottom: -1 / 0, right: -1 / 0 }, zn = { top: -1 / 0, left: -1 / 0, bottom: 1 / 0, right: 1 / 0 };\n    function jn(t, e) {\n      for (var r = 0, n = [\"top\", \"left\", \"bottom\", \"right\"]; r < n.length; r++) {\n        var o = n[r];\n        o in t || (t[o] = e[o]);\n      }\n      return t;\n    }\n    var ht = { noInner: kn, noOuter: zn, start: function(t) {\n      var e, r = t.interaction, n = t.startOffset, o = t.state, l = o.options;\n      l && (e = _e(Ye(l.offset, r, r.coords.start.page))), e = e || { x: 0, y: 0 }, o.offset = { top: e.y + n.top, left: e.x + n.left, bottom: e.y - n.bottom, right: e.x - n.right };\n    }, set: function(t) {\n      var e = t.coords, r = t.edges, n = t.interaction, o = t.state, l = o.offset, c = o.options;\n      if (r) {\n        var p = H({}, e), h = Ye(c.inner, n, p) || {}, g = Ye(c.outer, n, p) || {};\n        jn(h, kn), jn(g, zn), r.top ? e.y = Math.min(Math.max(g.top + l.top, p.y), h.top + l.top) : r.bottom && (e.y = Math.max(Math.min(g.bottom + l.bottom, p.y), h.bottom + l.bottom)), r.left ? e.x = Math.min(Math.max(g.left + l.left, p.x), h.left + l.left) : r.right && (e.x = Math.max(Math.min(g.right + l.right, p.x), h.right + l.right));\n      }\n    }, defaults: { inner: null, outer: null, offset: null, endOnly: !1, enabled: !1 } }, ts = Ae(ht, \"restrictEdges\"), rs = H({ get elementRect() {\n      return { top: 0, left: 0, bottom: 1, right: 1 };\n    }, set elementRect(t) {\n    } }, Et.defaults), ns = Ae({ start: Et.start, set: Et.set, defaults: rs }, \"restrictRect\"), is = { width: -1 / 0, height: -1 / 0 }, os = { width: 1 / 0, height: 1 / 0 }, ss = Ae({ start: function(t) {\n      return ht.start(t);\n    }, set: function(t) {\n      var e = t.interaction, r = t.state, n = t.rect, o = t.edges, l = r.options;\n      if (o) {\n        var c = ze(Ye(l.min, e, t.coords)) || is, p = ze(Ye(l.max, e, t.coords)) || os;\n        r.options = { endOnly: l.endOnly, inner: H({}, ht.noInner), outer: H({}, ht.noOuter) }, o.top ? (r.options.inner.top = n.bottom - c.height, r.options.outer.top = n.bottom - p.height) : o.bottom && (r.options.inner.bottom = n.top + c.height, r.options.outer.bottom = n.top + p.height), o.left ? (r.options.inner.left = n.right - c.width, r.options.outer.left = n.right - p.width) : o.right && (r.options.inner.right = n.left + c.width, r.options.outer.right = n.left + p.width), ht.set(t), r.options = l;\n      }\n    }, defaults: { min: null, max: null, endOnly: !1, enabled: !1 } }, \"restrictSize\"), mr = { start: function(t) {\n      var e, r = t.interaction, n = t.interactable, o = t.element, l = t.rect, c = t.state, p = t.startOffset, h = c.options, g = h.offsetWithOrigin ? function(w) {\n        var I = w.interaction.element, E = _e(ye(w.state.options.origin, null, null, [I])), D = E || it(w.interactable, I, w.interaction.prepared.name);\n        return D;\n      }(t) : { x: 0, y: 0 };\n      if (h.offset === \"startCoords\") e = { x: r.coords.start.page.x, y: r.coords.start.page.y };\n      else {\n        var d = ye(h.offset, n, o, [r]);\n        (e = _e(d) || { x: 0, y: 0 }).x += g.x, e.y += g.y;\n      }\n      var b = h.relativePoints;\n      c.offsets = l && b && b.length ? b.map(function(w, I) {\n        return { index: I, relativePoint: w, x: p.left - l.width * w.x + e.x, y: p.top - l.height * w.y + e.y };\n      }) : [{ index: 0, relativePoint: null, x: e.x, y: e.y }];\n    }, set: function(t) {\n      var e = t.interaction, r = t.coords, n = t.state, o = n.options, l = n.offsets, c = it(e.interactable, e.element, e.prepared.name), p = H({}, r), h = [];\n      o.offsetWithOrigin || (p.x -= c.x, p.y -= c.y);\n      for (var g = 0, d = l; g < d.length; g++) for (var b = d[g], w = p.x - b.x, I = p.y - b.y, E = 0, D = o.targets.length; E < D; E++) {\n        var L = o.targets[E], j = void 0;\n        (j = S.func(L) ? L(w, I, e._proxy, b, E) : L) && h.push({ x: (S.number(j.x) ? j.x : w) + b.x, y: (S.number(j.y) ? j.y : I) + b.y, range: S.number(j.range) ? j.range : o.range, source: L, index: E, offset: b });\n      }\n      for (var Y = { target: null, inRange: !1, distance: 0, range: 0, delta: { x: 0, y: 0 } }, q = 0; q < h.length; q++) {\n        var ee = h[q], B = ee.range, Z = ee.x - p.x, me = ee.y - p.y, le = ot(Z, me), Te = le <= B;\n        B === 1 / 0 && Y.inRange && Y.range !== 1 / 0 && (Te = !1), Y.target && !(Te ? Y.inRange && B !== 1 / 0 ? le / B < Y.distance / Y.range : B === 1 / 0 && Y.range !== 1 / 0 || le < Y.distance : !Y.inRange && le < Y.distance) || (Y.target = ee, Y.distance = le, Y.range = B, Y.inRange = Te, Y.delta.x = Z, Y.delta.y = me);\n      }\n      return Y.inRange && (r.x = Y.target.x, r.y = Y.target.y), n.closest = Y, Y;\n    }, defaults: { range: 1 / 0, targets: null, offset: null, offsetWithOrigin: !0, origin: null, relativePoints: null, endOnly: !1, enabled: !1 } }, as = Ae(mr, \"snap\"), It = { start: function(t) {\n      var e = t.state, r = t.edges, n = e.options;\n      if (!r) return null;\n      t.state = { options: { targets: null, relativePoints: [{ x: r.left ? 0 : 1, y: r.top ? 0 : 1 }], offset: n.offset || \"self\", origin: { x: 0, y: 0 }, range: n.range } }, e.targetFields = e.targetFields || [[\"width\", \"height\"], [\"x\", \"y\"]], mr.start(t), e.offsets = t.state.offsets, t.state = e;\n    }, set: function(t) {\n      var e = t.interaction, r = t.state, n = t.coords, o = r.options, l = r.offsets, c = { x: n.x - l[0].x, y: n.y - l[0].y };\n      r.options = H({}, o), r.options.targets = [];\n      for (var p = 0, h = o.targets || []; p < h.length; p++) {\n        var g = h[p], d = void 0;\n        if (d = S.func(g) ? g(c.x, c.y, e) : g) {\n          for (var b = 0, w = r.targetFields; b < w.length; b++) {\n            var I = w[b], E = I[0], D = I[1];\n            if (E in d || D in d) {\n              d.x = d[E], d.y = d[D];\n              break;\n            }\n          }\n          r.options.targets.push(d);\n        }\n      }\n      var L = mr.set(t);\n      return r.options = o, L;\n    }, defaults: { range: 1 / 0, targets: null, offset: null, endOnly: !1, enabled: !1 } }, ls = Ae(It, \"snapSize\"), br = { aspectRatio: Qo, restrictEdges: ts, restrict: es, restrictRect: ns, restrictSize: ss, snapEdges: Ae({ start: function(t) {\n      var e = t.edges;\n      return e ? (t.state.targetFields = t.state.targetFields || [[e.left ? \"left\" : \"right\", e.top ? \"top\" : \"bottom\"]], It.start(t)) : null;\n    }, set: It.set, defaults: H(Be(It.defaults), { targets: void 0, range: void 0, offset: { x: 0, y: 0 } }) }, \"snapEdges\"), snap: as, snapSize: ls, spring: Mt, avoid: Mt, transform: Mt, rubberband: Mt }, cs = { id: \"modifiers\", install: function(t) {\n      var e = t.interactStatic;\n      for (var r in t.usePlugin(bn), t.usePlugin(Vo), e.modifiers = br, br) {\n        var n = br[r], o = n._defaults, l = n._methods;\n        o._methods = l, t.defaults.perAction[r] = o;\n      }\n    } }, us = cs, An = function(t) {\n      O(r, t);\n      var e = _(r);\n      function r(n, o, l, c, p, h) {\n        var g;\n        if (v(this, r), bt(T(g = e.call(this, p)), l), l !== o && bt(T(g), o), g.timeStamp = h, g.originalEvent = l, g.type = n, g.pointerId = st(o), g.pointerType = Qr(o), g.target = c, g.currentTarget = null, n === \"tap\") {\n          var d = p.getPointerIndex(o);\n          g.dt = g.timeStamp - p.pointers[d].downTime;\n          var b = g.timeStamp - p.tapTime;\n          g.double = !!p.prevTap && p.prevTap.type !== \"doubletap\" && p.prevTap.target === g.target && b < 500;\n        } else n === \"doubletap\" && (g.dt = o.timeStamp - p.tapTime, g.double = !0);\n        return g;\n      }\n      return y(r, [{ key: \"_subtractOrigin\", value: function(n) {\n        var o = n.x, l = n.y;\n        return this.pageX -= o, this.pageY -= l, this.clientX -= o, this.clientY -= l, this;\n      } }, { key: \"_addOrigin\", value: function(n) {\n        var o = n.x, l = n.y;\n        return this.pageX += o, this.pageY += l, this.clientX += o, this.clientY += l, this;\n      } }, { key: \"preventDefault\", value: function() {\n        this.originalEvent.preventDefault();\n      } }]), r;\n    }(wt), dt = { id: \"pointer-events/base\", before: [\"inertia\", \"modifiers\", \"auto-start\", \"actions\"], install: function(t) {\n      t.pointerEvents = dt, t.defaults.actions.pointerEvents = dt.defaults, H(t.actions.phaselessTypes, dt.types);\n    }, listeners: { \"interactions:new\": function(t) {\n      var e = t.interaction;\n      e.prevTap = null, e.tapTime = 0;\n    }, \"interactions:update-pointer\": function(t) {\n      var e = t.down, r = t.pointerInfo;\n      !e && r.hold || (r.hold = { duration: 1 / 0, timeout: null });\n    }, \"interactions:move\": function(t, e) {\n      var r = t.interaction, n = t.pointer, o = t.event, l = t.eventTarget;\n      t.duplicate || r.pointerIsDown && !r.pointerWasMoved || (r.pointerIsDown && yr(t), He({ interaction: r, pointer: n, event: o, eventTarget: l, type: \"move\" }, e));\n    }, \"interactions:down\": function(t, e) {\n      (function(r, n) {\n        for (var o = r.interaction, l = r.pointer, c = r.event, p = r.eventTarget, h = r.pointerIndex, g = o.pointers[h].hold, d = Ce(p), b = { interaction: o, pointer: l, event: c, eventTarget: p, type: \"hold\", targets: [], path: d, node: null }, w = 0; w < d.length; w++) {\n          var I = d[w];\n          b.node = I, n.fire(\"pointerEvents:collect-targets\", b);\n        }\n        if (b.targets.length) {\n          for (var E = 1 / 0, D = 0, L = b.targets; D < L.length; D++) {\n            var j = L[D].eventable.options.holdDuration;\n            j < E && (E = j);\n          }\n          g.duration = E, g.timeout = setTimeout(function() {\n            He({ interaction: o, eventTarget: p, pointer: l, event: c, type: \"hold\" }, n);\n          }, E);\n        }\n      })(t, e), He(t, e);\n    }, \"interactions:up\": function(t, e) {\n      yr(t), He(t, e), function(r, n) {\n        var o = r.interaction, l = r.pointer, c = r.event, p = r.eventTarget;\n        o.pointerWasMoved || He({ interaction: o, eventTarget: p, pointer: l, event: c, type: \"tap\" }, n);\n      }(t, e);\n    }, \"interactions:cancel\": function(t, e) {\n      yr(t), He(t, e);\n    } }, PointerEvent: An, fire: He, collectEventTargets: Ln, defaults: { holdDuration: 600, ignoreFrom: null, allowFrom: null, origin: { x: 0, y: 0 } }, types: { down: !0, move: !0, up: !0, cancel: !0, tap: !0, doubletap: !0, hold: !0 } };\n    function He(t, e) {\n      var r = t.interaction, n = t.pointer, o = t.event, l = t.eventTarget, c = t.type, p = t.targets, h = p === void 0 ? Ln(t, e) : p, g = new An(c, n, o, l, r, e.now());\n      e.fire(\"pointerEvents:new\", { pointerEvent: g });\n      for (var d = { interaction: r, pointer: n, event: o, eventTarget: l, targets: h, type: c, pointerEvent: g }, b = 0; b < h.length; b++) {\n        var w = h[b];\n        for (var I in w.props || {}) g[I] = w.props[I];\n        var E = it(w.eventable, w.node);\n        if (g._subtractOrigin(E), g.eventable = w.eventable, g.currentTarget = w.node, w.eventable.fire(g), g._addOrigin(E), g.immediatePropagationStopped || g.propagationStopped && b + 1 < h.length && h[b + 1].node !== g.currentTarget) break;\n      }\n      if (e.fire(\"pointerEvents:fired\", d), c === \"tap\") {\n        var D = g.double ? He({ interaction: r, pointer: n, event: o, eventTarget: l, type: \"doubletap\" }, e) : g;\n        r.prevTap = D, r.tapTime = D.timeStamp;\n      }\n      return g;\n    }\n    function Ln(t, e) {\n      var r = t.interaction, n = t.pointer, o = t.event, l = t.eventTarget, c = t.type, p = r.getPointerIndex(n), h = r.pointers[p];\n      if (c === \"tap\" && (r.pointerWasMoved || !h || h.downTarget !== l)) return [];\n      for (var g = Ce(l), d = { interaction: r, pointer: n, event: o, eventTarget: l, type: c, path: g, targets: [], node: null }, b = 0; b < g.length; b++) {\n        var w = g[b];\n        d.node = w, e.fire(\"pointerEvents:collect-targets\", d);\n      }\n      return c === \"hold\" && (d.targets = d.targets.filter(function(I) {\n        var E, D;\n        return I.eventable.options.holdDuration === ((E = r.pointers[p]) == null || (D = E.hold) == null ? void 0 : D.duration);\n      })), d.targets;\n    }\n    function yr(t) {\n      var e = t.interaction, r = t.pointerIndex, n = e.pointers[r].hold;\n      n && n.timeout && (clearTimeout(n.timeout), n.timeout = null);\n    }\n    var ps = Object.freeze({ __proto__: null, default: dt });\n    function hs(t) {\n      var e = t.interaction;\n      e.holdIntervalHandle && (clearInterval(e.holdIntervalHandle), e.holdIntervalHandle = null);\n    }\n    var ds = { id: \"pointer-events/holdRepeat\", install: function(t) {\n      t.usePlugin(dt);\n      var e = t.pointerEvents;\n      e.defaults.holdRepeatInterval = 0, e.types.holdrepeat = t.actions.phaselessTypes.holdrepeat = !0;\n    }, listeners: [\"move\", \"up\", \"cancel\", \"endall\"].reduce(function(t, e) {\n      return t[\"pointerEvents:\".concat(e)] = hs, t;\n    }, { \"pointerEvents:new\": function(t) {\n      var e = t.pointerEvent;\n      e.type === \"hold\" && (e.count = (e.count || 0) + 1);\n    }, \"pointerEvents:fired\": function(t, e) {\n      var r = t.interaction, n = t.pointerEvent, o = t.eventTarget, l = t.targets;\n      if (n.type === \"hold\" && l.length) {\n        var c = l[0].eventable.options.holdRepeatInterval;\n        c <= 0 || (r.holdIntervalHandle = setTimeout(function() {\n          e.pointerEvents.fire({ interaction: r, eventTarget: o, type: \"hold\", pointer: n, event: n }, e);\n        }, c));\n      }\n    } }) }, fs = ds, vs = { id: \"pointer-events/interactableTargets\", install: function(t) {\n      var e = t.Interactable;\n      e.prototype.pointerEvents = function(n) {\n        return H(this.events.options, n), this;\n      };\n      var r = e.prototype._backCompatOption;\n      e.prototype._backCompatOption = function(n, o) {\n        var l = r.call(this, n, o);\n        return l === this && (this.events.options[n] = o), l;\n      };\n    }, listeners: { \"pointerEvents:collect-targets\": function(t, e) {\n      var r = t.targets, n = t.node, o = t.type, l = t.eventTarget;\n      e.interactables.forEachMatch(n, function(c) {\n        var p = c.events, h = p.options;\n        p.types[o] && p.types[o].length && c.testIgnoreAllow(h, n, l) && r.push({ node: n, eventable: p, props: { interactable: c } });\n      });\n    }, \"interactable:new\": function(t) {\n      var e = t.interactable;\n      e.events.getRect = function(r) {\n        return e.getRect(r);\n      };\n    }, \"interactable:set\": function(t, e) {\n      var r = t.interactable, n = t.options;\n      H(r.events.options, e.pointerEvents.defaults), H(r.events.options, n.pointerEvents || {});\n    } } }, gs = vs, ms = { id: \"pointer-events\", install: function(t) {\n      t.usePlugin(ps), t.usePlugin(fs), t.usePlugin(gs);\n    } }, bs = ms, ys = { id: \"reflow\", install: function(t) {\n      var e = t.Interactable;\n      t.actions.phases.reflow = !0, e.prototype.reflow = function(r) {\n        return function(n, o, l) {\n          for (var c = n.getAllElements(), p = l.window.Promise, h = p ? [] : null, g = function() {\n            var b = c[d], w = n.getRect(b);\n            if (!w) return 1;\n            var I, E = lt(l.interactions.list, function(j) {\n              return j.interacting() && j.interactable === n && j.element === b && j.prepared.name === o.name;\n            });\n            if (E) E.move(), h && (I = E._reflowPromise || new p(function(j) {\n              E._reflowResolve = j;\n            }));\n            else {\n              var D = ze(w), L = /* @__PURE__ */ function(j) {\n                return { coords: j, get page() {\n                  return this.coords.page;\n                }, get client() {\n                  return this.coords.client;\n                }, get timeStamp() {\n                  return this.coords.timeStamp;\n                }, get pageX() {\n                  return this.coords.page.x;\n                }, get pageY() {\n                  return this.coords.page.y;\n                }, get clientX() {\n                  return this.coords.client.x;\n                }, get clientY() {\n                  return this.coords.client.y;\n                }, get pointerId() {\n                  return this.coords.pointerId;\n                }, get target() {\n                  return this.coords.target;\n                }, get type() {\n                  return this.coords.type;\n                }, get pointerType() {\n                  return this.coords.pointerType;\n                }, get buttons() {\n                  return this.coords.buttons;\n                }, preventDefault: function() {\n                } };\n              }({ page: { x: D.x, y: D.y }, client: { x: D.x, y: D.y }, timeStamp: l.now() });\n              I = function(j, Y, q, ee, B) {\n                var Z = j.interactions.new({ pointerType: \"reflow\" }), me = { interaction: Z, event: B, pointer: B, eventTarget: q, phase: \"reflow\" };\n                Z.interactable = Y, Z.element = q, Z.prevEvent = B, Z.updatePointer(B, B, q, !0), Vr(Z.coords.delta), ar(Z.prepared, ee), Z._doPhase(me);\n                var le = j.window, Te = le.Promise, Se = Te ? new Te(function(De) {\n                  Z._reflowResolve = De;\n                }) : void 0;\n                return Z._reflowPromise = Se, Z.start(ee, Y, q), Z._interacting ? (Z.move(me), Z.end(B)) : (Z.stop(), Z._reflowResolve()), Z.removePointer(B, B), Se;\n              }(l, n, b, o, L);\n            }\n            h && h.push(I);\n          }, d = 0; d < c.length && !g(); d++) ;\n          return h && p.all(h).then(function() {\n            return n;\n          });\n        }(this, r, t);\n      };\n    }, listeners: { \"interactions:stop\": function(t, e) {\n      var r = t.interaction;\n      r.pointerType === \"reflow\" && (r._reflowResolve && r._reflowResolve(), function(n, o) {\n        n.splice(n.indexOf(o), 1);\n      }(e.interactions.list, r));\n    } } }, Ts = ys;\n    if (ge.use(mn), ge.use(xn), ge.use(bs), ge.use(Ao), ge.use(us), ge.use(Co), ge.use(fo), ge.use(go), ge.use(Ts), ge.default = ge, f(s) === \"object\" && s) try {\n      s.exports = ge;\n    } catch {\n    }\n    return ge.default = ge, ge;\n  });\n})(Lt, Lt.exports);\nvar Ss = Lt.exports;\nconst Tr = /* @__PURE__ */ Ze(Ss);\nvar xi = { exports: {} };\n(function(s, i) {\n  (function(a, u) {\n    s.exports = u();\n  })(We, function() {\n    var a = 1e3, u = 6e4, f = 36e5, v = \"millisecond\", m = \"second\", y = \"minute\", x = \"hour\", O = \"day\", $ = \"week\", P = \"month\", T = \"quarter\", _ = \"year\", M = \"date\", C = \"Invalid Date\", z = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/, N = /\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, G = { name: \"en\", weekdays: \"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\".split(\"_\"), months: \"January_February_March_April_May_June_July_August_September_October_November_December\".split(\"_\"), ordinal: function(W) {\n      var k = [\"th\", \"st\", \"nd\", \"rd\"], R = W % 100;\n      return \"[\" + W + (k[(R - 20) % 10] || k[R] || k[0]) + \"]\";\n    } }, Q = function(W, k, R) {\n      var F = String(W);\n      return !F || F.length >= k ? W : \"\" + Array(k + 1 - F.length).join(R) + W;\n    }, te = { s: Q, z: function(W) {\n      var k = -W.utcOffset(), R = Math.abs(k), F = Math.floor(R / 60), A = R % 60;\n      return (k <= 0 ? \"+\" : \"-\") + Q(F, 2, \"0\") + \":\" + Q(A, 2, \"0\");\n    }, m: function W(k, R) {\n      if (k.date() < R.date()) return -W(R, k);\n      var F = 12 * (R.year() - k.year()) + (R.month() - k.month()), A = k.clone().add(F, P), K = R - A < 0, X = k.clone().add(F + (K ? -1 : 1), P);\n      return +(-(F + (R - A) / (K ? A - X : X - A)) || 0);\n    }, a: function(W) {\n      return W < 0 ? Math.ceil(W) || 0 : Math.floor(W);\n    }, p: function(W) {\n      return { M: P, y: _, w: $, d: O, D: M, h: x, m: y, s: m, ms: v, Q: T }[W] || String(W || \"\").toLowerCase().replace(/s$/, \"\");\n    }, u: function(W) {\n      return W === void 0;\n    } }, re = \"en\", ue = {};\n    ue[re] = G;\n    var S = \"$isDayjsObject\", be = function(W) {\n      return W instanceof de || !(!W || !W[S]);\n    }, we = function W(k, R, F) {\n      var A;\n      if (!k) return re;\n      if (typeof k == \"string\") {\n        var K = k.toLowerCase();\n        ue[K] && (A = K), R && (ue[K] = R, A = K);\n        var X = k.split(\"-\");\n        if (!A && X.length > 1) return W(X[0]);\n      } else {\n        var ie = k.name;\n        ue[ie] = k, A = ie;\n      }\n      return !F && A && (re = A), A || !F && re;\n    }, ce = function(W, k) {\n      if (be(W)) return W.clone();\n      var R = typeof k == \"object\" ? k : {};\n      return R.date = W, R.args = arguments, new de(R);\n    }, ne = te;\n    ne.l = we, ne.i = be, ne.w = function(W, k) {\n      return ce(W, { locale: k.$L, utc: k.$u, x: k.$x, $offset: k.$offset });\n    };\n    var de = function() {\n      function W(R) {\n        this.$L = we(R.locale, null, !0), this.parse(R), this.$x = this.$x || R.x || {}, this[S] = !0;\n      }\n      var k = W.prototype;\n      return k.parse = function(R) {\n        this.$d = function(F) {\n          var A = F.date, K = F.utc;\n          if (A === null) return /* @__PURE__ */ new Date(NaN);\n          if (ne.u(A)) return /* @__PURE__ */ new Date();\n          if (A instanceof Date) return new Date(A);\n          if (typeof A == \"string\" && !/Z$/i.test(A)) {\n            var X = A.match(z);\n            if (X) {\n              var ie = X[2] - 1 || 0, ae = (X[7] || \"0\").substring(0, 3);\n              return K ? new Date(Date.UTC(X[1], ie, X[3] || 1, X[4] || 0, X[5] || 0, X[6] || 0, ae)) : new Date(X[1], ie, X[3] || 1, X[4] || 0, X[5] || 0, X[6] || 0, ae);\n            }\n          }\n          return new Date(A);\n        }(R), this.init();\n      }, k.init = function() {\n        var R = this.$d;\n        this.$y = R.getFullYear(), this.$M = R.getMonth(), this.$D = R.getDate(), this.$W = R.getDay(), this.$H = R.getHours(), this.$m = R.getMinutes(), this.$s = R.getSeconds(), this.$ms = R.getMilliseconds();\n      }, k.$utils = function() {\n        return ne;\n      }, k.isValid = function() {\n        return this.$d.toString() !== C;\n      }, k.isSame = function(R, F) {\n        var A = ce(R);\n        return this.startOf(F) <= A && A <= this.endOf(F);\n      }, k.isAfter = function(R, F) {\n        return ce(R) < this.startOf(F);\n      }, k.isBefore = function(R, F) {\n        return this.endOf(F) < ce(R);\n      }, k.$g = function(R, F, A) {\n        return ne.u(R) ? this[F] : this.set(A, R);\n      }, k.unix = function() {\n        return Math.floor(this.valueOf() / 1e3);\n      }, k.valueOf = function() {\n        return this.$d.getTime();\n      }, k.startOf = function(R, F) {\n        var A = this, K = !!ne.u(F) || F, X = ne.p(R), ie = function(H, fe) {\n          var ye = ne.w(A.$u ? Date.UTC(A.$y, fe, H) : new Date(A.$y, fe, H), A);\n          return K ? ye : ye.endOf(O);\n        }, ae = function(H, fe) {\n          return ne.w(A.toDate()[H].apply(A.toDate(\"s\"), (K ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(fe)), A);\n        }, pe = this.$W, he = this.$M, ve = this.$D, Oe = \"set\" + (this.$u ? \"UTC\" : \"\");\n        switch (X) {\n          case _:\n            return K ? ie(1, 0) : ie(31, 11);\n          case P:\n            return K ? ie(1, he) : ie(0, he + 1);\n          case $:\n            var Ce = this.$locale().weekStart || 0, ke = (pe < Ce ? pe + 7 : pe) - Ce;\n            return ie(K ? ve - ke : ve + (6 - ke), he);\n          case O:\n          case M:\n            return ae(Oe + \"Hours\", 0);\n          case x:\n            return ae(Oe + \"Minutes\", 1);\n          case y:\n            return ae(Oe + \"Seconds\", 2);\n          case m:\n            return ae(Oe + \"Milliseconds\", 3);\n          default:\n            return this.clone();\n        }\n      }, k.endOf = function(R) {\n        return this.startOf(R, !1);\n      }, k.$set = function(R, F) {\n        var A, K = ne.p(R), X = \"set\" + (this.$u ? \"UTC\" : \"\"), ie = (A = {}, A[O] = X + \"Date\", A[M] = X + \"Date\", A[P] = X + \"Month\", A[_] = X + \"FullYear\", A[x] = X + \"Hours\", A[y] = X + \"Minutes\", A[m] = X + \"Seconds\", A[v] = X + \"Milliseconds\", A)[K], ae = K === O ? this.$D + (F - this.$W) : F;\n        if (K === P || K === _) {\n          var pe = this.clone().set(M, 1);\n          pe.$d[ie](ae), pe.init(), this.$d = pe.set(M, Math.min(this.$D, pe.daysInMonth())).$d;\n        } else ie && this.$d[ie](ae);\n        return this.init(), this;\n      }, k.set = function(R, F) {\n        return this.clone().$set(R, F);\n      }, k.get = function(R) {\n        return this[ne.p(R)]();\n      }, k.add = function(R, F) {\n        var A, K = this;\n        R = Number(R);\n        var X = ne.p(F), ie = function(he) {\n          var ve = ce(K);\n          return ne.w(ve.date(ve.date() + Math.round(he * R)), K);\n        };\n        if (X === P) return this.set(P, this.$M + R);\n        if (X === _) return this.set(_, this.$y + R);\n        if (X === O) return ie(1);\n        if (X === $) return ie(7);\n        var ae = (A = {}, A[y] = u, A[x] = f, A[m] = a, A)[X] || 1, pe = this.$d.getTime() + R * ae;\n        return ne.w(pe, this);\n      }, k.subtract = function(R, F) {\n        return this.add(-1 * R, F);\n      }, k.format = function(R) {\n        var F = this, A = this.$locale();\n        if (!this.isValid()) return A.invalidDate || C;\n        var K = R || \"YYYY-MM-DDTHH:mm:ssZ\", X = ne.z(this), ie = this.$H, ae = this.$m, pe = this.$M, he = A.weekdays, ve = A.months, Oe = A.meridiem, Ce = function(fe, ye, _e, ze) {\n          return fe && (fe[ye] || fe(F, K)) || _e[ye].slice(0, ze);\n        }, ke = function(fe) {\n          return ne.s(ie % 12 || 12, fe, \"0\");\n        }, H = Oe || function(fe, ye, _e) {\n          var ze = fe < 12 ? \"AM\" : \"PM\";\n          return _e ? ze.toLowerCase() : ze;\n        };\n        return K.replace(N, function(fe, ye) {\n          return ye || function(_e) {\n            switch (_e) {\n              case \"YY\":\n                return String(F.$y).slice(-2);\n              case \"YYYY\":\n                return ne.s(F.$y, 4, \"0\");\n              case \"M\":\n                return pe + 1;\n              case \"MM\":\n                return ne.s(pe + 1, 2, \"0\");\n              case \"MMM\":\n                return Ce(A.monthsShort, pe, ve, 3);\n              case \"MMMM\":\n                return Ce(ve, pe);\n              case \"D\":\n                return F.$D;\n              case \"DD\":\n                return ne.s(F.$D, 2, \"0\");\n              case \"d\":\n                return String(F.$W);\n              case \"dd\":\n                return Ce(A.weekdaysMin, F.$W, he, 2);\n              case \"ddd\":\n                return Ce(A.weekdaysShort, F.$W, he, 3);\n              case \"dddd\":\n                return he[F.$W];\n              case \"H\":\n                return String(ie);\n              case \"HH\":\n                return ne.s(ie, 2, \"0\");\n              case \"h\":\n                return ke(1);\n              case \"hh\":\n                return ke(2);\n              case \"a\":\n                return H(ie, ae, !0);\n              case \"A\":\n                return H(ie, ae, !1);\n              case \"m\":\n                return String(ae);\n              case \"mm\":\n                return ne.s(ae, 2, \"0\");\n              case \"s\":\n                return String(F.$s);\n              case \"ss\":\n                return ne.s(F.$s, 2, \"0\");\n              case \"SSS\":\n                return ne.s(F.$ms, 3, \"0\");\n              case \"Z\":\n                return X;\n            }\n            return null;\n          }(fe) || X.replace(\":\", \"\");\n        });\n      }, k.utcOffset = function() {\n        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);\n      }, k.diff = function(R, F, A) {\n        var K, X = this, ie = ne.p(F), ae = ce(R), pe = (ae.utcOffset() - this.utcOffset()) * u, he = this - ae, ve = function() {\n          return ne.m(X, ae);\n        };\n        switch (ie) {\n          case _:\n            K = ve() / 12;\n            break;\n          case P:\n            K = ve();\n            break;\n          case T:\n            K = ve() / 3;\n            break;\n          case $:\n            K = (he - pe) / 6048e5;\n            break;\n          case O:\n            K = (he - pe) / 864e5;\n            break;\n          case x:\n            K = he / f;\n            break;\n          case y:\n            K = he / u;\n            break;\n          case m:\n            K = he / a;\n            break;\n          default:\n            K = he;\n        }\n        return A ? K : ne.a(K);\n      }, k.daysInMonth = function() {\n        return this.endOf(P).$D;\n      }, k.$locale = function() {\n        return ue[this.$L];\n      }, k.locale = function(R, F) {\n        if (!R) return this.$L;\n        var A = this.clone(), K = we(R, F, !0);\n        return K && (A.$L = K), A;\n      }, k.clone = function() {\n        return ne.w(this.$d, this);\n      }, k.toDate = function() {\n        return new Date(this.valueOf());\n      }, k.toJSON = function() {\n        return this.isValid() ? this.toISOString() : null;\n      }, k.toISOString = function() {\n        return this.$d.toISOString();\n      }, k.toString = function() {\n        return this.$d.toUTCString();\n      }, W;\n    }(), Ee = de.prototype;\n    return ce.prototype = Ee, [[\"$ms\", v], [\"$s\", m], [\"$m\", y], [\"$H\", x], [\"$W\", O], [\"$M\", P], [\"$y\", _], [\"$D\", M]].forEach(function(W) {\n      Ee[W[1]] = function(k) {\n        return this.$g(k, W[0], W[1]);\n      };\n    }), ce.extend = function(W, k) {\n      return W.$i || (W(k, de, ce), W.$i = !0), ce;\n    }, ce.locale = we, ce.isDayjs = be, ce.unix = function(W) {\n      return ce(1e3 * W);\n    }, ce.en = ue[re], ce.Ls = ue, ce.p = {}, ce;\n  });\n})(xi);\nvar xs = xi.exports;\nconst Me = /* @__PURE__ */ Ze(xs);\nvar Oi = { exports: {} };\n(function(s, i) {\n  (function(a, u) {\n    s.exports = u();\n  })(We, function() {\n    var a = \"minute\", u = /[+-]\\d\\d(?::?\\d\\d)?/g, f = /([+-]|\\d\\d)/g;\n    return function(v, m, y) {\n      var x = m.prototype;\n      y.utc = function(C) {\n        var z = { date: C, utc: !0, args: arguments };\n        return new m(z);\n      }, x.utc = function(C) {\n        var z = y(this.toDate(), { locale: this.$L, utc: !0 });\n        return C ? z.add(this.utcOffset(), a) : z;\n      }, x.local = function() {\n        return y(this.toDate(), { locale: this.$L, utc: !1 });\n      };\n      var O = x.parse;\n      x.parse = function(C) {\n        C.utc && (this.$u = !0), this.$utils().u(C.$offset) || (this.$offset = C.$offset), O.call(this, C);\n      };\n      var $ = x.init;\n      x.init = function() {\n        if (this.$u) {\n          var C = this.$d;\n          this.$y = C.getUTCFullYear(), this.$M = C.getUTCMonth(), this.$D = C.getUTCDate(), this.$W = C.getUTCDay(), this.$H = C.getUTCHours(), this.$m = C.getUTCMinutes(), this.$s = C.getUTCSeconds(), this.$ms = C.getUTCMilliseconds();\n        } else $.call(this);\n      };\n      var P = x.utcOffset;\n      x.utcOffset = function(C, z) {\n        var N = this.$utils().u;\n        if (N(C)) return this.$u ? 0 : N(this.$offset) ? P.call(this) : this.$offset;\n        if (typeof C == \"string\" && (C = function(re) {\n          re === void 0 && (re = \"\");\n          var ue = re.match(u);\n          if (!ue) return null;\n          var S = (\"\" + ue[0]).match(f) || [\"-\", 0, 0], be = S[0], we = 60 * +S[1] + +S[2];\n          return we === 0 ? 0 : be === \"+\" ? we : -we;\n        }(C), C === null)) return this;\n        var G = Math.abs(C) <= 16 ? 60 * C : C, Q = this;\n        if (z) return Q.$offset = G, Q.$u = C === 0, Q;\n        if (C !== 0) {\n          var te = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();\n          (Q = this.local().add(G + te, a)).$offset = G, Q.$x.$localOffset = te;\n        } else Q = this.utc();\n        return Q;\n      };\n      var T = x.format;\n      x.format = function(C) {\n        var z = C || (this.$u ? \"YYYY-MM-DDTHH:mm:ss[Z]\" : \"\");\n        return T.call(this, z);\n      }, x.valueOf = function() {\n        var C = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());\n        return this.$d.valueOf() - 6e4 * C;\n      }, x.isUTC = function() {\n        return !!this.$u;\n      }, x.toISOString = function() {\n        return this.toDate().toISOString();\n      }, x.toString = function() {\n        return this.toDate().toUTCString();\n      };\n      var _ = x.toDate;\n      x.toDate = function(C) {\n        return C === \"s\" && this.$offset ? y(this.format(\"YYYY-MM-DD HH:mm:ss:SSS\")).toDate() : _.call(this);\n      };\n      var M = x.diff;\n      x.diff = function(C, z, N) {\n        if (C && this.$u === C.$u) return M.call(this, C, z, N);\n        var G = this.local(), Q = y(C).local();\n        return M.call(G, Q, z, N);\n      };\n    };\n  });\n})(Oi);\nvar Os = Oi.exports;\nconst Cs = /* @__PURE__ */ Ze(Os);\nfunction _s() {\n  this.__data__ = [], this.size = 0;\n}\nvar Ms = _s;\nfunction Es(s, i) {\n  return s === i || s !== s && i !== i;\n}\nvar Ci = Es, Is = Ci;\nfunction Ps(s, i) {\n  for (var a = s.length; a--; )\n    if (Is(s[a][0], i))\n      return a;\n  return -1;\n}\nvar Yt = Ps, Ds = Yt, Rs = Array.prototype, $s = Rs.splice;\nfunction ks(s) {\n  var i = this.__data__, a = Ds(i, s);\n  if (a < 0)\n    return !1;\n  var u = i.length - 1;\n  return a == u ? i.pop() : $s.call(i, a, 1), --this.size, !0;\n}\nvar zs = ks, js = Yt;\nfunction As(s) {\n  var i = this.__data__, a = js(i, s);\n  return a < 0 ? void 0 : i[a][1];\n}\nvar Ls = As, Hs = Yt;\nfunction Ws(s) {\n  return Hs(this.__data__, s) > -1;\n}\nvar Fs = Ws, Us = Yt;\nfunction Ns(s, i) {\n  var a = this.__data__, u = Us(a, s);\n  return u < 0 ? (++this.size, a.push([s, i])) : a[u][1] = i, this;\n}\nvar Ys = Ns, Gs = Ms, Ks = zs, Xs = Ls, Bs = Fs, Vs = Ys;\nfunction Je(s) {\n  var i = -1, a = s == null ? 0 : s.length;\n  for (this.clear(); ++i < a; ) {\n    var u = s[i];\n    this.set(u[0], u[1]);\n  }\n}\nJe.prototype.clear = Gs;\nJe.prototype.delete = Ks;\nJe.prototype.get = Xs;\nJe.prototype.has = Bs;\nJe.prototype.set = Vs;\nvar Gt = Je, qs = Gt;\nfunction Zs() {\n  this.__data__ = new qs(), this.size = 0;\n}\nvar Js = Zs;\nfunction Qs(s) {\n  var i = this.__data__, a = i.delete(s);\n  return this.size = i.size, a;\n}\nvar ea = Qs;\nfunction ta(s) {\n  return this.__data__.get(s);\n}\nvar ra = ta;\nfunction na(s) {\n  return this.__data__.has(s);\n}\nvar ia = na, oa = typeof We == \"object\" && We && We.Object === Object && We, _i = oa, sa = _i, aa = typeof self == \"object\" && self && self.Object === Object && self, la = sa || aa || Function(\"return this\")(), $e = la, ca = $e, ua = ca.Symbol, kr = ua, Wn = kr, Mi = Object.prototype, pa = Mi.hasOwnProperty, ha = Mi.toString, vt = Wn ? Wn.toStringTag : void 0;\nfunction da(s) {\n  var i = pa.call(s, vt), a = s[vt];\n  try {\n    s[vt] = void 0;\n    var u = !0;\n  } catch {\n  }\n  var f = ha.call(s);\n  return u && (i ? s[vt] = a : delete s[vt]), f;\n}\nvar fa = da, va = Object.prototype, ga = va.toString;\nfunction ma(s) {\n  return ga.call(s);\n}\nvar ba = ma, Fn = kr, ya = fa, Ta = ba, wa = \"[object Null]\", Sa = \"[object Undefined]\", Un = Fn ? Fn.toStringTag : void 0;\nfunction xa(s) {\n  return s == null ? s === void 0 ? Sa : wa : Un && Un in Object(s) ? ya(s) : Ta(s);\n}\nvar Kt = xa;\nfunction Oa(s) {\n  var i = typeof s;\n  return s != null && (i == \"object\" || i == \"function\");\n}\nvar Ei = Oa, Ca = Kt, _a = Ei, Ma = \"[object AsyncFunction]\", Ea = \"[object Function]\", Ia = \"[object GeneratorFunction]\", Pa = \"[object Proxy]\";\nfunction Da(s) {\n  if (!_a(s))\n    return !1;\n  var i = Ca(s);\n  return i == Ea || i == Ia || i == Ma || i == Pa;\n}\nvar Ii = Da, Ra = $e, $a = Ra[\"__core-js_shared__\"], ka = $a, wr = ka, Nn = function() {\n  var s = /[^.]+$/.exec(wr && wr.keys && wr.keys.IE_PROTO || \"\");\n  return s ? \"Symbol(src)_1.\" + s : \"\";\n}();\nfunction za(s) {\n  return !!Nn && Nn in s;\n}\nvar ja = za, Aa = Function.prototype, La = Aa.toString;\nfunction Ha(s) {\n  if (s != null) {\n    try {\n      return La.call(s);\n    } catch {\n    }\n    try {\n      return s + \"\";\n    } catch {\n    }\n  }\n  return \"\";\n}\nvar Pi = Ha, Wa = Ii, Fa = ja, Ua = Ei, Na = Pi, Ya = /[\\\\^$.*+?()[\\]{}|]/g, Ga = /^\\[object .+?Constructor\\]$/, Ka = Function.prototype, Xa = Object.prototype, Ba = Ka.toString, Va = Xa.hasOwnProperty, qa = RegExp(\n  \"^\" + Ba.call(Va).replace(Ya, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\"\n);\nfunction Za(s) {\n  if (!Ua(s) || Fa(s))\n    return !1;\n  var i = Wa(s) ? qa : Ga;\n  return i.test(Na(s));\n}\nvar Ja = Za;\nfunction Qa(s, i) {\n  return s == null ? void 0 : s[i];\n}\nvar el = Qa, tl = Ja, rl = el;\nfunction nl(s, i) {\n  var a = rl(s, i);\n  return tl(a) ? a : void 0;\n}\nvar Qe = nl, il = Qe, ol = $e, sl = il(ol, \"Map\"), zr = sl, al = Qe, ll = al(Object, \"create\"), Xt = ll, Yn = Xt;\nfunction cl() {\n  this.__data__ = Yn ? Yn(null) : {}, this.size = 0;\n}\nvar ul = cl;\nfunction pl(s) {\n  var i = this.has(s) && delete this.__data__[s];\n  return this.size -= i ? 1 : 0, i;\n}\nvar hl = pl, dl = Xt, fl = \"__lodash_hash_undefined__\", vl = Object.prototype, gl = vl.hasOwnProperty;\nfunction ml(s) {\n  var i = this.__data__;\n  if (dl) {\n    var a = i[s];\n    return a === fl ? void 0 : a;\n  }\n  return gl.call(i, s) ? i[s] : void 0;\n}\nvar bl = ml, yl = Xt, Tl = Object.prototype, wl = Tl.hasOwnProperty;\nfunction Sl(s) {\n  var i = this.__data__;\n  return yl ? i[s] !== void 0 : wl.call(i, s);\n}\nvar xl = Sl, Ol = Xt, Cl = \"__lodash_hash_undefined__\";\nfunction _l(s, i) {\n  var a = this.__data__;\n  return this.size += this.has(s) ? 0 : 1, a[s] = Ol && i === void 0 ? Cl : i, this;\n}\nvar Ml = _l, El = ul, Il = hl, Pl = bl, Dl = xl, Rl = Ml;\nfunction et(s) {\n  var i = -1, a = s == null ? 0 : s.length;\n  for (this.clear(); ++i < a; ) {\n    var u = s[i];\n    this.set(u[0], u[1]);\n  }\n}\net.prototype.clear = El;\net.prototype.delete = Il;\net.prototype.get = Pl;\net.prototype.has = Dl;\net.prototype.set = Rl;\nvar $l = et, Gn = $l, kl = Gt, zl = zr;\nfunction jl() {\n  this.size = 0, this.__data__ = {\n    hash: new Gn(),\n    map: new (zl || kl)(),\n    string: new Gn()\n  };\n}\nvar Al = jl;\nfunction Ll(s) {\n  var i = typeof s;\n  return i == \"string\" || i == \"number\" || i == \"symbol\" || i == \"boolean\" ? s !== \"__proto__\" : s === null;\n}\nvar Hl = Ll, Wl = Hl;\nfunction Fl(s, i) {\n  var a = s.__data__;\n  return Wl(i) ? a[typeof i == \"string\" ? \"string\" : \"hash\"] : a.map;\n}\nvar Bt = Fl, Ul = Bt;\nfunction Nl(s) {\n  var i = Ul(this, s).delete(s);\n  return this.size -= i ? 1 : 0, i;\n}\nvar Yl = Nl, Gl = Bt;\nfunction Kl(s) {\n  return Gl(this, s).get(s);\n}\nvar Xl = Kl, Bl = Bt;\nfunction Vl(s) {\n  return Bl(this, s).has(s);\n}\nvar ql = Vl, Zl = Bt;\nfunction Jl(s, i) {\n  var a = Zl(this, s), u = a.size;\n  return a.set(s, i), this.size += a.size == u ? 0 : 1, this;\n}\nvar Ql = Jl, ec = Al, tc = Yl, rc = Xl, nc = ql, ic = Ql;\nfunction tt(s) {\n  var i = -1, a = s == null ? 0 : s.length;\n  for (this.clear(); ++i < a; ) {\n    var u = s[i];\n    this.set(u[0], u[1]);\n  }\n}\ntt.prototype.clear = ec;\ntt.prototype.delete = tc;\ntt.prototype.get = rc;\ntt.prototype.has = nc;\ntt.prototype.set = ic;\nvar Di = tt, oc = Gt, sc = zr, ac = Di, lc = 200;\nfunction cc(s, i) {\n  var a = this.__data__;\n  if (a instanceof oc) {\n    var u = a.__data__;\n    if (!sc || u.length < lc - 1)\n      return u.push([s, i]), this.size = ++a.size, this;\n    a = this.__data__ = new ac(u);\n  }\n  return a.set(s, i), this.size = a.size, this;\n}\nvar uc = cc, pc = Gt, hc = Js, dc = ea, fc = ra, vc = ia, gc = uc;\nfunction rt(s) {\n  var i = this.__data__ = new pc(s);\n  this.size = i.size;\n}\nrt.prototype.clear = hc;\nrt.prototype.delete = dc;\nrt.prototype.get = fc;\nrt.prototype.has = vc;\nrt.prototype.set = gc;\nvar mc = rt, bc = \"__lodash_hash_undefined__\";\nfunction yc(s) {\n  return this.__data__.set(s, bc), this;\n}\nvar Tc = yc;\nfunction wc(s) {\n  return this.__data__.has(s);\n}\nvar Sc = wc, xc = Di, Oc = Tc, Cc = Sc;\nfunction Ht(s) {\n  var i = -1, a = s == null ? 0 : s.length;\n  for (this.__data__ = new xc(); ++i < a; )\n    this.add(s[i]);\n}\nHt.prototype.add = Ht.prototype.push = Oc;\nHt.prototype.has = Cc;\nvar _c = Ht;\nfunction Mc(s, i) {\n  for (var a = -1, u = s == null ? 0 : s.length; ++a < u; )\n    if (i(s[a], a, s))\n      return !0;\n  return !1;\n}\nvar Ec = Mc;\nfunction Ic(s, i) {\n  return s.has(i);\n}\nvar Pc = Ic, Dc = _c, Rc = Ec, $c = Pc, kc = 1, zc = 2;\nfunction jc(s, i, a, u, f, v) {\n  var m = a & kc, y = s.length, x = i.length;\n  if (y != x && !(m && x > y))\n    return !1;\n  var O = v.get(s), $ = v.get(i);\n  if (O && $)\n    return O == i && $ == s;\n  var P = -1, T = !0, _ = a & zc ? new Dc() : void 0;\n  for (v.set(s, i), v.set(i, s); ++P < y; ) {\n    var M = s[P], C = i[P];\n    if (u)\n      var z = m ? u(C, M, P, i, s, v) : u(M, C, P, s, i, v);\n    if (z !== void 0) {\n      if (z)\n        continue;\n      T = !1;\n      break;\n    }\n    if (_) {\n      if (!Rc(i, function(N, G) {\n        if (!$c(_, G) && (M === N || f(M, N, a, u, v)))\n          return _.push(G);\n      })) {\n        T = !1;\n        break;\n      }\n    } else if (!(M === C || f(M, C, a, u, v))) {\n      T = !1;\n      break;\n    }\n  }\n  return v.delete(s), v.delete(i), T;\n}\nvar Ri = jc, Ac = $e, Lc = Ac.Uint8Array, Hc = Lc;\nfunction Wc(s) {\n  var i = -1, a = Array(s.size);\n  return s.forEach(function(u, f) {\n    a[++i] = [f, u];\n  }), a;\n}\nvar Fc = Wc;\nfunction Uc(s) {\n  var i = -1, a = Array(s.size);\n  return s.forEach(function(u) {\n    a[++i] = u;\n  }), a;\n}\nvar Nc = Uc, Kn = kr, Xn = Hc, Yc = Ci, Gc = Ri, Kc = Fc, Xc = Nc, Bc = 1, Vc = 2, qc = \"[object Boolean]\", Zc = \"[object Date]\", Jc = \"[object Error]\", Qc = \"[object Map]\", eu = \"[object Number]\", tu = \"[object RegExp]\", ru = \"[object Set]\", nu = \"[object String]\", iu = \"[object Symbol]\", ou = \"[object ArrayBuffer]\", su = \"[object DataView]\", Bn = Kn ? Kn.prototype : void 0, Sr = Bn ? Bn.valueOf : void 0;\nfunction au(s, i, a, u, f, v, m) {\n  switch (a) {\n    case su:\n      if (s.byteLength != i.byteLength || s.byteOffset != i.byteOffset)\n        return !1;\n      s = s.buffer, i = i.buffer;\n    case ou:\n      return !(s.byteLength != i.byteLength || !v(new Xn(s), new Xn(i)));\n    case qc:\n    case Zc:\n    case eu:\n      return Yc(+s, +i);\n    case Jc:\n      return s.name == i.name && s.message == i.message;\n    case tu:\n    case nu:\n      return s == i + \"\";\n    case Qc:\n      var y = Kc;\n    case ru:\n      var x = u & Bc;\n      if (y || (y = Xc), s.size != i.size && !x)\n        return !1;\n      var O = m.get(s);\n      if (O)\n        return O == i;\n      u |= Vc, m.set(s, i);\n      var $ = Gc(y(s), y(i), u, f, v, m);\n      return m.delete(s), $;\n    case iu:\n      if (Sr)\n        return Sr.call(s) == Sr.call(i);\n  }\n  return !1;\n}\nvar lu = au;\nfunction cu(s, i) {\n  for (var a = -1, u = i.length, f = s.length; ++a < u; )\n    s[f + a] = i[a];\n  return s;\n}\nvar uu = cu, pu = Array.isArray, jr = pu, hu = uu, du = jr;\nfunction fu(s, i, a) {\n  var u = i(s);\n  return du(s) ? u : hu(u, a(s));\n}\nvar vu = fu;\nfunction gu(s, i) {\n  for (var a = -1, u = s == null ? 0 : s.length, f = 0, v = []; ++a < u; ) {\n    var m = s[a];\n    i(m, a, s) && (v[f++] = m);\n  }\n  return v;\n}\nvar mu = gu;\nfunction bu() {\n  return [];\n}\nvar yu = bu, Tu = mu, wu = yu, Su = Object.prototype, xu = Su.propertyIsEnumerable, Vn = Object.getOwnPropertySymbols, Ou = Vn ? function(s) {\n  return s == null ? [] : (s = Object(s), Tu(Vn(s), function(i) {\n    return xu.call(s, i);\n  }));\n} : wu, Cu = Ou;\nfunction _u(s, i) {\n  for (var a = -1, u = Array(s); ++a < s; )\n    u[a] = i(a);\n  return u;\n}\nvar Mu = _u;\nfunction Eu(s) {\n  return s != null && typeof s == \"object\";\n}\nvar Vt = Eu, Iu = Kt, Pu = Vt, Du = \"[object Arguments]\";\nfunction Ru(s) {\n  return Pu(s) && Iu(s) == Du;\n}\nvar $u = Ru, qn = $u, ku = Vt, $i = Object.prototype, zu = $i.hasOwnProperty, ju = $i.propertyIsEnumerable, Au = qn(/* @__PURE__ */ function() {\n  return arguments;\n}()) ? qn : function(s) {\n  return ku(s) && zu.call(s, \"callee\") && !ju.call(s, \"callee\");\n}, Lu = Au, Wt = { exports: {} };\nfunction Hu() {\n  return !1;\n}\nvar Wu = Hu;\nWt.exports;\n(function(s, i) {\n  var a = $e, u = Wu, f = i && !i.nodeType && i, v = f && !0 && s && !s.nodeType && s, m = v && v.exports === f, y = m ? a.Buffer : void 0, x = y ? y.isBuffer : void 0, O = x || u;\n  s.exports = O;\n})(Wt, Wt.exports);\nvar ki = Wt.exports, Fu = 9007199254740991, Uu = /^(?:0|[1-9]\\d*)$/;\nfunction Nu(s, i) {\n  var a = typeof s;\n  return i = i ?? Fu, !!i && (a == \"number\" || a != \"symbol\" && Uu.test(s)) && s > -1 && s % 1 == 0 && s < i;\n}\nvar Yu = Nu, Gu = 9007199254740991;\nfunction Ku(s) {\n  return typeof s == \"number\" && s > -1 && s % 1 == 0 && s <= Gu;\n}\nvar zi = Ku, Xu = Kt, Bu = zi, Vu = Vt, qu = \"[object Arguments]\", Zu = \"[object Array]\", Ju = \"[object Boolean]\", Qu = \"[object Date]\", ep = \"[object Error]\", tp = \"[object Function]\", rp = \"[object Map]\", np = \"[object Number]\", ip = \"[object Object]\", op = \"[object RegExp]\", sp = \"[object Set]\", ap = \"[object String]\", lp = \"[object WeakMap]\", cp = \"[object ArrayBuffer]\", up = \"[object DataView]\", pp = \"[object Float32Array]\", hp = \"[object Float64Array]\", dp = \"[object Int8Array]\", fp = \"[object Int16Array]\", vp = \"[object Int32Array]\", gp = \"[object Uint8Array]\", mp = \"[object Uint8ClampedArray]\", bp = \"[object Uint16Array]\", yp = \"[object Uint32Array]\", oe = {};\noe[pp] = oe[hp] = oe[dp] = oe[fp] = oe[vp] = oe[gp] = oe[mp] = oe[bp] = oe[yp] = !0;\noe[qu] = oe[Zu] = oe[cp] = oe[Ju] = oe[up] = oe[Qu] = oe[ep] = oe[tp] = oe[rp] = oe[np] = oe[ip] = oe[op] = oe[sp] = oe[ap] = oe[lp] = !1;\nfunction Tp(s) {\n  return Vu(s) && Bu(s.length) && !!oe[Xu(s)];\n}\nvar wp = Tp;\nfunction Sp(s) {\n  return function(i) {\n    return s(i);\n  };\n}\nvar xp = Sp, Ft = { exports: {} };\nFt.exports;\n(function(s, i) {\n  var a = _i, u = i && !i.nodeType && i, f = u && !0 && s && !s.nodeType && s, v = f && f.exports === u, m = v && a.process, y = function() {\n    try {\n      var x = f && f.require && f.require(\"util\").types;\n      return x || m && m.binding && m.binding(\"util\");\n    } catch {\n    }\n  }();\n  s.exports = y;\n})(Ft, Ft.exports);\nvar Op = Ft.exports, Cp = wp, _p = xp, Zn = Op, Jn = Zn && Zn.isTypedArray, Mp = Jn ? _p(Jn) : Cp, ji = Mp, Ep = Mu, Ip = Lu, Pp = jr, Dp = ki, Rp = Yu, $p = ji, kp = Object.prototype, zp = kp.hasOwnProperty;\nfunction jp(s, i) {\n  var a = Pp(s), u = !a && Ip(s), f = !a && !u && Dp(s), v = !a && !u && !f && $p(s), m = a || u || f || v, y = m ? Ep(s.length, String) : [], x = y.length;\n  for (var O in s)\n    (i || zp.call(s, O)) && !(m && // Safari 9 has enumerable `arguments.length` in strict mode.\n    (O == \"length\" || // Node.js 0.10 has enumerable non-index properties on buffers.\n    f && (O == \"offset\" || O == \"parent\") || // PhantomJS 2 has enumerable non-index properties on typed arrays.\n    v && (O == \"buffer\" || O == \"byteLength\" || O == \"byteOffset\") || // Skip index properties.\n    Rp(O, x))) && y.push(O);\n  return y;\n}\nvar Ap = jp, Lp = Object.prototype;\nfunction Hp(s) {\n  var i = s && s.constructor, a = typeof i == \"function\" && i.prototype || Lp;\n  return s === a;\n}\nvar Wp = Hp;\nfunction Fp(s, i) {\n  return function(a) {\n    return s(i(a));\n  };\n}\nvar Up = Fp, Np = Up, Yp = Np(Object.keys, Object), Gp = Yp, Kp = Wp, Xp = Gp, Bp = Object.prototype, Vp = Bp.hasOwnProperty;\nfunction qp(s) {\n  if (!Kp(s))\n    return Xp(s);\n  var i = [];\n  for (var a in Object(s))\n    Vp.call(s, a) && a != \"constructor\" && i.push(a);\n  return i;\n}\nvar Zp = qp, Jp = Ii, Qp = zi;\nfunction eh(s) {\n  return s != null && Qp(s.length) && !Jp(s);\n}\nvar th = eh, rh = Ap, nh = Zp, ih = th;\nfunction oh(s) {\n  return ih(s) ? rh(s) : nh(s);\n}\nvar sh = oh, ah = vu, lh = Cu, ch = sh;\nfunction uh(s) {\n  return ah(s, ch, lh);\n}\nvar ph = uh, Qn = ph, hh = 1, dh = Object.prototype, fh = dh.hasOwnProperty;\nfunction vh(s, i, a, u, f, v) {\n  var m = a & hh, y = Qn(s), x = y.length, O = Qn(i), $ = O.length;\n  if (x != $ && !m)\n    return !1;\n  for (var P = x; P--; ) {\n    var T = y[P];\n    if (!(m ? T in i : fh.call(i, T)))\n      return !1;\n  }\n  var _ = v.get(s), M = v.get(i);\n  if (_ && M)\n    return _ == i && M == s;\n  var C = !0;\n  v.set(s, i), v.set(i, s);\n  for (var z = m; ++P < x; ) {\n    T = y[P];\n    var N = s[T], G = i[T];\n    if (u)\n      var Q = m ? u(G, N, T, i, s, v) : u(N, G, T, s, i, v);\n    if (!(Q === void 0 ? N === G || f(N, G, a, u, v) : Q)) {\n      C = !1;\n      break;\n    }\n    z || (z = T == \"constructor\");\n  }\n  if (C && !z) {\n    var te = s.constructor, re = i.constructor;\n    te != re && \"constructor\" in s && \"constructor\" in i && !(typeof te == \"function\" && te instanceof te && typeof re == \"function\" && re instanceof re) && (C = !1);\n  }\n  return v.delete(s), v.delete(i), C;\n}\nvar gh = vh, mh = Qe, bh = $e, yh = mh(bh, \"DataView\"), Th = yh, wh = Qe, Sh = $e, xh = wh(Sh, \"Promise\"), Oh = xh, Ch = Qe, _h = $e, Mh = Ch(_h, \"Set\"), Eh = Mh, Ih = Qe, Ph = $e, Dh = Ih(Ph, \"WeakMap\"), Rh = Dh, Or = Th, Cr = zr, _r = Oh, Mr = Eh, Er = Rh, Ai = Kt, nt = Pi, ei = \"[object Map]\", $h = \"[object Object]\", ti = \"[object Promise]\", ri = \"[object Set]\", ni = \"[object WeakMap]\", ii = \"[object DataView]\", kh = nt(Or), zh = nt(Cr), jh = nt(_r), Ah = nt(Mr), Lh = nt(Er), Ge = Ai;\n(Or && Ge(new Or(new ArrayBuffer(1))) != ii || Cr && Ge(new Cr()) != ei || _r && Ge(_r.resolve()) != ti || Mr && Ge(new Mr()) != ri || Er && Ge(new Er()) != ni) && (Ge = function(s) {\n  var i = Ai(s), a = i == $h ? s.constructor : void 0, u = a ? nt(a) : \"\";\n  if (u)\n    switch (u) {\n      case kh:\n        return ii;\n      case zh:\n        return ei;\n      case jh:\n        return ti;\n      case Ah:\n        return ri;\n      case Lh:\n        return ni;\n    }\n  return i;\n});\nvar Hh = Ge, xr = mc, Wh = Ri, Fh = lu, Uh = gh, oi = Hh, si = jr, ai = ki, Nh = ji, Yh = 1, li = \"[object Arguments]\", ci = \"[object Array]\", Dt = \"[object Object]\", Gh = Object.prototype, ui = Gh.hasOwnProperty;\nfunction Kh(s, i, a, u, f, v) {\n  var m = si(s), y = si(i), x = m ? ci : oi(s), O = y ? ci : oi(i);\n  x = x == li ? Dt : x, O = O == li ? Dt : O;\n  var $ = x == Dt, P = O == Dt, T = x == O;\n  if (T && ai(s)) {\n    if (!ai(i))\n      return !1;\n    m = !0, $ = !1;\n  }\n  if (T && !$)\n    return v || (v = new xr()), m || Nh(s) ? Wh(s, i, a, u, f, v) : Fh(s, i, x, a, u, f, v);\n  if (!(a & Yh)) {\n    var _ = $ && ui.call(s, \"__wrapped__\"), M = P && ui.call(i, \"__wrapped__\");\n    if (_ || M) {\n      var C = _ ? s.value() : s, z = M ? i.value() : i;\n      return v || (v = new xr()), f(C, z, a, u, v);\n    }\n  }\n  return T ? (v || (v = new xr()), Uh(s, i, a, u, f, v)) : !1;\n}\nvar Xh = Kh, Bh = Xh, pi = Vt;\nfunction Li(s, i, a, u, f) {\n  return s === i ? !0 : s == null || i == null || !pi(s) && !pi(i) ? s !== s && i !== i : Bh(s, i, a, u, Li, f);\n}\nvar Vh = Li, qh = Vh;\nfunction Zh(s, i) {\n  return qh(s, i);\n}\nvar Jh = Zh;\nconst Ir = /* @__PURE__ */ Ze(Jh);\nfunction J(s, i) {\n  return typeof s.get == \"function\" ? s.get(i) : s[i];\n}\nfunction hi(s) {\n  return typeof s.count == \"function\" ? s.count() : s.length;\n}\nfunction gt(s, i) {\n  return hi(s) === hi(i) && s.every((a, u) => a === J(i, u.toString()));\n}\nfunction Qh(s, i) {\n  const a = {};\n  return s.forEach((u) => {\n    a[u[i]] = u;\n  }), a;\n}\nfunction $t() {\n}\nfunction Ke(...s) {\n  return (i, ...a) => {\n    i.preventDefault(), s.forEach((u) => u && u(i, ...a));\n  };\n}\nfunction Hi({ item: s, itemContext: i, getItemProps: a, getResizeProps: u }) {\n  const { left: f, right: v } = u(), { key: m, ref: y, ...x } = a(s.itemProps ?? {}), { useResizeHandle: O } = i;\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\n    \"div\",\n    { ...x, ref: y, key: `${m}-outer` },\n    O ? (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { ...f, key: `${m}-lr` }) : null,\n    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: \"rct-item-content\", style: { maxHeight: `${i.dimensions.height}` }, children: i.title }, `${m}-content`),\n    O ? (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { ...v, key: `${m}-rr` }) : null\n  );\n}\nfunction Ut(s, i, a) {\n  return (i - s) / a;\n}\nfunction Nt(s, i, a, u) {\n  const f = a / (i - s);\n  return (u - s) * f;\n}\nfunction Ar(s, i, a, u) {\n  return (i - s) / a * u + s;\n}\nfunction Lr(s, i, a, u, f) {\n  let v = Me(s).startOf(a);\n  if (u[a] && u[a] > 1) {\n    const m = v.get(a);\n    v = v.set(a, m - m % u[a]);\n  }\n  for (; v.valueOf() < i; ) {\n    const m = Me(v).add(u[a] || 1, a).startOf(a);\n    f(v, m), v = m;\n  }\n}\nconst Pr = 17;\nfunction kt(s, i, a) {\n  const u = {\n    second: 1e3,\n    minute: 60,\n    hour: 60,\n    day: 24,\n    month: 30,\n    year: 12\n  };\n  let f = \"year\", v = s;\n  return Object.keys(u).some((m) => {\n    const y = m;\n    v = v / u[y];\n    const x = v / a[y], O = a[y] && a[y] > 1 ? 3 * Pr : Pr, $ = i / O;\n    if (x < $)\n      return f = m, !0;\n  }), f;\n}\nconst Dr = {\n  second: \"minute\",\n  minute: \"hour\",\n  hour: \"day\",\n  day: \"month\",\n  month: \"year\",\n  year: \"year\"\n};\nfunction Hr(s) {\n  if (!Dr[s])\n    throw new Error(`unit ${s} is not acceptable`);\n  return Dr[s];\n}\nfunction Wi({ itemTimeStart: s, itemTimeEnd: i, dragTime: a, isDragging: u, isResizing: f, resizingEdge: v, resizeTime: m }) {\n  const y = i - s;\n  return [\n    u && a ? a : f && v === \"left\" && m ? m : s,\n    u && a ? a + y : f && v === \"right\" && m ? m : i\n  ];\n}\nfunction Fi({ itemTimeStart: s, itemTimeEnd: i, canvasTimeStart: a, canvasTimeEnd: u, canvasWidth: f }) {\n  const v = i - s, m = Math.max(s, a), y = Math.min(i, u), x = Nt(a, u, f, m), $ = Nt(a, u, f, y) - x;\n  return {\n    left: x,\n    width: Math.max($, 3),\n    collisionLeft: s,\n    collisionWidth: v\n  };\n}\nfunction Wr(s, i) {\n  const { groupIdKey: a } = i, u = {};\n  for (let f = 0; f < s.length; f++)\n    u[J(s[f], a)] = {\n      index: f,\n      group: s[f]\n    };\n  return u;\n}\nfunction Ui(s, i) {\n  var f, v;\n  const a = {}, u = Object.keys(i);\n  for (let m = 0; m < u.length; m++) {\n    const y = i[u[m]];\n    a[m] = {\n      index: y.index,\n      group: y.group,\n      items: []\n    };\n  }\n  for (let m = 0; m < s.length; m++)\n    if (s[m].dimensions !== void 0 && ((f = s[m].dimensions) == null ? void 0 : f.order) !== void 0) {\n      const y = a[((v = s[m].dimensions) == null ? void 0 : v.order.index) ?? 0];\n      y && y.items.push(s[m]);\n    }\n  return a;\n}\nfunction Fr(s, i, a, u) {\n  const { itemTimeStartKey: f, itemTimeEndKey: v } = u;\n  return s.filter((m) => {\n    const y = Me(J(m, f)).valueOf() <= a, x = Me(J(m, v)).valueOf() >= i;\n    return y && x;\n  });\n}\nconst ed = 1e-3;\nfunction Ni(s, i, a = ed) {\n  return s.collisionLeft + a < i.collisionLeft + i.collisionWidth && s.collisionLeft + s.collisionWidth - a > i.collisionLeft && s.top - 0 + a < i.top + i.height && s.top + s.height + 0 - a > i.top;\n}\nfunction Yi(s, i, a, u, f, v) {\n  let m = u;\n  const y = (s - i.dimensions.height) / 2;\n  if (i.dimensions.stack && i.dimensions.top === null) {\n    i.dimensions.top = f + y, m = Math.max(m, s);\n    do {\n      var x = null;\n      for (let O = v - 1, $ = 0; O >= $; O--) {\n        const P = a[O];\n        if (P.dimensions.top !== null && P.dimensions.stack && Ni(i.dimensions, P.dimensions)) {\n          x = P;\n          break;\n        }\n      }\n      x != null && (i.dimensions.top = x.dimensions.top + s, m = Math.max(m, i.dimensions.top + i.dimensions.height + y - f));\n    } while (x);\n  }\n  return {\n    groupHeight: m,\n    verticalMargin: y,\n    itemTop: i.dimensions.top\n  };\n}\nfunction Gi(s, i, a, u) {\n  var v, m;\n  const f = (s - (((v = i.dimensions) == null ? void 0 : v.height) ?? 1)) / 2;\n  return i.dimensions && i.dimensions.top === null && (i.dimensions.top = u + f, a = Math.max(a, s)), { groupHeight: a, verticalMargin: 0, itemTop: ((m = i.dimensions) == null ? void 0 : m.top) ?? 0 };\n}\nfunction di(s = []) {\n  return s.reduce((i, a) => i + a, 0);\n}\nfunction Ki(s, i, a, u) {\n  const f = [], v = [], m = Ui(s, i);\n  for (const y in m) {\n    const x = m[y], { items: O, group: $ } = x, P = di(f), T = $.stackItems !== void 0 ? $.stackItems : u, { groupHeight: _ } = Xi(O, T, a, P);\n    v.push(P), $.height ? f.push($.height) : f.push(Math.max(_, a));\n  }\n  return {\n    height: di(f),\n    groupHeights: f,\n    groupTops: v\n  };\n}\nfunction Xi(s, i, a, u) {\n  let f = 0, v = 0;\n  for (let m = 0; m < s.length; m++) {\n    const y = i ? Yi(a, s[m], s, f, u, m) : Gi(a, s[m], f, u);\n    f = y.groupHeight, v = y.verticalMargin;\n  }\n  return { groupHeight: f, verticalMargin: v };\n}\nfunction qe(s, i, a, u, f, v, m, y, x, O, $, P, T, _, M) {\n  const z = Fr(s, u, f, v).map((ue) => Vi({\n    item: ue,\n    keys: v,\n    draggingItem: O,\n    resizingItem: $,\n    dragTime: P,\n    resizingEdge: T,\n    resizeTime: _,\n    groups: i,\n    newGroupOrder: M\n  }));\n  if (i.length === 0)\n    return {\n      dimensionItems: [],\n      height: 0,\n      groupHeights: [],\n      groupTops: []\n    };\n  const N = Wr(i, v), G = z.map((ue) => Bi({\n    item: ue,\n    keys: v,\n    canvasTimeStart: u,\n    canvasTimeEnd: f,\n    canvasWidth: a,\n    groupOrders: N,\n    lineHeight: m,\n    itemHeightRatio: y\n  })).filter((ue) => !!ue), { height: Q, groupHeights: te, groupTops: re } = Ki(G, N, m, x);\n  return { dimensionItems: G, height: Q, groupHeights: te, groupTops: re };\n}\nfunction Re(s, i) {\n  return s * i;\n}\nfunction Bi({ item: s, keys: i, canvasTimeStart: a, canvasTimeEnd: u, canvasWidth: f, groupOrders: v, lineHeight: m, itemHeightRatio: y }) {\n  const x = J(s, i.itemIdKey), O = Fi({\n    itemTimeStart: J(s, i.itemTimeStartKey),\n    itemTimeEnd: J(s, i.itemTimeEndKey),\n    canvasTimeStart: a,\n    canvasTimeEnd: u,\n    canvasWidth: f\n  });\n  if (O)\n    return O.top = null, O.order = v[J(s, i.itemGroupKey)], O.stack = !s.isOverlay, O.height = m * y, {\n      id: x,\n      dimensions: O\n    };\n}\nfunction Vi({ item: s, keys: i, draggingItem: a, resizingItem: u, dragTime: f, resizingEdge: v, resizeTime: m, groups: y, newGroupOrder: x }) {\n  if (!u && !a)\n    return s;\n  const O = J(s, i.itemIdKey), $ = O === a, P = O === u, [T, _] = Wi({\n    itemTimeStart: J(s, i.itemTimeStartKey),\n    itemTimeEnd: J(s, i.itemTimeEndKey),\n    isDragging: $,\n    isResizing: P,\n    dragTime: f,\n    resizingEdge: v,\n    resizeTime: m\n  });\n  return {\n    ...s,\n    [i.itemTimeStartKey]: T,\n    [i.itemTimeEndKey]: _,\n    [i.itemGroupKey]: $ ? J(y[x], i.groupIdKey) : J(s, i.itemGroupKey)\n  };\n}\nfunction Ur(s, i, a) {\n  const u = i - s, f = s - u * (a - 1) / 2, v = f + u * a;\n  return [f, v];\n}\nfunction Rr(s, i, a, u, f, v, m) {\n  const y = v.buffer, x = m.canvasTimeStart, O = m.canvasTimeEnd, $ = m.visibleTimeEnd - m.visibleTimeStart, P = i - s, T = {\n    ...m,\n    visibleTimeStart: s,\n    visibleTimeEnd: i\n  }, _ = $ * (y - 1) * 0.25;\n  if (P !== $ || s <= x + _ || i >= O - _ || a) {\n    const [C, z] = Ur(s, i, y);\n    T.canvasTimeStart = C, T.canvasTimeEnd = z;\n    const N = {\n      ...m,\n      ...T\n    }, G = Re(N.width, v.buffer);\n    Object.assign(T, qe(u, f, G, N.canvasTimeStart, N.canvasTimeEnd, v.keys, v.lineHeight, v.itemHeightRatio, v.stackItems, N.draggingItem, N.resizingItem, N.dragTime, N.resizingEdge, N.resizeTime, N.newGroupOrder));\n  }\n  return T;\n}\nconst bf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  NEXT_UNITS: Dr,\n  calculateDimensions: Fi,\n  calculateInteractionNewTimes: Wi,\n  calculateScrollCanvas: Rr,\n  calculateTimeForXPosition: Ar,\n  calculateXPositionForTime: Nt,\n  collision: Ni,\n  coordinateToTimeRatio: Ut,\n  getCanvasBoundariesFromVisibleTime: Ur,\n  getCanvasWidth: Re,\n  getGroupOrders: Wr,\n  getGroupedItems: Ui,\n  getItemDimensions: Bi,\n  getItemWithInteractions: Vi,\n  getMinUnit: kt,\n  getNextUnit: Hr,\n  getVisibleItems: Fr,\n  groupNoStack: Gi,\n  groupStack: Yi,\n  iterateTimes: Lr,\n  minCellWidth: Pr,\n  stackAll: Ki,\n  stackGroup: Xi,\n  stackTimelineItems: qe\n}, Symbol.toStringTag, { value: \"Module\" })), td = {\n  fontSize: 12,\n  color: \"white\",\n  cursor: \"pointer\",\n  background: \"#2196f3\",\n  borderTopWidth: \"1px\",\n  borderBottomWidth: \"1px\",\n  borderLeftWidth: \"1px\",\n  borderRightWidth: \"1px\",\n  borderStyle: \"solid\",\n  borderColor: \"#1a6fb3\",\n  zIndex: 80\n}, rd = {\n  background: \"#ffc107\",\n  borderTopWidth: \"1px\",\n  borderLeftWidth: \"1px\",\n  borderRightWidth: \"1px\",\n  borderBottomWidth: \"1px\",\n  borderStyle: \"solid\",\n  borderColor: \"#ff9800\",\n  zIndex: 82\n}, nd = {\n  willChange: \"left, top, width\",\n  cursor: \"move\"\n}, id = {\n  borderLeftWidth: 3\n}, od = {\n  cursor: \"w-resize\"\n}, sd = {\n  borderRightWidth: \"3px\"\n}, ad = {\n  cursor: \"e-resize\"\n}, ld = {\n  position: \"absolute\",\n  width: 24,\n  maxWidth: \"20%\",\n  minWidth: 2,\n  height: \"100%\",\n  top: 0,\n  left: 0,\n  cursor: \"pointer\",\n  zIndex: 88\n}, cd = {\n  position: \"absolute\",\n  width: 24,\n  maxWidth: \"20%\",\n  minWidth: 2,\n  height: \"100%\",\n  top: 0,\n  right: 0,\n  cursor: \"pointer\",\n  zIndex: 88\n}, ud = {\n  getTimelineState: () => (console.warn('\"getTimelineState\" default func is being used'), {}),\n  getLeftOffsetFromDate: () => (console.warn('\"getLeftOffsetFromDate\" default func is being used'), 0),\n  getDateFromLeftOffsetPosition: () => (console.warn('\"getDateFromLeftOffsetPosition\" default func is being used'), 0),\n  showPeriod: () => {\n    console.warn('\"showPeriod\" default func is being used');\n  }\n}, Nr = react__WEBPACK_IMPORTED_MODULE_1___default().createContext(ud), { Consumer: pd, Provider: hd } = Nr;\nclass dd extends (react__WEBPACK_IMPORTED_MODULE_1___default().Component) {\n  constructor(i) {\n    super(i), Object.defineProperty(this, \"getTimelineState\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: () => {\n        const { visibleTimeStart: a, visibleTimeEnd: u, canvasTimeStart: f, canvasTimeEnd: v, canvasWidth: m, timelineUnit: y, timelineWidth: x } = this.props;\n        return {\n          visibleTimeStart: a,\n          visibleTimeEnd: u,\n          canvasTimeStart: f,\n          canvasTimeEnd: v,\n          canvasWidth: m,\n          timelineUnit: y,\n          timelineWidth: x\n        };\n      }\n    }), Object.defineProperty(this, \"getLeftOffsetFromDate\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (a) => {\n        const { canvasTimeStart: u, canvasTimeEnd: f, canvasWidth: v } = this.props;\n        return Nt(u, f, v, a);\n      }\n    }), Object.defineProperty(this, \"getDateFromLeftOffsetPosition\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (a) => {\n        const { canvasTimeStart: u, canvasTimeEnd: f, canvasWidth: v } = this.props;\n        return Ar(u, f, v, a);\n      }\n    }), this.state = {\n      timelineContext: {\n        getTimelineState: this.getTimelineState,\n        getLeftOffsetFromDate: this.getLeftOffsetFromDate,\n        getDateFromLeftOffsetPosition: this.getDateFromLeftOffsetPosition,\n        showPeriod: this.props.showPeriod\n      }\n    };\n  }\n  render() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(hd, { value: this.state.timelineContext, children: this.props.children });\n  }\n}\nconst qt = pd, fd = () => (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(Nr);\nMe.extend(Cs);\nclass Yr extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n  constructor(i) {\n    super(i), Object.defineProperty(this, \"state\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: {\n        interactMounted: !1,\n        dragging: !1,\n        dragStart: null,\n        preDragPosition: null,\n        dragTime: null,\n        dragGroupDelta: null,\n        resizing: !1,\n        resizeEdge: null,\n        resizeStart: null,\n        resizeTime: null\n      }\n    }), Object.defineProperty(this, \"itemId\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"\"\n    }), Object.defineProperty(this, \"itemTitle\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"\"\n    }), Object.defineProperty(this, \"itemDivTitle\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    }), Object.defineProperty(this, \"itemTimeStart\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    }), Object.defineProperty(this, \"itemTimeEnd\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    }), Object.defineProperty(this, \"itemRef\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)()\n    }), Object.defineProperty(this, \"dragLeft\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    }), Object.defineProperty(this, \"dragRight\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    }), Object.defineProperty(this, \"startedClicking\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: !1\n    }), Object.defineProperty(this, \"startedTouching\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: !1\n    }), Object.defineProperty(this, \"dragInProgress\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: !1\n    }), Object.defineProperty(this, \"fireInteractEvent\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (a) => {\n        var u;\n        if (this.itemRef && this.itemRef.current) {\n          const f = new CustomEvent(\"itemInteraction\", {\n            bubbles: !0,\n            detail: {\n              itemInteraction: a\n            }\n          });\n          (u = this.itemRef.current) == null || u.dispatchEvent(f);\n        }\n      }\n    }), Object.defineProperty(this, \"onMouseDown\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (a) => {\n        this.state.interactMounted || (a.preventDefault(), this.startedClicking = !0);\n      }\n    }), Object.defineProperty(this, \"onMouseUp\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (a) => {\n        !this.state.interactMounted && this.startedClicking && (this.startedClicking = !1, this.actualClick(a, \"click\"));\n      }\n    }), Object.defineProperty(this, \"onTouchStart\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (a) => {\n        this.state.interactMounted || (a.preventDefault(), this.startedTouching = !0);\n      }\n    }), Object.defineProperty(this, \"onTouchEnd\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (a) => {\n        !this.state.interactMounted && this.startedTouching && (this.startedTouching = !1, this.actualClick(a, \"touch\"));\n      }\n    }), Object.defineProperty(this, \"handleDoubleClick\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (a) => {\n        a.stopPropagation(), this.props.onItemDoubleClick && this.props.onItemDoubleClick(this.itemId, a);\n      }\n    }), Object.defineProperty(this, \"handleContextMenu\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (a) => {\n        this.props.onContextMenu && (a.preventDefault(), a.stopPropagation(), this.props.onContextMenu(this.itemId, a));\n      }\n    }), Object.defineProperty(this, \"getDragLeftRef\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (a) => this.dragLeft = a\n    }), Object.defineProperty(this, \"getDragRightRef\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (a) => this.dragRight = a\n    }), Object.defineProperty(this, \"getItemProps\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (a = {}) => {\n        const u = \"rct-item\" + (this.props.item.className ? ` ${this.props.item.className}` : \"\");\n        return {\n          key: this.itemId,\n          ref: this.itemRef,\n          title: this.itemDivTitle,\n          className: u + ` ${a.className ? a.className : \"\"}`,\n          onMouseDown: Ke(this.onMouseDown, a.onMouseDown),\n          onMouseUp: Ke(this.onMouseUp, a.onMouseUp),\n          onTouchStart: Ke(this.onTouchStart, a.onTouchStart),\n          onTouchEnd: Ke(this.onTouchEnd, a.onTouchEnd),\n          onDoubleClick: Ke(this.handleDoubleClick, a.onDoubleClick),\n          onContextMenu: Ke(this.handleContextMenu, a.onContextMenu),\n          style: Object.assign({}, this.getItemStyle(a))\n        };\n      }\n    }), Object.defineProperty(this, \"getResizeProps\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (a = {}) => {\n        let u = \"rct-item-handler rct-item-handler-left rct-item-handler-resize-left\";\n        a.leftClassName && (u += ` ${a.leftClassName}`);\n        let f = \"rct-item-handler rct-item-handler-right rct-item-handler-resize-right\";\n        return a.rightClassName && (f += ` ${a.rightClassName}`), {\n          left: {\n            ref: this.getDragLeftRef,\n            className: u,\n            style: Object.assign({}, ld, a.leftStyle)\n          },\n          right: {\n            ref: this.getDragRightRef,\n            className: f,\n            style: Object.assign({}, cd, a.rightStyle)\n          }\n        };\n      }\n    }), this.cacheDataFromProps(i);\n  }\n  shouldComponentUpdate(i, a) {\n    return !Ir(this.props, i) || !Ir(this.state, a);\n  }\n  cacheDataFromProps(i) {\n    this.itemId = J(i.item, i.keys.itemIdKey), this.itemTitle = J(i.item, i.keys.itemTitleKey), this.itemDivTitle = i.keys.itemDivTitleKey ? J(i.item, i.keys.itemDivTitleKey) : this.itemTitle, this.itemTimeStart = J(i.item, i.keys.itemTimeStartKey), this.itemTimeEnd = J(i.item, i.keys.itemTimeEndKey);\n  }\n  getTimeRatio() {\n    const { canvasTimeStart: i, canvasTimeEnd: a, canvasWidth: u } = this.props;\n    return Ut(i, a, u);\n  }\n  dragTimeSnap(i, a) {\n    const { dragSnap: u } = this.props;\n    if (u) {\n      const f = a ? Me().utcOffset() * 60 * 1e3 : 0;\n      return Math.round(i / u) * u - f % u;\n    } else\n      return i;\n  }\n  resizeTimeSnap(i) {\n    const { dragSnap: a } = this.props;\n    if (a) {\n      const u = this.itemTimeEnd % a;\n      return Math.round((i - u) / a) * a + u;\n    } else\n      return i;\n  }\n  dragTime(i) {\n    const a = Me(this.itemTimeStart);\n    return this.state.dragging ? this.dragTimeSnap(this.timeFor(i) + this.state.dragStart.offset, !0) : a.valueOf();\n  }\n  timeFor(i) {\n    const a = Ut(this.props.canvasTimeStart, this.props.canvasTimeEnd, this.props.canvasWidth), u = At(this.props.scrollRef).offsetLeft, f = jt(this.props.scrollRef);\n    return (i.pageX - u + f.scrollLeft) * a + this.props.canvasTimeStart;\n  }\n  dragGroupDelta(i) {\n    const { groupTops: a, order: u } = this.props;\n    if (this.state.dragging) {\n      if (!this.props.canChangeGroup)\n        return 0;\n      let f = 0;\n      const v = At(this.props.scrollRef).offsetTop, m = jt(this.props.scrollRef);\n      for (const y of Object.keys(a)) {\n        const x = a[y];\n        if (i.pageY - v + m.scrollTop > x)\n          f = parseInt(y, 10) - u.index;\n        else\n          break;\n      }\n      return this.props.order.index + f < 0 ? 0 - this.props.order.index : f;\n    } else\n      return 0;\n  }\n  resizeTimeDelta(i, a) {\n    const u = this.itemTimeEnd - this.itemTimeStart, f = this.dragTimeSnap((i.pageX - this.state.resizeStart) * this.getTimeRatio());\n    return u + (a === \"left\" ? -f : f) < (this.props.dragSnap || 1e3) ? a === \"left\" ? u - (this.props.dragSnap || 1e3) : (this.props.dragSnap || 1e3) - u : f;\n  }\n  mountInteract() {\n    const i = this.props.useResizeHandle ? \".rct-item-handler-resize-left\" : !0, a = this.props.useResizeHandle ? \".rct-item-handler-resize-right\" : !0;\n    Tr(this.itemRef.current).resizable({\n      edges: {\n        left: this.canResizeLeft() && i,\n        right: this.canResizeRight() && a,\n        top: !1,\n        bottom: !1\n      },\n      enabled: this.props.selected && (this.canResizeLeft() || this.canResizeRight())\n    }).draggable({\n      enabled: this.props.selected && this.canMove()\n    }).styleCursor(!1).on(\"dragstart\", (u) => {\n      if (this.props.selected) {\n        this.dragInProgress = !0, this.fireInteractEvent(!0);\n        const f = this.timeFor(u);\n        this.setState({\n          dragging: !0,\n          dragStart: {\n            x: u.pageX,\n            y: u.pageY,\n            offset: this.itemTimeStart - f\n          },\n          preDragPosition: { x: u.target.offsetLeft, y: u.target.offsetTop },\n          dragTime: this.itemTimeStart,\n          dragGroupDelta: 0\n        });\n      } else\n        return !1;\n    }).on(\"dragmove\", (u) => {\n      this.state.dragging && this.setState((f) => {\n        if (!this.dragInProgress)\n          return { ...f };\n        let v = this.dragTime(u);\n        const m = this.dragGroupDelta(u);\n        return this.props.moveResizeValidator && (v = this.props.moveResizeValidator(\"move\", this.props.item, v)), this.props.onDrag && this.props.onDrag(this.itemId, v, this.props.order.index + m), {\n          dragTime: v,\n          dragGroupDelta: m\n        };\n      });\n    }).on(\"dragend\", (u) => {\n      if (this.state.dragging) {\n        if (this.props.onDrop) {\n          this.dragInProgress = !1, this.fireInteractEvent(!1);\n          let f = this.dragTime(u);\n          this.props.moveResizeValidator && (f = this.props.moveResizeValidator(\"move\", this.props.item, f)), this.props.onDrop(this.itemId, f, this.props.order.index + this.dragGroupDelta(u));\n        }\n        this.setState({\n          dragging: !1,\n          dragStart: null,\n          preDragPosition: null,\n          dragTime: null,\n          dragGroupDelta: null\n        });\n      }\n    }).on(\"resizestart\", (u) => {\n      if (this.props.selected)\n        this.fireInteractEvent(!0), this.setState({\n          resizing: !0,\n          resizeEdge: null,\n          // we don't know yet\n          resizeStart: u.pageX,\n          resizeTime: 0\n        });\n      else\n        return !1;\n    }).on(\"resizemove\", (u) => {\n      if (this.state.resizing) {\n        let f = this.state.resizeEdge;\n        f || (f = u.deltaRect.left !== 0 ? \"left\" : \"right\", this.setState({ resizeEdge: f }));\n        let v = this.resizeTimeSnap(this.timeFor(u));\n        this.props.moveResizeValidator && (v = this.props.moveResizeValidator(\"resize\", this.props.item, v, f)), this.props.onResizing && this.props.onResizing(this.itemId, v, f), this.setState({\n          resizeTime: v\n        });\n      }\n    }).on(\"resizeend\", (u) => {\n      if (this.state.resizing) {\n        this.fireInteractEvent(!1);\n        const { resizeEdge: f } = this.state;\n        let v = this.resizeTimeSnap(this.timeFor(u));\n        this.props.moveResizeValidator && (v = this.props.moveResizeValidator(\"resize\", this.props.item, v, f)), this.props.onResized && this.props.onResized(this.itemId, v, f, this.resizeTimeDelta(u, f)), this.setState({\n          resizing: !1,\n          resizeStart: null,\n          resizeEdge: null,\n          resizeTime: null\n        });\n      }\n    }).on(\"tap\", (u) => {\n      this.actualClick(u, u.pointerType === \"mouse\" ? \"click\" : \"touch\");\n    }), this.setState({\n      interactMounted: !0\n    });\n  }\n  canResizeLeft(i = this.props) {\n    var u;\n    return !i.canResizeLeft || i.minResizeWidth === void 0 ? !1 : parseInt((u = i.dimensions.width) == null ? void 0 : u.toString(), 10) >= i.minResizeWidth;\n  }\n  canResizeRight(i = this.props) {\n    var u;\n    return !i.canResizeRight || i.minResizeWidth === void 0 ? !1 : parseInt((u = i.dimensions.width) == null ? void 0 : u.toString(), 10) >= i.minResizeWidth;\n  }\n  canMove(i = this.props) {\n    return !!i.canMove;\n  }\n  componentDidUpdate(i) {\n    this.cacheDataFromProps(this.props);\n    let { interactMounted: a } = this.state;\n    const u = i.selected && this.canMove(i), f = i.selected && this.canResizeLeft(i), v = i.selected && this.canResizeRight(i), m = this.props.selected && this.canMove(this.props), y = this.props.selected && this.canResizeLeft(this.props), x = this.props.selected && this.canResizeRight(this.props);\n    if (this.itemRef && this.itemRef.current) {\n      if (this.props.selected && !a && (this.mountInteract(), a = !0), a && (f !== y || v !== x)) {\n        const O = this.props.useResizeHandle ? this.dragLeft : !0, $ = this.props.useResizeHandle ? this.dragRight : !0;\n        Tr(this.itemRef.current).resizable({\n          enabled: y || x,\n          edges: {\n            top: !1,\n            bottom: !1,\n            left: y && O,\n            right: x && $\n          }\n        });\n      }\n      a && u !== m && Tr(this.itemRef.current).draggable({ enabled: m });\n    } else\n      a = !1;\n    a !== this.state.interactMounted && this.setState({\n      interactMounted: a\n    });\n  }\n  actualClick(i, a) {\n    this.props.canSelect && this.props.onSelect && this.props.onSelect(this.itemId, a, i);\n  }\n  getItemStyle(i) {\n    const a = this.props.dimensions, u = {\n      position: \"absolute\",\n      boxSizing: \"border-box\",\n      left: `${a.left}px`,\n      top: `${a.top}px`,\n      width: `${a.width}px`,\n      height: `${a.height}px`,\n      lineHeight: `${a.height}px`\n    };\n    return Object.assign({}, td, this.props.selected ? rd : {}, this.props.selected && this.canMove(this.props) ? nd : {}, this.props.selected && this.canResizeLeft(this.props) ? id : {}, this.props.selected && this.canResizeLeft(this.props) && this.state.dragging ? od : {}, this.props.selected && this.canResizeRight(this.props) ? sd : {}, this.props.selected && this.canResizeRight(this.props) && this.state.dragging ? ad : {}, i.style, u);\n  }\n  render() {\n    if (typeof this.props.order > \"u\" || this.props.order === null)\n      return null;\n    const i = this.context, a = {\n      dimensions: this.props.dimensions,\n      useResizeHandle: !!this.props.useResizeHandle,\n      title: this.itemTitle,\n      canMove: this.canMove(this.props),\n      canResizeLeft: this.canResizeLeft(this.props),\n      canResizeRight: this.canResizeRight(this.props),\n      selected: this.props.selected,\n      dragging: this.state.dragging,\n      dragStart: this.state.dragStart,\n      dragTime: this.state.dragTime,\n      dragGroupDelta: this.state.dragGroupDelta,\n      resizing: this.state.resizing,\n      resizeEdge: this.state.resizeEdge,\n      resizeStart: this.state.resizeStart,\n      resizeTime: this.state.resizeTime\n    };\n    return this.props.itemRenderer ? this.props.itemRenderer({\n      item: this.props.item,\n      timelineContext: i,\n      itemContext: a,\n      getItemProps: this.getItemProps,\n      getResizeProps: this.getResizeProps\n    }) : Hi({\n      item: this.props.item,\n      itemContext: a,\n      getItemProps: this.getItemProps,\n      getResizeProps: this.getResizeProps\n    });\n  }\n}\nObject.defineProperty(Yr, \"defaultProps\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: {\n    selected: !1,\n    itemRenderer: Hi\n  }\n});\nObject.defineProperty(Yr, \"contextType\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: Nr\n});\nfunction vd(s, i) {\n  const a = J(s, \"canResize\") !== void 0 ? J(s, \"canResize\") : i;\n  return a === \"left\" || a === \"both\";\n}\nfunction gd(s, i) {\n  const a = J(s, \"canResize\") !== void 0 ? J(s, \"canResize\") : i;\n  return a === \"right\" || a === \"both\" || a === !0;\n}\nclass md extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n  shouldComponentUpdate(i) {\n    return !(gt(i.groups, this.props.groups) && gt(i.items, this.props.items) && gt(i.dimensionItems, this.props.dimensionItems) && i.keys === this.props.keys && i.canvasTimeStart === this.props.canvasTimeStart && i.canvasTimeEnd === this.props.canvasTimeEnd && i.canvasWidth === this.props.canvasWidth && i.selectedItem === this.props.selectedItem && i.selected === this.props.selected && i.dragSnap === this.props.dragSnap && i.minResizeWidth === this.props.minResizeWidth && i.canChangeGroup === this.props.canChangeGroup && i.canMove === this.props.canMove && i.canResize === this.props.canResize && i.canSelect === this.props.canSelect);\n  }\n  isSelected(i, a) {\n    if (this.props.selected) {\n      const u = J(i, a);\n      return this.props.selected.includes(u);\n    } else\n      return this.props.selectedItem === J(i, a);\n  }\n  getVisibleItems(i, a) {\n    const { keys: u, items: f } = this.props;\n    return Fr(f, i, a, u);\n  }\n  render() {\n    const { canvasTimeStart: i, canvasTimeEnd: a, dimensionItems: u, keys: f, groups: v } = this.props, { itemIdKey: m, itemGroupKey: y } = f, x = Wr(v, f), O = this.getVisibleItems(i, a), $ = Qh(u, \"id\");\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: \"rct-items\", children: O.filter((P) => $[J(P, m)]).map((P) => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Yr, { itemProps: P.itemProps, item: P, keys: this.props.keys, order: x[J(P, y)], dimensions: $[J(P, m)].dimensions, selected: this.isSelected(P, m), canChangeGroup: J(P, \"canChangeGroup\") !== void 0 ? J(P, \"canChangeGroup\") : this.props.canChangeGroup, canMove: J(P, \"canMove\") !== void 0 ? J(P, \"canMove\") : this.props.canMove, canResizeLeft: vd(P, this.props.canResize), canResizeRight: gd(P, this.props.canResize), canSelect: J(P, \"canSelect\") !== void 0 ? J(P, \"canSelect\") : this.props.canSelect, useResizeHandle: this.props.useResizeHandle, groupTops: this.props.groupTops, canvasTimeStart: this.props.canvasTimeStart, canvasTimeEnd: this.props.canvasTimeEnd, canvasWidth: this.props.canvasWidth, dragSnap: this.props.dragSnap, minResizeWidth: this.props.minResizeWidth, onResizing: this.props.itemResizing, onResized: this.props.itemResized, moveResizeValidator: this.props.moveResizeValidator, onDrag: this.props.itemDrag, onDrop: this.props.itemDrop, onItemDoubleClick: this.props.onItemDoubleClick, onContextMenu: this.props.onItemContextMenu, onSelect: this.props.itemSelect, itemRenderer: this.props.itemRenderer, scrollRef: this.props.scrollRef }, J(P, m))) });\n  }\n}\nclass fi extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n  shouldComponentUpdate(i) {\n    return !(i.keys === this.props.keys && i.width === this.props.width && i.height === this.props.height && gt(i.groups, this.props.groups) && gt(i.groupHeights, this.props.groupHeights));\n  }\n  renderGroupContent(i, a = !1, u, f) {\n    return this.props.groupRenderer ? react__WEBPACK_IMPORTED_MODULE_1___default().createElement(this.props.groupRenderer, {\n      group: i,\n      isRightSidebar: a\n    }) : J(i, a ? f : u);\n  }\n  render() {\n    const { width: i, groupHeights: a, height: u, isRightSidebar: f } = this.props, { groupIdKey: v, groupTitleKey: m, groupRightTitleKey: y } = this.props.keys, x = {\n      width: `${i}px`,\n      height: `${u}px`\n    }, O = {\n      width: `${i}px`\n    }, $ = this.props.groups.map((P, T) => {\n      const _ = {\n        height: `${a[T]}px`,\n        lineHeight: `${a[T]}px`\n      };\n      return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: \"rct-sidebar-row rct-sidebar-row-\" + (T % 2 === 0 ? \"even\" : \"odd\"), style: _, children: this.renderGroupContent(P, f, m, y) }, J(P, v));\n    });\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: \"rct-sidebar\" + (f ? \" rct-sidebar-right\" : \"\"), style: x, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { style: O, children: $ }) });\n  }\n}\nclass bd extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n  shouldComponentUpdate(i) {\n    return !(i.canvasTimeStart === this.props.canvasTimeStart && i.canvasTimeEnd === this.props.canvasTimeEnd && i.canvasWidth === this.props.canvasWidth && i.lineCount === this.props.lineCount && i.minUnit === this.props.minUnit && i.timeSteps === this.props.timeSteps && i.height === this.props.height && i.verticalLineClassNamesForTime === this.props.verticalLineClassNamesForTime);\n  }\n  render() {\n    const {\n      canvasTimeStart: i,\n      canvasTimeEnd: a,\n      // canvasWidth,\n      minUnit: u,\n      timeSteps: f,\n      height: v,\n      verticalLineClassNamesForTime: m,\n      getLeftOffsetFromDate: y\n    } = this.props, x = [];\n    return Lr(i, a, u, f, (O, $) => {\n      const T = O.get(u === \"day\" ? \"date\" : u) === (u === \"day\" ? 1 : 0);\n      let _ = [];\n      m && (_ = m(\n        O.unix() * 1e3,\n        // turn into ms, which is what verticalLineClassNamesForTime expects\n        $.unix() * 1e3 - 1\n      ));\n      const M = \"rct-vl\" + (T ? \" rct-vl-first\" : \"\") + (u === \"day\" || u === \"hour\" || u === \"minute\" ? ` rct-day-${O.day()} ` : \" \") + _.join(\" \"), C = y(O.valueOf()), z = y($.valueOf());\n      x.push((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: M, style: {\n        pointerEvents: \"none\",\n        top: \"0px\",\n        left: `${C}px`,\n        width: `${z - C}px`,\n        height: `${v}px`\n      } }, `line-${O.valueOf()}`));\n    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: \"rct-vertical-lines\", children: x });\n  }\n}\nconst yd = ({ ...s }) => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(qt, { children: ({ getLeftOffsetFromDate: i }) => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(bd, { getLeftOffsetFromDate: i, ...s }) });\nclass Td extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n  constructor() {\n    super(...arguments), Object.defineProperty(this, \"handleMouseDown\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (i) => {\n        this.originClickX = i.clientX;\n      }\n    }), Object.defineProperty(this, \"handleMouseUp\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (i) => {\n        this.props.clickTolerance !== void 0 && Math.abs(this.originClickX - i.clientX) > this.props.clickTolerance && (this.cancelClick = !0);\n      }\n    }), Object.defineProperty(this, \"handleClick\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (i) => {\n        this.cancelClick || this.props.onClick(i), this.cancelClick = !1, this.originClickX = null;\n      }\n    }), Object.defineProperty(this, \"originClickX\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    }), Object.defineProperty(this, \"cancelClick\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: !1\n    });\n  }\n  render() {\n    const i = react__WEBPACK_IMPORTED_MODULE_1___default().Children.only(this.props.children);\n    return react__WEBPACK_IMPORTED_MODULE_1___default().cloneElement(i, {\n      onMouseDown: this.handleMouseDown,\n      onMouseUp: this.handleMouseUp,\n      onClick: this.handleClick\n    });\n  }\n}\nclass wd extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n  render() {\n    const { onContextMenu: i, onDoubleClick: a, isEvenRow: u, style: f, onClick: v, clickTolerance: m, horizontalLineClassNamesForGroup: y, group: x } = this.props;\n    let O = [];\n    return y && (O = y(x)), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Td, { clickTolerance: m, onClick: v, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { onContextMenu: i, onDoubleClick: a, className: (u ? \"rct-hl-even \" : \"rct-hl-odd \") + (O ? O.join(\" \") : \"\"), style: f }) });\n  }\n}\nclass Sd extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n  shouldComponentUpdate(i) {\n    return !(i.canvasWidth === this.props.canvasWidth && i.lineCount === this.props.lineCount && i.groupHeights === this.props.groupHeights && i.groups === this.props.groups);\n  }\n  render() {\n    const { canvasWidth: i, lineCount: a, groupHeights: u, onRowClick: f, onRowDoubleClick: v, clickTolerance: m, groups: y, horizontalLineClassNamesForGroup: x, onRowContextClick: O } = this.props, $ = [];\n    for (let P = 0; P < a; P++)\n      $.push((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(wd, { clickTolerance: m, onContextMenu: (T) => O(T, P), onClick: (T) => f(T, P), onDoubleClick: (T) => v(T, P), isEvenRow: P % 2 === 0, group: y[P], horizontalLineClassNamesForGroup: x, style: {\n        width: `${i}px`,\n        height: `${u[P]}px`\n      } }, `horizontal-line-${P}`));\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { className: \"rct-horizontal-lines\", children: $ });\n  }\n}\nclass xd extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n  constructor(i) {\n    super(i), Object.defineProperty(this, \"scrollComponentRef\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)()\n    }), Object.defineProperty(this, \"dragLastPosition\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: null\n    }), Object.defineProperty(this, \"lastTouchDistance\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: null\n    }), Object.defineProperty(this, \"singleTouchStart\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: null\n    }), Object.defineProperty(this, \"lastSingleTouch\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: null\n    }), Object.defineProperty(this, \"isItemInteraction\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: !1\n    }), Object.defineProperty(this, \"handleScroll\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: () => {\n        const a = this.scrollComponentRef.current.scrollLeft;\n        this.props.onScroll(a);\n      }\n    }), Object.defineProperty(this, \"handleWheel\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (a) => {\n        if (a.ctrlKey || a.metaKey || a.altKey) {\n          a.preventDefault();\n          const u = Hn(a.currentTarget), f = a.clientX - u.x, v = a.ctrlKey ? 10 : a.metaKey ? 3 : 1;\n          this.props.onWheelZoom(v, f, a.deltaY);\n        } else a.shiftKey && (a.preventDefault(), this.props.onScroll(this.scrollComponentRef.current.scrollLeft + (a.deltaY || a.deltaX)));\n      }\n    }), Object.defineProperty(this, \"handleMouseDown\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (a) => {\n        a.button === 0 && (this.dragLastPosition = a.pageX, this.setState({\n          isDragging: !0\n        }));\n      }\n    }), Object.defineProperty(this, \"handleMouseMove\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (a) => {\n        this.state.isDragging && !this.isItemInteraction && (this.props.onScroll(this.scrollComponentRef.current.scrollLeft + this.dragLastPosition - a.pageX), this.dragLastPosition = a.pageX);\n      }\n    }), Object.defineProperty(this, \"handleMouseUp\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: () => {\n        this.dragLastPosition = null, this.setState({\n          isDragging: !1\n        });\n      }\n    }), Object.defineProperty(this, \"handleMouseLeave\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: () => {\n        this.dragLastPosition = null, this.setState({\n          isDragging: !1\n        });\n      }\n    }), Object.defineProperty(this, \"handleTouchStart\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (a) => {\n        if (a.touches.length === 2)\n          a.preventDefault(), this.lastTouchDistance = Math.abs(a.touches[0].screenX - a.touches[1].screenX), this.singleTouchStart = null, this.lastSingleTouch = null;\n        else if (a.touches.length === 1) {\n          a.preventDefault();\n          const u = a.touches[0].clientX, f = a.touches[0].clientY;\n          this.lastTouchDistance = null, this.singleTouchStart = { x: u, y: f, screenY: window.pageYOffset }, this.lastSingleTouch = { x: u, y: f, screenY: window.pageYOffset };\n        }\n      }\n    }), Object.defineProperty(this, \"handleTouchMove\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (a) => {\n        const { width: u, onZoom: f } = this.props;\n        if (this.isItemInteraction) {\n          a.preventDefault();\n          return;\n        }\n        if (this.lastTouchDistance && a.touches.length === 2) {\n          a.preventDefault();\n          const v = Math.abs(a.touches[0].screenX - a.touches[1].screenX), m = Hn(a.currentTarget), y = (a.touches[0].screenX + a.touches[1].screenX) / 2 - m.x;\n          v !== 0 && this.lastTouchDistance !== 0 && (f(this.lastTouchDistance / v, y / u), this.lastTouchDistance = v);\n        } else if (this.lastSingleTouch && a.touches.length === 1) {\n          a.preventDefault();\n          const v = a.touches[0].clientX, m = a.touches[0].clientY, y = v - this.lastSingleTouch.x, x = v - this.singleTouchStart.x, O = m - this.singleTouchStart.y;\n          this.lastSingleTouch = { x: v, y: m, screenY: window.pageYOffset };\n          const $ = Math.abs(x) * 3 > Math.abs(O), P = Math.abs(O) * 3 > Math.abs(x);\n          y !== 0 && $ && this.props.onScroll(this.scrollComponentRef.current.scrollLeft - y), P && window.scrollTo(window.scrollX, this.singleTouchStart.screenY - O);\n        }\n      }\n    }), Object.defineProperty(this, \"handleTouchEnd\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: () => {\n        this.lastTouchDistance && (this.lastTouchDistance = null), this.lastSingleTouch && (this.lastSingleTouch = null, this.singleTouchStart = null);\n      }\n    }), Object.defineProperty(this, \"handleItemInteract\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (a) => {\n        this.isItemInteraction = a.detail.itemInteraction;\n      }\n    }), this.state = {\n      isDragging: !1\n    };\n  }\n  componentDidMount() {\n    this.scrollComponentRef.current && (this.props.scrollRef(this.scrollComponentRef.current), this.scrollComponentRef.current.addEventListener(\"wheel\", this.handleWheel, { passive: !1 }), this.scrollComponentRef.current.addEventListener(\"itemInteraction\", this.handleItemInteract), this.scrollComponentRef.current.addEventListener(\"touchstart\", this.handleTouchStart, { passive: !1 }), this.scrollComponentRef.current.addEventListener(\"touchmove\", this.handleTouchMove, { passive: !1 }));\n  }\n  componentWillUnmount() {\n    this.scrollComponentRef.current && (this.scrollComponentRef.current.removeEventListener(\"wheel\", this.handleWheel), this.scrollComponentRef.current.removeEventListener(\"itemInteraction\", this.handleItemInteract), this.scrollComponentRef.current.removeEventListener(\"touchstart\", this.handleTouchStart), this.scrollComponentRef.current.removeEventListener(\"touchmove\", this.handleTouchMove));\n  }\n  render() {\n    const { width: i, height: a, children: u } = this.props, { isDragging: f } = this.state, v = {\n      width: `${i}px`,\n      height: `${a + 20}px`,\n      //20px to push the scroll element down off screen...?\n      cursor: f ? \"move\" : \"default\",\n      position: \"relative\"\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n      ref: this.scrollComponentRef,\n      \"data-testid\": \"scroll-element\",\n      className: \"rct-scroll\",\n      style: v,\n      onMouseDown: this.handleMouseDown,\n      onMouseMove: this.handleMouseMove,\n      onMouseUp: this.handleMouseUp,\n      onMouseLeave: this.handleMouseLeave,\n      //        onTouchStart={this.handleTouchStart}\n      //         onTouchMove={this.handleTouchMove}\n      onTouchEnd: this.handleTouchEnd,\n      onScroll: this.handleScroll,\n      children: u\n    });\n  }\n}\nconst Od = {\n  subscribeToMouseOver: () => (console.warn('\"subscribeToMouseOver\" default func is being used'), () => {\n  })\n}, { Consumer: Cd, Provider: _d } = react__WEBPACK_IMPORTED_MODULE_1___default().createContext(Od), Md = _d, Ed = Cd, Id = {\n  markers: [],\n  subscribeMarker: () => (console.warn(\"default subscribe marker used\"), {\n    unsubscribe: $t,\n    getMarker: $t\n  }),\n  updateMarker: () => (console.warn(\"default subscribe marker used\"), $t)\n}, { Consumer: Pd, Provider: Dd } = react__WEBPACK_IMPORTED_MODULE_1___default().createContext(Id);\nlet vi = 0;\nconst Rd = () => (vi += 1, vi + 1);\nclass $d extends (react__WEBPACK_IMPORTED_MODULE_1___default().Component) {\n  constructor(i) {\n    super(i), Object.defineProperty(this, \"handleSubscribeToMarker\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (a) => (a = {\n        ...a,\n        // REVIEW: in the event that we accept id to be passed to the Marker components, this line would override those\n        id: Rd()\n      }, this.setState((u) => ({\n        markers: [...u.markers, a]\n      })), {\n        unsubscribe: () => {\n          this.setState((u) => ({\n            markers: u.markers.filter((f) => f.id !== a.id)\n          }));\n        },\n        getMarker: () => a\n      })\n    }), Object.defineProperty(this, \"handleUpdateMarker\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (a) => {\n        const u = this.state.markers.findIndex((f) => f.id === a.id);\n        u < 0 || this.setState((f) => ({\n          markers: [\n            ...f.markers.slice(0, u),\n            a,\n            ...f.markers.slice(u + 1)\n          ]\n        }));\n      }\n    }), this.state = {\n      markers: [],\n      subscribeMarker: this.handleSubscribeToMarker,\n      updateMarker: this.handleUpdateMarker\n    };\n  }\n  render() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Dd, { value: this.state, children: this.props.children });\n  }\n}\nconst Zt = Pd;\nvar Fe;\n(function(s) {\n  s.Today = \"Today\", s.Custom = \"Custom\", s.Cursor = \"Cursor\";\n})(Fe || (Fe = {}));\nconst kd = {\n  position: \"absolute\",\n  top: 0,\n  bottom: 0,\n  width: \"2px\",\n  backgroundColor: \"black\",\n  // by default, pointer events (specifically click) will\n  // \"pass through\".  This is added so that CursorMarker\n  // will not get in the way of canvas click\n  pointerEvents: \"none\"\n}, Gr = (s) => ({\n  ...kd,\n  left: s\n}), Kr = (s) => function({ styles: a }) {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { style: a, \"data-testid\": s });\n}, zd = Kr(\"default-today-line\");\nlet qi = class extends (react__WEBPACK_IMPORTED_MODULE_1___default().Component) {\n  constructor() {\n    super(...arguments), Object.defineProperty(this, \"state\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: {\n        date: Date.now()\n      }\n    }), Object.defineProperty(this, \"intervalToken\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    });\n  }\n  componentDidMount() {\n    this.intervalToken = this.createIntervalUpdater(this.props.interval);\n  }\n  componentDidUpdate(i) {\n    i.interval !== this.props.interval && (clearInterval(this.intervalToken), this.intervalToken = this.createIntervalUpdater(this.props.interval));\n  }\n  createIntervalUpdater(i) {\n    return setInterval(() => {\n      this.setState({\n        date: Date.now()\n        // FIXME: use date utils pass in as props\n      });\n    }, i);\n  }\n  componentWillUnmount() {\n    clearInterval(this.intervalToken);\n  }\n  render() {\n    const { date: i } = this.state, a = this.props.getLeftOffsetFromDate(i), u = Gr(a);\n    return this.props.renderer({ styles: u, date: i });\n  }\n};\nObject.defineProperty(qi, \"defaultProps\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: {\n    renderer: zd\n  }\n});\nconst jd = Kr(\"default-customer-marker-id\");\nlet Zi = class extends (react__WEBPACK_IMPORTED_MODULE_1___default().Component) {\n  render() {\n    const { date: i } = this.props, a = this.props.getLeftOffsetFromDate(i), u = Gr(a);\n    return this.props.renderer({ styles: u, date: i });\n  }\n};\nObject.defineProperty(Zi, \"defaultProps\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: {\n    renderer: jd\n  }\n});\nconst Ad = Kr(\"default-cursor-marker\");\nlet Ji = class extends (react__WEBPACK_IMPORTED_MODULE_1___default().Component) {\n  constructor(i) {\n    super(i), Object.defineProperty(this, \"handleCanvasMouseOver\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: ({ leftOffset: a, date: u, isCursorOverCanvas: f }) => {\n        this.setState({\n          leftOffset: a,\n          date: u,\n          isShowingCursor: f\n        });\n      }\n    }), Object.defineProperty(this, \"unsubscribe\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    }), this.state = {\n      leftOffset: 0,\n      date: 0,\n      isShowingCursor: !1\n    };\n  }\n  componentDidMount() {\n    this.unsubscribe = this.props.subscribeToCanvasMouseOver(this.handleCanvasMouseOver);\n  }\n  componentWillUnmount() {\n    this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0);\n  }\n  render() {\n    const { isShowingCursor: i, leftOffset: a, date: u } = this.state;\n    if (!i)\n      return null;\n    const f = Gr(a);\n    return this.props.renderer ? this.props.renderer({ styles: f, date: u }) : null;\n  }\n};\nObject.defineProperty(Ji, \"defaultProps\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: {\n    renderer: Ad\n  }\n});\nconst Qi = (s) => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Ed, { children: ({ subscribeToMouseOver: i }) => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Ji, { subscribeToCanvasMouseOver: i, ...s }) });\nQi.displayName = \"CursorMarkerWrapper\";\nconst Ld = () => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(qt, { children: ({ getLeftOffsetFromDate: s, getTimelineState: i }) => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Zt, { children: ({ markers: a }) => {\n  const u = i();\n  return a.map((f) => {\n    switch (f.type) {\n      case Fe.Today:\n        return (/* @__PURE__ */ new Date()).valueOf() >= u.canvasTimeStart && (/* @__PURE__ */ new Date()).valueOf() <= u.canvasTimeEnd ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(qi, { getLeftOffsetFromDate: s, renderer: f.renderer, interval: f.interval }, f.id) : null;\n      case Fe.Custom:\n        return f.date >= u.canvasTimeStart && f.date <= u.canvasTimeEnd ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Zi, { renderer: f.renderer, date: f.date, getLeftOffsetFromDate: s }, f.id) : null;\n      case Fe.Cursor:\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Qi, { renderer: f.renderer, getLeftOffsetFromDate: s }, f.id);\n      default:\n        return null;\n    }\n  });\n} }) }), Hd = {\n  position: \"absolute\",\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0\n};\nclass Wd extends (react__WEBPACK_IMPORTED_MODULE_1___default().Component) {\n  constructor() {\n    super(...arguments), Object.defineProperty(this, \"handleMouseMove\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (i) => {\n        var a;\n        if (this.subscription !== null) {\n          const { pageX: u } = i, { left: f } = ((a = this.containerEl.current) == null ? void 0 : a.getBoundingClientRect()) ?? {\n            left: 0\n          }, v = u - f, m = this.props.getDateFromLeftOffsetPosition(v);\n          this.subscription({\n            leftOffset: v,\n            date: m,\n            isCursorOverCanvas: !0\n          });\n        }\n      }\n    }), Object.defineProperty(this, \"handleMouseLeave\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: () => {\n        this.subscription !== null && this.subscription({ leftOffset: 0, date: 0, isCursorOverCanvas: !1 });\n      }\n    }), Object.defineProperty(this, \"handleMouseMoveSubscribe\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (i) => (this.subscription = i, () => {\n        this.subscription = null;\n      })\n    }), Object.defineProperty(this, \"state\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: {\n        subscribeToMouseOver: this.handleMouseMoveSubscribe\n      }\n    }), Object.defineProperty(this, \"containerEl\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: react__WEBPACK_IMPORTED_MODULE_1___default().createRef()\n    }), Object.defineProperty(this, \"subscription\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: null\n    });\n  }\n  render() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Md, { value: this.state, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", { style: Hd, onMouseMove: this.handleMouseMove, onMouseLeave: this.handleMouseLeave, ref: this.containerEl, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Ld, {}), this.props.children] }) });\n  }\n}\nconst Fd = (s) => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(qt, { children: ({ getDateFromLeftOffsetPosition: i }) => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Wd, { getDateFromLeftOffsetPosition: i, ...s }) });\nfunction Ud(s) {\n  s._resizeEventListener = () => s.resize(), window.addEventListener(\"resize\", s._resizeEventListener);\n}\nfunction Nd(s) {\n  window.removeEventListener(\"resize\", s._resizeEventListener);\n}\nconst gi = { addListener: Ud, removeListener: Nd }, Yd = {\n  groupIdKey: \"id\",\n  groupTitleKey: \"title\",\n  groupRightTitleKey: \"rightTitle\",\n  groupLabelKey: \"title\",\n  itemIdKey: \"id\",\n  itemTitleKey: \"title\",\n  itemDivTitleKey: \"title\",\n  itemGroupKey: \"group\",\n  itemTimeStartKey: \"start_time\",\n  itemTimeEndKey: \"end_time\"\n}, Gd = {\n  second: 1,\n  minute: 1,\n  hour: 1,\n  day: 1,\n  month: 1,\n  year: 1\n}, Kd = {\n  year: {\n    long: \"YYYY\",\n    mediumLong: \"YYYY\",\n    medium: \"YYYY\",\n    short: \"YY\"\n  },\n  month: {\n    long: \"MMMM YYYY\",\n    mediumLong: \"MMMM\",\n    medium: \"MMMM\",\n    short: \"MM/YY\"\n  },\n  week: {\n    long: \"w\",\n    mediumLong: \"w\",\n    medium: \"w\",\n    short: \"w\"\n  },\n  day: {\n    long: \"dddd, LL\",\n    mediumLong: \"dddd, LL\",\n    medium: \"dd D\",\n    short: \"D\"\n  },\n  hour: {\n    long: \"dddd, LL, HH:00\",\n    mediumLong: \"L, HH:00\",\n    medium: \"HH:00\",\n    short: \"HH\"\n  },\n  minute: {\n    long: \"HH:mm\",\n    mediumLong: \"HH:mm\",\n    medium: \"HH:mm\",\n    short: \"mm\"\n  },\n  second: {\n    long: \"mm:ss\",\n    mediumLong: \"mm:ss\",\n    medium: \"mm:ss\",\n    short: \"ss\"\n  }\n}, Xd = {\n  registerScroll: () => (console.warn(\"default registerScroll header used\"), $t),\n  rightSidebarWidth: 0,\n  leftSidebarWidth: 150,\n  timeSteps: {}\n}, eo = react__WEBPACK_IMPORTED_MODULE_1___default().createContext(Xd);\nclass Bd extends (react__WEBPACK_IMPORTED_MODULE_1___default().Component) {\n  render() {\n    const i = {\n      rightSidebarWidth: this.props.rightSidebarWidth,\n      leftSidebarWidth: this.props.leftSidebarWidth,\n      timeSteps: this.props.timeSteps,\n      registerScroll: this.props.registerScroll\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(eo.Provider, { value: i, children: this.props.children });\n  }\n}\nconst Vd = eo, Xr = () => (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(Vd);\nvar to = { exports: {} };\n/*!\n\tCopyright (c) 2018 Jed Watson.\n\tLicensed under the MIT License (MIT), see\n\thttp://jedwatson.github.io/classnames\n*/\n(function(s) {\n  (function() {\n    var i = {}.hasOwnProperty;\n    function a() {\n      for (var v = \"\", m = 0; m < arguments.length; m++) {\n        var y = arguments[m];\n        y && (v = f(v, u(y)));\n      }\n      return v;\n    }\n    function u(v) {\n      if (typeof v == \"string\" || typeof v == \"number\")\n        return v;\n      if (typeof v != \"object\")\n        return \"\";\n      if (Array.isArray(v))\n        return a.apply(null, v);\n      if (v.toString !== Object.prototype.toString && !v.toString.toString().includes(\"[native code]\"))\n        return v.toString();\n      var m = \"\";\n      for (var y in v)\n        i.call(v, y) && v[y] && (m = f(m, y));\n      return m;\n    }\n    function f(v, m) {\n      return m ? v ? v + \" \" + m : v + m : v;\n    }\n    s.exports ? (a.default = a, s.exports = a) : window.classNames = a;\n  })();\n})(to);\nvar qd = to.exports;\nconst mi = /* @__PURE__ */ Ze(qd), Zd = \"left\", ro = \"right\";\nclass Jd extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor() {\n    super(...arguments), Object.defineProperty(this, \"getRootProps\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (i = {}) => {\n        const { style: a } = i, u = this.props.variant === ro ? this.props.rightSidebarWidth : this.props.leftSidebarWidth;\n        return {\n          style: {\n            color: (a == null ? void 0 : a.color) ?? \"#fff\",\n            ...a,\n            width: u\n          }\n        };\n      }\n    }), Object.defineProperty(this, \"getStateAndHelpers\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: () => ({\n        getRootProps: this.getRootProps,\n        data: this.props.headerData\n      })\n    });\n  }\n  render() {\n    const i = this.getStateAndHelpers();\n    return this.props.children(i);\n  }\n}\nconst Qd = ({ getRootProps: s }) => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { \"data-testid\": \"sidebarHeader\", ...s() }), zt = (s) => {\n  const { children: i, variant: a = Zd, headerData: u } = s, { leftSidebarWidth: f, rightSidebarWidth: v } = Xr();\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Jd, { leftSidebarWidth: f, rightSidebarWidth: v, variant: a, headerData: u, children: i || Qd });\n};\nzt.secretKey = \"SidebarHeader\";\nclass ef extends (react__WEBPACK_IMPORTED_MODULE_1___default().Component) {\n  constructor() {\n    super(...arguments), Object.defineProperty(this, \"getRootStyle\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: () => ({\n        ...this.props.style,\n        display: \"flex\",\n        width: \"100%\"\n      })\n    }), Object.defineProperty(this, \"getCalendarHeaderStyle\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: () => {\n        const { leftSidebarWidth: i, rightSidebarWidth: a, calendarHeaderStyle: u } = this.props;\n        return {\n          ...u,\n          overflow: \"hidden\",\n          width: `calc(100% - ${i + a}px)`\n        };\n      }\n    }), Object.defineProperty(this, \"isSidebarHeader\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (i) => i.type === void 0 ? !1 : i.type.secretKey === zt.secretKey\n    });\n  }\n  render() {\n    let i, a;\n    const u = [], f = Array.isArray(this.props.children) ? this.props.children.filter((v) => v) : [this.props.children];\n    return react__WEBPACK_IMPORTED_MODULE_1___default().Children.map(f, (v) => {\n      var m;\n      this.isSidebarHeader(v) ? ((m = v == null ? void 0 : v.props) == null ? void 0 : m.variant) === ro ? i = v : a = v : u.push(v);\n    }), a || (a = (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(zt, {})), !i && this.props.rightSidebarWidth && (i = (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(zt, { variant: \"right\" })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", { \"data-testid\": \"headerRootDiv\", style: this.getRootStyle(), className: mi(\"rct-header-root\", this.props.className), children: [a, (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ref: this.props.registerScroll, style: this.getCalendarHeaderStyle(), className: mi(\"rct-calendar-header\", this.props.calendarHeaderClassName), \"data-testid\": \"headerContainer\", children: u }), i] });\n  }\n}\nconst $r = ({ children: s, style: i, className: a, calendarHeaderStyle: u, calendarHeaderClassName: f }) => {\n  const { leftSidebarWidth: v, rightSidebarWidth: m, registerScroll: y } = Xr();\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ef, { leftSidebarWidth: v, rightSidebarWidth: m, registerScroll: y, style: i, className: a, calendarHeaderStyle: u, calendarHeaderClassName: f, children: s });\n};\n$r.secretKey = \"TimelineHeaders\";\nclass no extends (react__WEBPACK_IMPORTED_MODULE_1___default().Component) {\n  constructor(i) {\n    super(i), Object.defineProperty(this, \"getHeaderIntervals\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: ({ canvasTimeStart: x, canvasTimeEnd: O, unit: $, timeSteps: P, getLeftOffsetFromDate: T }) => {\n        const _ = [];\n        return Lr(x, O, $, P, (M, C) => {\n          const z = T(M.valueOf()), G = T(C.valueOf()) - z;\n          _.push({\n            startTime: M,\n            endTime: C,\n            labelWidth: G,\n            left: z\n          });\n        }), _;\n      }\n    }), Object.defineProperty(this, \"getRootProps\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (x = {}) => {\n        const { style: O } = x;\n        return {\n          style: Object.assign({}, O || {}, {\n            position: \"relative\",\n            width: this.props.canvasWidth,\n            height: this.props.height\n          })\n        };\n      }\n    }), Object.defineProperty(this, \"getIntervalProps\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (x = {}) => {\n        const { interval: O, style: $ } = x;\n        if (!O)\n          throw new Error(\"you should provide interval to the prop getter\");\n        const { startTime: P, labelWidth: T, left: _ } = O;\n        return {\n          style: {\n            ...$,\n            left: _,\n            width: T,\n            position: \"absolute\"\n          },\n          key: `label-${P.valueOf()}`\n        };\n      }\n    }), Object.defineProperty(this, \"getStateAndHelpers\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: () => {\n        const {\n          /*canvasTimeStart,\n          canvasTimeEnd,\n          timelineWidth,\n          visibleTimeStart,\n          visibleTimeEnd,*/\n          unit: x,\n          showPeriod: O,\n          headerData: $\n        } = this.props;\n        return {\n          /*timelineContext: {\n            timelineWidth,\n            visibleTimeStart,\n            visibleTimeEnd,\n            canvasTimeStart,\n            canvasTimeEnd,\n          },*/\n          headerContext: {\n            unit: x,\n            intervals: this.state.intervals\n          },\n          getRootProps: this.getRootProps,\n          getIntervalProps: this.getIntervalProps,\n          showPeriod: O,\n          data: $\n        };\n      }\n    });\n    const { canvasTimeStart: a, canvasTimeEnd: u, unit: f, timeSteps: v, getLeftOffsetFromDate: m } = i, y = this.getHeaderIntervals({\n      canvasTimeStart: a,\n      canvasTimeEnd: u,\n      unit: f,\n      timeSteps: v,\n      getLeftOffsetFromDate: m\n    });\n    this.state = {\n      intervals: y\n    };\n  }\n  /*shouldComponentUpdate(nextProps: CustomHeaderProps<Data>) {\n    if (\n      nextProps.canvasTimeStart !== this.props.canvasTimeStart ||\n      nextProps.canvasTimeEnd !== this.props.canvasTimeEnd ||\n      nextProps.canvasWidth !== this.props.canvasWidth ||\n      nextProps.unit !== this.props.unit ||\n      nextProps.timeSteps !== this.props.timeSteps ||\n      nextProps.showPeriod !== this.props.showPeriod ||\n      nextProps.children !== this.props.children ||\n      nextProps.headerData !== this.props.headerData\n    ) {\n      return true\n    }\n    return false\n  }*/\n  componentDidUpdate(i) {\n    if (!Ir(i, this.props)) {\n      const { canvasTimeStart: a, canvasTimeEnd: u, unit: f, timeSteps: v, getLeftOffsetFromDate: m } = this.props, y = this.getHeaderIntervals({\n        canvasTimeStart: a,\n        canvasTimeEnd: u,\n        unit: f,\n        timeSteps: v,\n        getLeftOffsetFromDate: m\n      });\n      this.setState({ intervals: y });\n    }\n  }\n  render() {\n    const i = this.getStateAndHelpers();\n    return this.props.children(i);\n  }\n}\nObject.defineProperty(no, \"defaultProps\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: {\n    height: 30\n  }\n});\nfunction tf({ children: s, unit: i, headerData: a, height: u }) {\n  const { getTimelineState: f, showPeriod: v, getLeftOffsetFromDate: m } = fd(), y = f(), { timeSteps: x } = Xr();\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(no, { children: s, timeSteps: x, showPeriod: v, unit: i || y.timelineUnit, ...y, headerData: a, getLeftOffsetFromDate: m, height: u });\n}\nvar bi = Number.isNaN || function(i) {\n  return typeof i == \"number\" && i !== i;\n};\nfunction rf(s, i) {\n  return !!(s === i || bi(s) && bi(i));\n}\nfunction nf(s, i) {\n  if (s.length !== i.length)\n    return !1;\n  for (var a = 0; a < s.length; a++)\n    if (!rf(s[a], i[a]))\n      return !1;\n  return !0;\n}\nfunction yi(s, i) {\n  i === void 0 && (i = nf);\n  var a = null;\n  function u() {\n    for (var f = [], v = 0; v < arguments.length; v++)\n      f[v] = arguments[v];\n    if (a && a.lastThis === this && i(f, a.lastArgs))\n      return a.lastResult;\n    var m = s.apply(this, f);\n    return a = {\n      lastResult: m,\n      lastArgs: f,\n      lastThis: this\n    }, m;\n  }\n  return u.clear = function() {\n    a = null;\n  }, u;\n}\nclass of extends (react__WEBPACK_IMPORTED_MODULE_1___default().PureComponent) {\n  constructor() {\n    super(...arguments), Object.defineProperty(this, \"onIntervalClick\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: () => {\n        const { primaryHeader: i, interval: a, unit: u, showPeriod: f } = this.props;\n        if (i) {\n          const v = Hr(u), m = a.startTime.clone().startOf(v), y = a.startTime.clone().endOf(v);\n          f(m, y);\n        } else\n          f(a.startTime, a.endTime);\n      }\n    }), Object.defineProperty(this, \"getIntervalProps\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (i = {}) => ({\n        ...this.props.getIntervalProps({\n          interval: this.props.interval,\n          ...i\n        }),\n        onClick: Ke(this.onIntervalClick, i.onClick)\n      })\n    });\n  }\n  render() {\n    const { intervalText: i, interval: a, intervalRenderer: u, headerData: f } = this.props, v = u;\n    if (v)\n      return v({\n        getIntervalProps: this.getIntervalProps,\n        intervalContext: {\n          interval: a,\n          intervalText: i\n        },\n        data: f\n      });\n    const { key: m, ...y } = this.getIntervalProps();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\n      \"div\",\n      { \"data-testid\": \"dateHeaderInterval\", ...y, key: m, className: `rct-dateHeader ${this.props.primaryHeader ? \"rct-dateHeader-primary\" : \"\"}` },\n      (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { children: i })\n    );\n  }\n}\nfunction sf({ headerContext: { intervals: s, unit: i }, getRootProps: a, getIntervalProps: u, showPeriod: f, data: { style: v, intervalRenderer: m, className: y, getLabelFormat: x, unitProp: O, headerData: $ } }) {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { \"data-testid\": \"dateHeader\", className: y, ...a({ style: v }), children: s.map((P) => {\n    const T = x([P.startTime, P.endTime], i, P.labelWidth);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(of, { unit: i, interval: P, showPeriod: f, intervalText: T, primaryHeader: O === \"primaryHeader\", getIntervalProps: u, intervalRenderer: m, headerData: $ }, `label-${P.startTime.valueOf()}`);\n  }) });\n}\nclass af extends (react__WEBPACK_IMPORTED_MODULE_1___default().Component) {\n  constructor() {\n    super(...arguments), Object.defineProperty(this, \"getHeaderUnit\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: () => this.props.unit === \"primaryHeader\" ? Hr(this.props.timelineUnit) : this.props.unit ? this.props.unit : this.props.timelineUnit\n    }), Object.defineProperty(this, \"getRootStyle\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: yi((i) => ({\n        height: 30,\n        ...i\n      }))\n    }), Object.defineProperty(this, \"getLabelFormat\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (i, a, u) => {\n        const { labelFormat: f } = this.props;\n        if (typeof f == \"string\")\n          return i[0].format(f);\n        if (typeof f == \"function\")\n          return f(i, a, u);\n        throw new Error(\"labelFormat should be function or string\");\n      }\n    }), Object.defineProperty(this, \"getHeaderData\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: yi((i, a, u, f, v, m) => ({\n        intervalRenderer: i,\n        style: a,\n        className: u,\n        getLabelFormat: f,\n        unitProp: v,\n        headerData: m\n      }))\n    });\n  }\n  render() {\n    const i = this.getHeaderUnit(), { height: a } = this.props;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(tf, { children: sf, unit: i, height: a, headerData: this.getHeaderData(this.props.intervalRenderer, this.getRootStyle(this.props.style), this.props.className, this.getLabelFormat, this.props.unit, this.props.headerData) });\n  }\n}\nfunction Ti({ labelFormat: s, unit: i, style: a, className: u, intervalRenderer: f, headerData: v, height: m }) {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(qt, { children: ({ getTimelineState: y }) => {\n    const x = y();\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(af, { timelineUnit: x.timelineUnit, unit: i, labelFormat: s || lf, style: a, className: u, intervalRenderer: f, headerData: v, height: m });\n  } });\n}\nconst lf = ([s], i, a = 150, u = Kd) => {\n  let f;\n  return a >= 150 ? f = u[i].long : a >= 100 ? f = u[i].mediumLong : a >= 50 ? f = u[i].medium : f = u[i].short, s.format(f);\n};\nvar io = { exports: {} };\n(function(s, i) {\n  (function(a, u) {\n    s.exports = u();\n  })(We, function() {\n    var a = { LTS: \"h:mm:ss A\", LT: \"h:mm A\", L: \"MM/DD/YYYY\", LL: \"MMMM D, YYYY\", LLL: \"MMMM D, YYYY h:mm A\", LLLL: \"dddd, MMMM D, YYYY h:mm A\" };\n    return function(u, f, v) {\n      var m = f.prototype, y = m.format;\n      v.en.formats = a, m.format = function(x) {\n        x === void 0 && (x = \"YYYY-MM-DDTHH:mm:ssZ\");\n        var O = this.$locale().formats, $ = function(P, T) {\n          return P.replace(/(\\[[^\\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(_, M, C) {\n            var z = C && C.toUpperCase();\n            return M || T[C] || a[C] || T[z].replace(/(\\[[^\\]]+])|(MMMM|MM|DD|dddd)/g, function(N, G, Q) {\n              return G || Q.slice(1);\n            });\n          });\n        }(x, O === void 0 ? {} : O);\n        return y.call(this, $);\n      };\n    };\n  });\n})(io);\nvar cf = io.exports;\nconst uf = /* @__PURE__ */ Ze(cf);\nMe.extend(uf);\nclass oo extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n  constructor(i) {\n    super(i), Object.defineProperty(this, \"getTimelineContext\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: () => {\n        const { width: T, visibleTimeStart: _, visibleTimeEnd: M, canvasTimeStart: C, canvasTimeEnd: z } = this.state, N = M - _, G = Re(T, this.props.buffer), Q = kt(N, T, this.props.timeSteps);\n        return {\n          canvasWidth: G,\n          timelineUnit: Q,\n          timelineWidth: T,\n          visibleTimeStart: _,\n          visibleTimeEnd: M,\n          canvasTimeStart: C,\n          canvasTimeEnd: z\n        };\n      }\n    }), Object.defineProperty(this, \"getTimelineUnit\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: () => {\n        const { width: T, visibleTimeStart: _, visibleTimeEnd: M } = this.state, { timeSteps: C } = this.props, z = M - _;\n        return kt(z, T, C);\n      }\n    }), Object.defineProperty(this, \"state\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    }), Object.defineProperty(this, \"scrollComponent\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: null\n    }), Object.defineProperty(this, \"scrollHeaderRef\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: null\n    }), Object.defineProperty(this, \"resize\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (T = this.props) => {\n        var re;\n        const { width: _ } = ((re = this.container.current) == null ? void 0 : re.getBoundingClientRect()) ?? { width: 0 }, M = _ - T.sidebarWidth - T.rightSidebarWidth, C = Re(M, T.buffer), { dimensionItems: z, height: N, groupHeights: G, groupTops: Q } = qe(T.items, T.groups, C, this.state.canvasTimeStart, this.state.canvasTimeEnd, T.keys, T.lineHeight, T.itemHeightRatio, T.stackItems, this.state.draggingItem, this.state.resizingItem, this.state.dragTime, this.state.resizingEdge, this.state.resizeTime, this.state.newGroupOrder);\n        this.setState({\n          width: M,\n          dimensionItems: z,\n          height: N,\n          groupHeights: G,\n          groupTops: Q\n        });\n        const te = M * ((T.buffer - 1) / 2);\n        this.scrollComponent && (this.scrollComponent.scrollLeft = te), this.scrollHeaderRef && (this.scrollHeaderRef.scrollLeft = te);\n      }\n    }), Object.defineProperty(this, \"onScroll\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (T) => {\n        var N, G;\n        const _ = this.state.width, M = this.state.canvasTimeStart, C = this.state.visibleTimeEnd - this.state.visibleTimeStart, z = M + C * T / _;\n        (this.state.visibleTimeStart !== z || this.state.visibleTimeEnd !== z + C) && ((G = (N = this.props).onTimeChange) == null || G.call(N, z, z + C, this.updateScrollCanvas, this.getTimelineUnit()));\n      }\n    }), Object.defineProperty(this, \"updateScrollCanvas\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (T, _, M = !1, C = this.props.items, z = this.props.groups) => {\n        this.setState(Rr(T, _, M, C, z, this.props, this.state));\n      }\n    }), Object.defineProperty(this, \"handleWheelZoom\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (T, _, M) => {\n        this.changeZoom(1 + T * M / 500, _ / this.state.width);\n      }\n    }), Object.defineProperty(this, \"changeZoom\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (T, _ = 0.5) => {\n        const { minZoom: M, maxZoom: C } = this.props, z = this.state.visibleTimeEnd - this.state.visibleTimeStart, N = Math.min(Math.max(Math.round(z * T), M), C), G = Math.round(this.state.visibleTimeStart + (z - N) * _);\n        this.props.onTimeChange && this.props.onTimeChange(G, G + N, this.updateScrollCanvas, this.getTimelineUnit());\n      }\n    }), Object.defineProperty(this, \"showPeriod\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (T, _) => {\n        var N, G;\n        const M = T.valueOf(), z = _.valueOf() - M;\n        z < this.props.minZoom || (G = (N = this.props).onTimeChange) == null || G.call(N, M, M + z, this.updateScrollCanvas, this.getTimelineUnit());\n      }\n    }), Object.defineProperty(this, \"selectItem\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (T, _, M) => {\n        if (this.isItemSelected(T) || this.props.itemTouchSendsClick && _ === \"touch\") {\n          if (T && this.props.onItemClick) {\n            const C = this.timeFromItemEvent(M);\n            this.props.onItemClick(T, M, C);\n          }\n        } else if (this.setState({ selectedItem: T }), T && this.props.onItemSelect) {\n          const C = this.timeFromItemEvent(M);\n          this.props.onItemSelect(T, M, C);\n        } else T === null && this.props.onItemDeselect && this.props.onItemDeselect(M);\n      }\n    }), Object.defineProperty(this, \"doubleClickItem\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (T, _) => {\n        if (this.props.onItemDoubleClick) {\n          const M = this.timeFromItemEvent(_);\n          this.props.onItemDoubleClick(T, _, M);\n        }\n      }\n    }), Object.defineProperty(this, \"contextMenuClickItem\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (T, _) => {\n        if (this.props.onItemContextMenu) {\n          const M = this.timeFromItemEvent(_);\n          this.props.onItemContextMenu(T, _, M);\n        }\n      }\n    }), Object.defineProperty(this, \"getTimeFromRowClickEvent\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (T) => {\n        const { dragSnap: _, buffer: M } = this.props, { width: C, canvasTimeStart: z, canvasTimeEnd: N } = this.state, { offsetX: G } = T.nativeEvent;\n        let Q = Ar(z, N, Re(C, M), G);\n        return Q = Math.floor(Q / _) * _, Q;\n      }\n    }), Object.defineProperty(this, \"timeFromItemEvent\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (T) => {\n        const { width: _, visibleTimeStart: M, visibleTimeEnd: C } = this.state, z = this.props.dragSnap, N = this.scrollComponent, { left: G } = N.getBoundingClientRect(), te = (T.clientX - G) / _, re = C - M, ue = te * re;\n        let S = Math.round(M + ue);\n        return S = Math.floor(S / z) * z, S;\n      }\n    }), Object.defineProperty(this, \"dragItem\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (T, _, M) => {\n        const C = this.props.groups[M], z = this.props.keys;\n        this.setState({\n          draggingItem: T,\n          dragTime: _,\n          newGroupOrder: M,\n          dragGroupTitle: C ? J(C, z.groupLabelKey) : \"\"\n        }), this.updatingItem({\n          eventType: \"move\",\n          itemId: T,\n          time: _,\n          newGroupOrder: M\n        });\n      }\n    }), Object.defineProperty(this, \"dropItem\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (T, _, M) => {\n        this.setState({ draggingItem: null, dragTime: null, dragGroupTitle: null }), this.props.onItemMove && this.props.onItemMove(T, _, M);\n      }\n    }), Object.defineProperty(this, \"resizingItem\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (T, _, M) => {\n        this.setState({\n          resizingItem: T,\n          resizingEdge: M,\n          resizeTime: _\n        }), this.updatingItem({\n          eventType: \"resize\",\n          itemId: T,\n          time: _,\n          edge: M || void 0\n        });\n      }\n    }), Object.defineProperty(this, \"resizedItem\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (T, _, M, C) => {\n        this.setState({ resizingItem: null, resizingEdge: null, resizeTime: null }), this.props.onItemResize && C !== 0 && this.props.onItemResize(T, _, M);\n      }\n    }), Object.defineProperty(this, \"updatingItem\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: ({ eventType: T, itemId: _, time: M, edge: C, newGroupOrder: z }) => {\n        this.props.onItemDrag && (T === \"move\" ? this.props.onItemDrag({\n          eventType: T,\n          itemId: _,\n          time: M,\n          newGroupOrder: z\n        }) : this.props.onItemDrag({\n          eventType: T,\n          itemId: _,\n          time: M,\n          edge: C\n        }));\n      }\n    }), Object.defineProperty(this, \"handleRowClick\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (T, _) => {\n        if (this.hasSelectedItem() && this.selectItem(null, \"click\", T), this.props.onCanvasClick == null)\n          return;\n        const M = this.getTimeFromRowClickEvent(T), C = J(this.props.groups[_], this.props.keys.groupIdKey);\n        this.props.onCanvasClick(C, M, T);\n      }\n    }), Object.defineProperty(this, \"handleRowDoubleClick\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (T, _) => {\n        if (this.props.onCanvasDoubleClick == null)\n          return;\n        const M = this.getTimeFromRowClickEvent(T), C = J(this.props.groups[_], this.props.keys.groupIdKey);\n        this.props.onCanvasDoubleClick(C, M, T);\n      }\n    }), Object.defineProperty(this, \"handleScrollContextMenu\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (T, _) => {\n        if (this.props.onCanvasContextMenu == null)\n          return;\n        const M = this.getTimeFromRowClickEvent(T), C = J(this.props.groups[_], this.props.keys.groupIdKey);\n        this.props.onCanvasContextMenu && (T.preventDefault(), this.props.onCanvasContextMenu(C, M, T));\n      }\n    }), Object.defineProperty(this, \"handleHeaderRef\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (T) => {\n        this.scrollHeaderRef = T, this.props.headerRef && this.props.headerRef(T);\n      }\n    }), Object.defineProperty(this, \"isTimelineHeader\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (T) => T.type === void 0 ? !1 : T.type.secretKey === $r.secretKey\n    }), Object.defineProperty(this, \"renderHeaders\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: () => {\n        if (this.props.children) {\n          let T;\n          if (react__WEBPACK_IMPORTED_MODULE_1___default().Children.map(this.props.children, (_) => {\n            this.isTimelineHeader(_) && (T = _);\n          }), T)\n            return T;\n        }\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)($r, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Ti, { unit: \"primaryHeader\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Ti, {})] });\n      }\n    }), Object.defineProperty(this, \"getScrollElementRef\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (T) => {\n        this.props.scrollRef && this.props.scrollRef(T), this.scrollComponent = T;\n      }\n    }), Object.defineProperty(this, \"container\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: react__WEBPACK_IMPORTED_MODULE_1___default().createRef()\n    }), Object.defineProperty(this, \"getBoundingClientRect\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: () => this.scrollComponent.getBoundingClientRect()\n    }), Object.defineProperty(this, \"calculateDropCoordinatesToTimeAndGroup\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: (T, _) => {\n        const M = Re(this.state.width, this.props.buffer), C = Ut(this.state.canvasTimeStart, this.state.canvasTimeEnd, M), z = At(this.scrollComponent).offsetLeft, N = jt(this.scrollComponent), G = (T - z + N.scrollLeft) * C + this.state.canvasTimeStart;\n        let Q = 0;\n        for (const re of this.state.groupTops)\n          if (_ > Number(re))\n            Q = this.state.groupTops.indexOf(re);\n          else\n            break;\n        if (!this.props.dragSnap)\n          return { time: G, groupIndex: Q };\n        const te = Me().utcOffset() * 60 * 1e3;\n        return {\n          time: Math.round(G / this.props.dragSnap) * this.props.dragSnap - te % this.props.dragSnap,\n          groupIndex: Q\n        };\n      }\n    }), this.getSelected = this.getSelected.bind(this), this.hasSelectedItem = this.hasSelectedItem.bind(this), this.isItemSelected = this.isItemSelected.bind(this);\n    let a = null, u = null;\n    if (this.props.defaultTimeStart && this.props.defaultTimeEnd)\n      a = this.props.defaultTimeStart, u = this.props.defaultTimeEnd;\n    else if (this.props.visibleTimeStart && this.props.visibleTimeEnd)\n      a = this.props.visibleTimeStart, u = this.props.visibleTimeEnd;\n    else\n      throw new Error('You must provide either \"defaultTimeStart\" and \"defaultTimeEnd\" or \"visibleTimeStart\" and \"visibleTimeEnd\" to initialize the Timeline');\n    const [f, v] = Ur(a, u, i.buffer), m = {\n      width: 1e3,\n      visibleTimeStart: a,\n      visibleTimeEnd: u,\n      canvasTimeStart: f,\n      canvasTimeEnd: v,\n      selectedItem: null,\n      dragTime: null,\n      dragGroupTitle: null,\n      resizeTime: null,\n      resizingItem: null,\n      resizingEdge: null,\n      newGroupOrder: 0\n      //CHECK\n    }, y = Re(m.width, i.buffer), { dimensionItems: x, height: O, groupHeights: $, groupTops: P } = qe(i.items, i.groups, y, m.canvasTimeStart, m.canvasTimeEnd, i.keys, i.lineHeight, i.itemHeightRatio, i.stackItems, m.draggingItem, m.resizingItem, m.dragTime, m.resizingEdge, m.resizeTime, m.newGroupOrder);\n    m.dimensionItems = x, m.height = O, m.groupHeights = $, m.groupTops = P, this.state = m;\n  }\n  componentDidMount() {\n    this.resize(this.props), this.props.resizeDetector && this.props.resizeDetector.addListener && this.props.resizeDetector.addListener(this), gi.addListener(this);\n  }\n  componentWillUnmount() {\n    this.props.resizeDetector && this.props.resizeDetector.addListener && this.props.resizeDetector.removeListener(this), gi.removeListener(this);\n  }\n  static getDerivedStateFromProps(i, a) {\n    const { visibleTimeStart: u, visibleTimeEnd: f, items: v, groups: m } = i, y = { items: v, groups: m }, x = v !== a.items || m !== a.groups;\n    if (u && f)\n      Object.assign(y, Rr(u, f, x, v, m, i, a));\n    else if (x) {\n      const O = Re(a.width, i.buffer);\n      Object.assign(y, qe(v, m, O, a.canvasTimeStart, a.canvasTimeEnd, i.keys, i.lineHeight, i.itemHeightRatio, i.stackItems, a.draggingItem, a.resizingItem, a.dragTime, a.resizingEdge, a.resizeTime, a.newGroupOrder));\n    }\n    return y;\n  }\n  componentDidUpdate(i, a) {\n    const u = this.state.visibleTimeEnd - this.state.visibleTimeStart, f = a.visibleTimeEnd - a.visibleTimeStart;\n    this.props.onZoom && u !== f && this.props.onZoom(this.getTimelineContext(), this.getTimelineUnit()), this.props.onBoundsChange && this.state.canvasTimeStart !== a.canvasTimeStart && this.props.onBoundsChange(this.state.canvasTimeStart, this.state.canvasTimeStart + u * 3);\n    const v = Math.round(this.state.width * (this.state.visibleTimeStart - this.state.canvasTimeStart) / u);\n    (Math.round(a.width * (a.visibleTimeStart - a.canvasTimeStart) / f) !== v || this.scrollComponent.scrollLeft !== v) && (this.scrollComponent.scrollLeft = v, this.scrollHeaderRef.scrollLeft = v);\n  }\n  columns(i, a, u, f, v, m) {\n    var y;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(yd, { canvasTimeStart: i, canvasTimeEnd: a, canvasWidth: u, lineCount: ((y = this.props.groups) == null ? void 0 : y.length) || 0, minUnit: f, timeSteps: v, height: m, verticalLineClassNamesForTime: this.props.verticalLineClassNamesForTime });\n  }\n  rows(i, a, u) {\n    var f;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Sd, { groups: u, canvasWidth: i, lineCount: ((f = this.props.groups) == null ? void 0 : f.length) || 0, groupHeights: a, clickTolerance: this.props.clickTolerance, onRowClick: this.handleRowClick, onRowDoubleClick: this.handleRowDoubleClick, horizontalLineClassNamesForGroup: this.props.horizontalLineClassNamesForGroup, onRowContextClick: this.handleScrollContextMenu });\n  }\n  items({ canvasTimeStart: i, canvasTimeEnd: a, canvasWidth: u, dimensionItems: f, groupTops: v }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(md, { canvasTimeStart: i, canvasTimeEnd: a, canvasWidth: u, dimensionItems: f, groupTops: v, items: this.props.items, groups: this.props.groups, keys: this.props.keys, selectedItem: this.state.selectedItem || void 0, dragSnap: this.props.dragSnap, minResizeWidth: this.props.minResizeWidth, canChangeGroup: this.props.canChangeGroup, canMove: this.props.canMove, canResize: this.props.canResize, useResizeHandle: this.props.useResizeHandle, canSelect: this.props.canSelect, moveResizeValidator: this.props.moveResizeValidator, itemSelect: this.selectItem, itemDrag: this.dragItem, itemDrop: this.dropItem, onItemDoubleClick: this.doubleClickItem, onItemContextMenu: this.props.onItemContextMenu ? this.contextMenuClickItem : void 0, itemResizing: this.resizingItem, itemResized: this.resizedItem, itemRenderer: this.props.itemRenderer, selected: this.props.selected, scrollRef: this.scrollComponent });\n  }\n  sidebar(i, a) {\n    const { sidebarWidth: u } = this.props;\n    return u && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(fi, { groups: this.props.groups, groupRenderer: this.props.groupRenderer, keys: this.props.keys, width: u, groupHeights: a, height: i });\n  }\n  rightSidebar(i, a) {\n    const { rightSidebarWidth: u } = this.props;\n    return u && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(fi, { groups: this.props.groups, keys: this.props.keys, groupRenderer: this.props.groupRenderer, isRightSidebar: !0, width: u, groupHeights: a, height: i });\n  }\n  childrenWithProps(i, a, u, f, v, m, y, x, O, $, P) {\n    if (!this.props.children)\n      return null;\n    const T = Array.isArray(this.props.children) ? this.props.children.filter((M) => M) : [this.props.children], _ = {\n      canvasTimeStart: i,\n      canvasTimeEnd: a,\n      canvasWidth: u,\n      visibleTimeStart: x,\n      visibleTimeEnd: O,\n      dimensionItems: f,\n      items: this.props.items,\n      groups: this.props.groups,\n      keys: this.props.keys,\n      groupHeights: v,\n      groupTops: m,\n      selected: this.getSelected(),\n      height: y,\n      minUnit: $,\n      timeSteps: P\n    };\n    return react__WEBPACK_IMPORTED_MODULE_1___default().Children.map(T, (M) => this.isTimelineHeader(M) ? null : react__WEBPACK_IMPORTED_MODULE_1___default().cloneElement(M, _));\n  }\n  getSelected() {\n    return this.state.selectedItem && !this.props.selected ? [this.state.selectedItem] : this.props.selected || [];\n  }\n  hasSelectedItem() {\n    return Array.isArray(this.props.selected) ? this.props.selected.length > 0 : !!this.state.selectedItem;\n  }\n  isItemSelected(i) {\n    return this.getSelected().some((u) => u === i);\n  }\n  render() {\n    const { items: i, groups: a, sidebarWidth: u, rightSidebarWidth: f, timeSteps: v, traditionalZoom: m, buffer: y } = this.props, { draggingItem: x, resizingItem: O, width: $, visibleTimeStart: P, visibleTimeEnd: T, canvasTimeStart: _, canvasTimeEnd: M } = this.state;\n    let { dimensionItems: C, height: z, groupHeights: N, groupTops: G } = this.state;\n    const Q = T - P, te = Re($, y), re = kt(Q, $, v);\n    if (!!x || !!O) {\n      const be = qe(i, a, te, this.state.canvasTimeStart, this.state.canvasTimeEnd, this.props.keys, this.props.lineHeight, this.props.itemHeightRatio, this.props.stackItems, this.state.draggingItem, this.state.resizingItem, this.state.dragTime, this.state.resizingEdge, this.state.resizeTime, this.state.newGroupOrder);\n      C = be.dimensionItems, z = be.height, N = be.groupHeights, G = be.groupTops;\n    }\n    const S = {\n      height: `${z}px`\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(dd, { visibleTimeStart: P, visibleTimeEnd: T, canvasTimeStart: _, canvasTimeEnd: M, canvasWidth: te, showPeriod: this.showPeriod, timelineUnit: re, timelineWidth: this.state.width, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)($d, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Bd, { registerScroll: this.handleHeaderRef, timeSteps: v, leftSidebarWidth: this.props.sidebarWidth, rightSidebarWidth: this.props.rightSidebarWidth, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", { style: this.props.style, ref: this.container, className: `react-calendar-timeline ${this.props.className}`, children: [this.renderHeaders(), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", { style: S, className: \"rct-outer\", children: [u > 0 ? this.sidebar(z, N) : null, (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(xd, { scrollRef: this.getScrollElementRef, width: $, height: z, onZoom: this.changeZoom, onWheelZoom: this.handleWheelZoom, traditionalZoom: !!m, onScroll: this.onScroll, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Fd, { children: [this.columns(_, M, te, re, v, z), this.rows(te, N, a), this.items({\n      canvasTimeStart: _,\n      canvasTimeEnd: M,\n      canvasWidth: te,\n      dimensionItems: C,\n      groupTops: G\n    }), this.childrenWithProps(_, M, te, C, N, G, z, P, T, re, v)] }) }), f > 0 ? this.rightSidebar(z, N) : null] })] }) }) }) });\n  }\n}\nObject.defineProperty(oo, \"setDayjsLocale\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: Me.locale\n});\nObject.defineProperty(oo, \"defaultProps\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: {\n    sidebarWidth: 150,\n    rightSidebarWidth: 0,\n    dragSnap: 1e3 * 60 * 15,\n    // 15min\n    minResizeWidth: 20,\n    lineHeight: 30,\n    itemHeightRatio: 0.65,\n    buffer: 3,\n    minZoom: 60 * 60 * 1e3,\n    // 1 hour\n    maxZoom: 5 * 365.24 * 86400 * 1e3,\n    // 5 years\n    clickTolerance: 3,\n    // how many pixels can we drag for it to be still considered a click?\n    canChangeGroup: !0,\n    canMove: !0,\n    canResize: \"right\",\n    useResizeHandle: !1,\n    canSelect: !0,\n    stackItems: !1,\n    traditionalZoom: !1,\n    horizontalLineClassNamesForGroup: null,\n    onItemMove: null,\n    onItemResize: null,\n    onItemClick: null,\n    onItemSelect: null,\n    onItemDeselect: null,\n    onItemDrag: null,\n    onCanvasClick: null,\n    onItemDoubleClick: null,\n    onItemContextMenu: null,\n    onZoom: null,\n    verticalLineClassNamesForTime: null,\n    moveResizeValidator: null,\n    dayBackground: null,\n    defaultTimeStart: null,\n    defaultTimeEnd: null,\n    itemTouchSendsClick: !1,\n    style: {},\n    className: \"\",\n    keys: Yd,\n    timeSteps: Gd,\n    headerRef: () => {\n    },\n    scrollRef: () => {\n    },\n    // if you pass in visibleTimeStart and visibleTimeEnd, you must also pass onTimeChange(visibleTimeStart, visibleTimeEnd),\n    // which needs to update the props visibleTimeStart and visibleTimeEnd to the ones passed\n    visibleTimeStart: null,\n    visibleTimeEnd: null,\n    onTimeChange: function(s, i, a) {\n      a(s, i);\n    },\n    // called when the canvas area of the calendar changes\n    onBoundsChange: null,\n    children: null,\n    selected: null\n  }\n});\nconst Sf = (s) => s.children || null;\nclass so extends (react__WEBPACK_IMPORTED_MODULE_1___default().Component) {\n  constructor() {\n    super(...arguments), Object.defineProperty(this, \"unsubscribe\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: null\n    }), Object.defineProperty(this, \"getMarker\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: null\n    });\n  }\n  componentDidMount() {\n    const { unsubscribe: i, getMarker: a } = this.props.subscribeMarker({\n      type: Fe.Today,\n      renderer: this.props.children,\n      interval: this.props.interval\n    });\n    this.unsubscribe = i, this.getMarker = a;\n  }\n  componentWillUnmount() {\n    this.unsubscribe != null && (this.unsubscribe(), this.unsubscribe = null);\n  }\n  componentDidUpdate(i) {\n    if (i.interval !== this.props.interval && this.getMarker) {\n      const a = this.getMarker();\n      this.props.updateMarker({\n        ...a,\n        interval: this.props.interval\n      });\n    }\n  }\n  render() {\n    return null;\n  }\n}\nObject.defineProperty(so, \"defaultProps\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: {\n    interval: 1e3 * 10\n    // default to ten seconds\n  }\n});\nconst pf = (s) => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Zt, { children: ({ subscribeMarker: i, updateMarker: a }) => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(so, { subscribeMarker: i, updateMarker: a, ...s }) });\npf.displayName = \"TodayMarkerWrapper\";\nclass hf extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n  constructor() {\n    super(...arguments), Object.defineProperty(this, \"unsubscribe\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: null\n    }), Object.defineProperty(this, \"getMarker\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: null\n    });\n  }\n  componentDidUpdate(i) {\n    if (i.date !== this.props.date && this.getMarker) {\n      const a = this.getMarker();\n      this.props.updateMarker({ ...a, date: this.props.date });\n    }\n  }\n  componentDidMount() {\n    const { unsubscribe: i, getMarker: a } = this.props.subscribeMarker({\n      type: Fe.Custom,\n      renderer: this.props.children,\n      date: this.props.date\n    });\n    this.unsubscribe = i, this.getMarker = a;\n  }\n  componentWillUnmount() {\n    this.unsubscribe != null && (this.unsubscribe(), this.unsubscribe = null);\n  }\n  render() {\n    return null;\n  }\n}\nconst df = (s) => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Zt, { children: ({ subscribeMarker: i, updateMarker: a }) => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(hf, { subscribeMarker: i, updateMarker: a, ...s }) });\ndf.displayName = \"CustomMarkerWrapper\";\nclass ff extends react__WEBPACK_IMPORTED_MODULE_1__.Component {\n  constructor() {\n    super(...arguments), Object.defineProperty(this, \"unsubscribe\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: null\n    });\n  }\n  componentDidMount() {\n    const { unsubscribe: i } = this.props.subscribeMarker({\n      type: Fe.Cursor,\n      renderer: this.props.children\n    });\n    this.unsubscribe = i;\n  }\n  componentWillUnmount() {\n    this.unsubscribe != null && (this.unsubscribe(), this.unsubscribe = null);\n  }\n  render() {\n    return null;\n  }\n}\nconst vf = (s) => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Zt, { children: ({ subscribeMarker: i }) => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ff, { subscribeMarker: i, ...s }) });\nvf.displayName = \"CursorMarkerWrapper\";\n\n//# sourceMappingURL=react-calendar-timeline.es.js.map\n\n\n//# sourceURL=webpack://dash_calendar_timeline/./node_modules/react-calendar-timeline/dist/react-calendar-timeline.es.js?\n}");

/***/ }),

/***/ "./node_modules/react-calendar-timeline/dist/style.css":
/*!*************************************************************!*\
  !*** ./node_modules/react-calendar-timeline/dist/style.css ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !!../../css-loader/dist/cjs.js!./style.css */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/react-calendar-timeline/dist/style.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_4___default());\noptions.setAttributes = (_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_2___default());\noptions.insert = function insertAtTop(element) {\n                                    var parent = document.querySelector(\"head\");\n                                    var lastInsertedElement =\n                                        window._lastElementInsertedByStyleLoader;\n\n                                    if (!lastInsertedElement) {\n                                        parent.insertBefore(element, parent.firstChild);\n                                    } else if (lastInsertedElement.nextSibling) {\n                                        parent.insertBefore(element, lastInsertedElement.nextSibling);\n                                    } else {\n                                        parent.appendChild(element);\n                                    }\n\n                                    window._lastElementInsertedByStyleLoader = element;\n                                };\noptions.domAPI = (_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3___default());\n\nvar update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_5__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_5__[\"default\"] && _css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_5__[\"default\"].locals ? _css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_5__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://dash_calendar_timeline/./node_modules/react-calendar-timeline/dist/style.css?\n}");

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-runtime.development.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-runtime.development.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! react */ \"react\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_MODULE_REFERENCE;\n\n{\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n}\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      // eslint-disable-next-line no-fallthrough\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if ( !fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n    return type;\n  }\n} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner$1.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object') {\n      return;\n    }\n\n    if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else if (node) {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\n\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n// even with the prod transform. This means that jsxDEV is purely\n// opt-in behavior for better messages but that we won't stop\n// giving you warnings if you use production apis.\n\nfunction jsxWithValidationStatic(type, props, key) {\n  {\n    return jsxWithValidation(type, props, key, true);\n  }\n}\nfunction jsxWithValidationDynamic(type, props, key) {\n  {\n    return jsxWithValidation(type, props, key, false);\n  }\n}\n\nvar jsx =  jsxWithValidationDynamic ; // we may want to special case jsxs internally to take advantage of static children.\n// for now we can ship identical prod functions\n\nvar jsxs =  jsxWithValidationStatic ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsx = jsx;\nexports.jsxs = jsxs;\n  })();\n}\n\n\n//# sourceURL=webpack://dash_calendar_timeline/./node_modules/react/cjs/react-jsx-runtime.development.js?\n}");

/***/ }),

/***/ "./node_modules/react/jsx-runtime.js":
/*!*******************************************!*\
  !*** ./node_modules/react/jsx-runtime.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{\n\nif (false) // removed by dead control flow\n{} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ \"./node_modules/react/cjs/react-jsx-runtime.development.js\");\n}\n\n\n//# sourceURL=webpack://dash_calendar_timeline/./node_modules/react/jsx-runtime.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("{\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://dash_calendar_timeline/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("{\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://dash_calendar_timeline/./node_modules/style-loader/dist/runtime/insertStyleElement.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://dash_calendar_timeline/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("{\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://dash_calendar_timeline/./node_modules/style-loader/dist/runtime/styleDomAPI.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("{\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://dash_calendar_timeline/./node_modules/style-loader/dist/runtime/styleTagTransform.js?\n}");

/***/ }),

/***/ "./src/ts/components/DashCalendarTimeline.tsx":
/*!****************************************************!*\
  !*** ./src/ts/components/DashCalendarTimeline.tsx ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("{\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\nvar react_calendar_timeline_1 = __importDefault(__webpack_require__(/*! react-calendar-timeline */ \"./node_modules/react-calendar-timeline/dist/react-calendar-timeline.es.js\"));\n__webpack_require__(/*! react-calendar-timeline/dist/style.css */ \"./node_modules/react-calendar-timeline/dist/style.css\");\n__webpack_require__(/*! ../styles/selected-item.css */ \"./src/ts/styles/selected-item.css\");\n__webpack_require__(/*! ../styles/base.css */ \"./src/ts/styles/base.css\");\nvar SelectedItemInfo_1 = __webpack_require__(/*! ../internal/components/SelectedItemInfo */ \"./src/ts/internal/components/SelectedItemInfo.tsx\");\nvar RightClickOutsideHandler_1 = __webpack_require__(/*! ../internal/components/RightClickOutsideHandler */ \"./src/ts/internal/components/RightClickOutsideHandler.tsx\");\nfunction transformItems(items) {\n    return items.map(function (item) { return (__assign({ canResize: \"both\" }, item)); });\n}\n/**\n * Component description\n */\nvar DashCalendarTimeline = function (props) {\n    var id = props.id, setProps = props.setProps;\n    var _a = (0, react_1.useState)(transformItems(props.items)), items = _a[0], setItems = _a[1];\n    var _b = (0, react_1.useState)(props.visible_time_start), visibleTimeStart = _b[0], setVisibleTimeStart = _b[1];\n    var _c = (0, react_1.useState)(props.visible_time_end), visibleTimeEnd = _c[0], setVisibleTimeEnd = _c[1];\n    var _d = (0, react_1.useState)(undefined), shownItemInfo = _d[0], setShownItemInfo = _d[1];\n    var _e = (0, react_1.useState)(false), hasSelectedItem = _e[0], setHasSelectedItem = _e[1];\n    var _f = (0, react_1.useState)(undefined), showContextMenu = _f[0], setShowContextMenu = _f[1];\n    var timelineRef = (0, react_1.useRef)(null);\n    (0, react_1.useEffect)(function () {\n        setItems(transformItems(props.items));\n    }, [props.items]);\n    (0, react_1.useEffect)(function () {\n        if (props.visible_time_start !== undefined) {\n            setVisibleTimeStart(props.visible_time_start);\n            setProps({\n                visible_time_start: undefined,\n            });\n        }\n        if (props.visible_time_end !== undefined) {\n            setVisibleTimeEnd(props.visible_time_end);\n            setProps({\n                visible_time_end: undefined,\n            });\n        }\n    }, [props.visible_time_start, props.visible_time_end]);\n    // HACK: we can't set defaultTimeStart to 0, so we have to set it to 1.\n    var minStartTime = Math.max(Math.min.apply(Math, items.map(function (item) { return item.start_time; })), 1);\n    var maxEndTime = Math.max.apply(Math, __spreadArray(__spreadArray([], items.map(function (item) { return item.end_time; }), false), [1000 * 60 * 60 * 24], false));\n    // Add 12 hours of padding on each side\n    var defaultTimeStart = props.default_time_start || minStartTime - 1000 * 60 * 60 * 12;\n    var defaultTimeEnd = props.default_time_end || maxEndTime + 1000 * 60 * 60 * 12;\n    var onItemMove = function (itemId, dragTime, newGroupOrder) {\n        var group = props.groups[newGroupOrder];\n        var newItems = items.map(function (item) {\n            return item.id === itemId\n                ? Object.assign({}, item, {\n                    start_time: dragTime,\n                    end_time: dragTime + (item.end_time - item.start_time),\n                    group: group.id,\n                })\n                : item;\n        });\n        setItems(newItems);\n        setProps({ items: newItems });\n    };\n    var onItemSelect = function (itemId, e) {\n        // Only respond to left clicks\n        if (e.button !== 0) {\n            return;\n        }\n        if (!hasSelectedItem && (shownItemInfo === null || shownItemInfo === void 0 ? void 0 : shownItemInfo.id) === itemId) {\n            setHasSelectedItem(true);\n            setProps({ clickedItem: shownItemInfo });\n            return;\n        }\n        var item = items.find(function (item) { return item.id === itemId; });\n        setShownItemInfo(__assign(__assign({}, item), { mousePosition: { x: e.clientX, y: e.clientY } }));\n        setProps({ clickedItem: item });\n        setHasSelectedItem(true);\n    };\n    var onItemClick = function (itemId, e, time) {\n        // Only respond to left clicks\n        if (e.button !== 0) {\n            return;\n        }\n        if (hasSelectedItem) {\n            setShownItemInfo(undefined);\n            setProps({ clickedItem: undefined, selectedItemInput: undefined });\n            setHasSelectedItem(false);\n        }\n        else {\n            var item = items.find(function (item) { return item.id === itemId; });\n            setShownItemInfo(__assign(__assign({}, item), { mousePosition: { x: e.clientX, y: e.clientY } }));\n            setProps({ clickedItem: item });\n            setHasSelectedItem(true);\n        }\n    };\n    var onItemDeselect = function () {\n        setShownItemInfo(undefined);\n        setProps({ clickedItem: undefined, selectedItemInput: undefined });\n        setHasSelectedItem(false);\n    };\n    var onItemResize = function (itemId, time, edge) {\n        var newItems = items.map(function (item) {\n            return item.id === itemId\n                ? Object.assign({}, item, {\n                    start_time: edge === \"left\" ? time : item.start_time,\n                    end_time: edge === \"right\" ? time : item.end_time,\n                })\n                : item;\n        });\n        setItems(newItems);\n        setProps({ items: newItems });\n    };\n    var onMouseEnter = function (itemId, e) {\n        if (hasSelectedItem) {\n            return;\n        }\n        // Show the selected item info on hover\n        var item = items.find(function (item) { return item.id === itemId; });\n        setShownItemInfo(__assign(__assign({}, item), { mousePosition: { x: e.clientX, y: e.clientY } }));\n    };\n    var onMouseLeave = function () {\n        // Hide the selected item info when not hovering\n        if (!hasSelectedItem) {\n            setShownItemInfo(undefined);\n        }\n    };\n    // Slightly modfied default item renderer from react-calendar-timeline to add mouse events\n    var itemRenderer = function (_a) {\n        var _b;\n        var item = _a.item, itemContext = _a.itemContext, getItemProps = _a.getItemProps, getResizeProps = _a.getResizeProps;\n        var _c = getResizeProps(), leftResizeProps = _c.left, rightResizeProps = _c.right;\n        var _d = getItemProps((_b = item.itemProps) !== null && _b !== void 0 ? _b : {}), key = _d.key, ref = _d.ref, rest = __rest(_d, [\"key\", \"ref\"]);\n        var useResizeHandle = itemContext.useResizeHandle;\n        return (react_1.default.createElement(\"div\", __assign({ onMouseEnter: function (e) { return onMouseEnter(item.id, e); }, onMouseLeave: onMouseLeave }, rest, { ref: ref, key: \"\".concat(key, \"-outer\"), isfixed: item.is_fixed ? \"true\" : \"false\" }),\n            useResizeHandle ? react_1.default.createElement(\"div\", __assign({}, leftResizeProps, { key: \"\".concat(key, \"-lr\") })) : null,\n            react_1.default.createElement(\"div\", { className: \"rct-item-content\", style: { maxHeight: \"\".concat(itemContext.dimensions.height) }, key: \"\".concat(key, \"-content\") }, itemContext.title),\n            useResizeHandle ? react_1.default.createElement(\"div\", __assign({}, rightResizeProps, { key: \"\".concat(key, \"-rr\") })) : null));\n    };\n    var onCanvasContextMenu = function (groupId, time, e) {\n        if (!props.context_menu_options) {\n            return;\n        }\n        e.preventDefault();\n        setShowContextMenu({\n            contextItems: props.context_menu_options || [],\n            mouseEvent: e,\n            time: time,\n            groupId: groupId,\n            onClickEvent: function (option) {\n                setShowContextMenu(undefined);\n                setProps({\n                    rightClickedEvent: {\n                        time: time,\n                        group_id: groupId,\n                        option: option,\n                    },\n                });\n            },\n        });\n    };\n    var onTimeChange = function (visibleTimeStart, visibleTimeEnd, updateScrollCanvas) {\n        setVisibleTimeStart(visibleTimeStart);\n        setVisibleTimeEnd(visibleTimeEnd);\n        updateScrollCanvas(visibleTimeStart, visibleTimeEnd);\n    };\n    (0, react_1.useEffect)(function () {\n        var _a;\n        if (!props.enable_external_drop) {\n            return;\n        }\n        var canvas = (_a = timelineRef.current) === null || _a === void 0 ? void 0 : _a.querySelector(\".rct-scroll\");\n        if (!canvas || !setProps) {\n            return;\n        }\n        var handleDragOver = function (event) {\n            event.preventDefault();\n            event.dataTransfer && (event.dataTransfer.dropEffect = \"copy\");\n        };\n        var handleDrop = function (event) {\n            var _a, _b, _c;\n            event.preventDefault();\n            var raw = (_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.getData(\"application/json\");\n            if (!raw || props.groups.length === 0) {\n                return;\n            }\n            var payload = JSON.parse(raw);\n            var rect = canvas.getBoundingClientRect();\n            var lineHeight = (_b = props.line_height) !== null && _b !== void 0 ? _b : 60;\n            var offsetX = event.clientX - rect.left + canvas.scrollLeft;\n            var offsetY = event.clientY - rect.top + canvas.scrollTop;\n            var groupIdx = Math.min(Math.floor(offsetY / lineHeight), props.groups.length - 1);\n            var start = visibleTimeStart !== null && visibleTimeStart !== void 0 ? visibleTimeStart : defaultTimeStart;\n            var end = visibleTimeEnd !== null && visibleTimeEnd !== void 0 ? visibleTimeEnd : defaultTimeEnd;\n            console.log(\"Calculating drop time with:\", {\n                offsetX: offsetX,\n                rect: rect,\n                canvas: canvas,\n                visibleTimeStart: visibleTimeStart,\n                visibleTimeEnd: visibleTimeEnd,\n                start: start,\n                end: end,\n            }); // Debug log\n            var dropTime = start + (offsetX / rect.width) * (end - start);\n            setProps({\n                externalDrop: {\n                    data: payload,\n                    group_id: (_c = props.groups[groupIdx]) === null || _c === void 0 ? void 0 : _c.id,\n                    time: dropTime,\n                },\n            });\n        };\n        canvas.addEventListener(\"dragover\", handleDragOver);\n        canvas.addEventListener(\"drop\", handleDrop);\n        return function () {\n            canvas.removeEventListener(\"dragover\", handleDragOver);\n            canvas.removeEventListener(\"drop\", handleDrop);\n        };\n    }, [\n        props.enable_external_drop,\n        props.groups,\n        visibleTimeStart,\n        visibleTimeEnd,\n        defaultTimeStart,\n        defaultTimeEnd,\n        setProps,\n    ]);\n    return (react_1.default.createElement(\"div\", { id: id, ref: timelineRef },\n        react_1.default.createElement(react_calendar_timeline_1.default, { groups: props.groups, items: items, defaultTimeStart: defaultTimeStart, defaultTimeEnd: defaultTimeEnd, dragSnap: props.drag_snap, minZoom: props.min_zoom, maxZoom: props.max_zoom, lineHeight: props.line_height, itemHeightRatio: props.item_height_ratio, useResizeHandle: props.use_resize_handle ? false : true, onItemMove: onItemMove, onItemSelect: onItemSelect, onItemClick: onItemClick, onItemDeselect: onItemDeselect, onItemResize: onItemResize, onItemDrag: function () {\n                setHasSelectedItem(false);\n                setShownItemInfo(undefined);\n            }, itemRenderer: itemRenderer, onCanvasContextMenu: onCanvasContextMenu, onCanvasClick: function () {\n                setShowContextMenu(undefined);\n            }, onTimeChange: onTimeChange, visibleTimeStart: visibleTimeStart, visibleTimeEnd: visibleTimeEnd }),\n        showContextMenu && react_1.default.createElement(RightClickOutsideHandler_1.RightClickOutsideHandler, __assign({}, showContextMenu)),\n        react_1.default.createElement(SelectedItemInfo_1.SelectedItemInfo, { item: shownItemInfo, setProps: setProps, selectedItemProps: props.selectedItemInput, onDelete: function (itemId) {\n                var newItems = items.filter(function (item) { return item.id !== itemId; });\n                setItems(newItems);\n                setProps({ items: newItems, clickedItem: undefined, selectedItemInput: undefined });\n                setShownItemInfo(undefined);\n            }, onItemFix: function (itemId, isFixed) {\n                var newItems = items.map(function (item) {\n                    return item.id === itemId ? __assign(__assign({}, item), { is_fixed: isFixed }) : item;\n                });\n                setItems(newItems);\n                setProps({ items: newItems });\n            }, onSkuChange: function (itemId, sku) {\n                var newItems = items.map(function (item) { return (item.id === itemId ? __assign(__assign({}, item), { sku: sku }) : item); });\n                setItems(newItems);\n                setProps({ items: newItems });\n            } })));\n};\nexports[\"default\"] = DashCalendarTimeline;\n\n\n//# sourceURL=webpack://dash_calendar_timeline/./src/ts/components/DashCalendarTimeline.tsx?\n}");

/***/ }),

/***/ "./src/ts/index.ts":
/*!*************************!*\
  !*** ./src/ts/index.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DashCalendarTimeline = void 0;\nvar DashCalendarTimeline_1 = __importDefault(__webpack_require__(/*! ./components/DashCalendarTimeline */ \"./src/ts/components/DashCalendarTimeline.tsx\"));\nexports.DashCalendarTimeline = DashCalendarTimeline_1.default;\n\n\n//# sourceURL=webpack://dash_calendar_timeline/./src/ts/index.ts?\n}");

/***/ }),

/***/ "./src/ts/internal/components/RightClickOutsideHandler.tsx":
/*!*****************************************************************!*\
  !*** ./src/ts/internal/components/RightClickOutsideHandler.tsx ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RightClickOutsideHandler = RightClickOutsideHandler;\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"react\"));\nfunction RightClickOutsideHandler(_a) {\n    var contextItems = _a.contextItems, mouseEvent = _a.mouseEvent, time = _a.time, groupId = _a.groupId, onClickEvent = _a.onClickEvent;\n    return (react_1.default.createElement(\"div\", { style: {\n            position: \"absolute\",\n            top: mouseEvent.clientY,\n            left: mouseEvent.clientX,\n            backgroundColor: \"white\",\n            border: \"1px solid black\",\n            zIndex: 1000,\n        }, className: \"dash-rct-right-click-menu\" }, contextItems.map(function (item, index) { return (react_1.default.createElement(\"div\", { key: index, onClick: function () { return onClickEvent(item); }, className: \"dash-rct-right-click-menu-option\" }, item)); })));\n}\n\n\n//# sourceURL=webpack://dash_calendar_timeline/./src/ts/internal/components/RightClickOutsideHandler.tsx?\n}");

/***/ }),

/***/ "./src/ts/internal/components/SelectedItemInfo.tsx":
/*!*********************************************************!*\
  !*** ./src/ts/internal/components/SelectedItemInfo.tsx ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("{\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SelectedItemInfo = SelectedItemInfo;\nvar react_1 = __importStar(__webpack_require__(/*! react */ \"react\"));\nfunction SelectedItemInfo(_a) {\n    var item = _a.item, setProps = _a.setProps, selectedItemProps = _a.selectedItemProps, onDelete = _a.onDelete, onItemFix = _a.onItemFix, onSkuChange = _a.onSkuChange;\n    var _b = (0, react_1.useState)((item === null || item === void 0 ? void 0 : item.sku) || 0), sku = _b[0], setSku = _b[1];\n    var _c = (0, react_1.useState)((item === null || item === void 0 ? void 0 : item.is_fixed) || false), isFixed = _c[0], setIsFixed = _c[1];\n    (0, react_1.useEffect)(function () {\n        setSku((item === null || item === void 0 ? void 0 : item.sku) || 0);\n        setIsFixed((item === null || item === void 0 ? void 0 : item.is_fixed) || false);\n    }, [item]);\n    if (item === undefined) {\n        return react_1.default.createElement(react_1.default.Fragment, null);\n    }\n    var x = item.mousePosition.x + 5;\n    var y = item.mousePosition.y + 5;\n    return (react_1.default.createElement(\"div\", { style: {\n            position: \"absolute\",\n            left: x,\n            top: y,\n        }, className: \"selected-item-info\" },\n        react_1.default.createElement(\"div\", { className: \"selected-item-info-inputs\" },\n            react_1.default.createElement(\"button\", { type: \"button\", onClick: function () { return onDelete(item.id); } }, \"\\uD83D\\uDDD1\"),\n            react_1.default.createElement(\"div\", null,\n                react_1.default.createElement(\"label\", { htmlFor: \"is-fixed-check\" }, \"Is Fixed\"),\n                react_1.default.createElement(\"input\", { type: \"checkbox\", name: \"Is Fixed\", id: \"is-fixed-check\", checked: isFixed, onChange: function (e) {\n                        setIsFixed(e.target.checked);\n                        setProps({\n                            isFixedChanged: e.target.checked,\n                        });\n                        onItemFix(item.id, e.target.checked);\n                    } })),\n            react_1.default.createElement(\"div\", null,\n                react_1.default.createElement(\"label\", { htmlFor: \"sku-input\" }, \"SKU\"),\n                react_1.default.createElement(\"input\", { type: \"number\", name: \"SKU\", id: \"sku-input\", value: sku, onChange: function (e) {\n                        setSku(Number(e.target.value));\n                        setProps({\n                            skuChanged: Number(e.target.value),\n                        });\n                        onSkuChange(item.id, Number(e.target.value));\n                    } }))),\n        item.hoverInfo && react_1.default.createElement(\"div\", { dangerouslySetInnerHTML: { __html: item.hoverInfo } }),\n        item.inputs &&\n            Object.entries(item.inputs).map(function (_a, index) {\n                var key = _a[0], input = _a[1];\n                return (react_1.default.createElement(\"div\", { key: index },\n                    react_1.default.createElement(\"label\", { htmlFor: input.id }, key),\n                    react_1.default.createElement(\"input\", __assign({}, input, { onChange: function (e) {\n                            var _a;\n                            if (input.onChange) {\n                                input.onChange(e);\n                            }\n                            var value = e.target.type === \"checkbox\" ? e.target.checked : e.target.value;\n                            setProps({\n                                selectedItemInput: __assign(__assign({}, selectedItemProps), (_a = {}, _a[key] = value, _a)),\n                            });\n                        } }))));\n            })));\n}\n\n\n//# sourceURL=webpack://dash_calendar_timeline/./src/ts/internal/components/SelectedItemInfo.tsx?\n}");

/***/ }),

/***/ "./src/ts/styles/base.css":
/*!********************************!*\
  !*** ./src/ts/styles/base.css ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_base_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js!./base.css */ \"./node_modules/css-loader/dist/cjs.js!./src/ts/styles/base.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_4___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_2___default());\noptions.insert = function insertAtTop(element) {\n                                    var parent = document.querySelector(\"head\");\n                                    var lastInsertedElement =\n                                        window._lastElementInsertedByStyleLoader;\n\n                                    if (!lastInsertedElement) {\n                                        parent.insertBefore(element, parent.firstChild);\n                                    } else if (lastInsertedElement.nextSibling) {\n                                        parent.insertBefore(element, lastInsertedElement.nextSibling);\n                                    } else {\n                                        parent.appendChild(element);\n                                    }\n\n                                    window._lastElementInsertedByStyleLoader = element;\n                                };\noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_base_css__WEBPACK_IMPORTED_MODULE_5__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_base_css__WEBPACK_IMPORTED_MODULE_5__[\"default\"] && _node_modules_css_loader_dist_cjs_js_base_css__WEBPACK_IMPORTED_MODULE_5__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_base_css__WEBPACK_IMPORTED_MODULE_5__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://dash_calendar_timeline/./src/ts/styles/base.css?\n}");

/***/ }),

/***/ "./src/ts/styles/selected-item.css":
/*!*****************************************!*\
  !*** ./src/ts/styles/selected-item.css ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_selected_item_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js!./selected-item.css */ \"./node_modules/css-loader/dist/cjs.js!./src/ts/styles/selected-item.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_4___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_2___default());\noptions.insert = function insertAtTop(element) {\n                                    var parent = document.querySelector(\"head\");\n                                    var lastInsertedElement =\n                                        window._lastElementInsertedByStyleLoader;\n\n                                    if (!lastInsertedElement) {\n                                        parent.insertBefore(element, parent.firstChild);\n                                    } else if (lastInsertedElement.nextSibling) {\n                                        parent.insertBefore(element, lastInsertedElement.nextSibling);\n                                    } else {\n                                        parent.appendChild(element);\n                                    }\n\n                                    window._lastElementInsertedByStyleLoader = element;\n                                };\noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_selected_item_css__WEBPACK_IMPORTED_MODULE_5__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_selected_item_css__WEBPACK_IMPORTED_MODULE_5__[\"default\"] && _node_modules_css_loader_dist_cjs_js_selected_item_css__WEBPACK_IMPORTED_MODULE_5__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_selected_item_css__WEBPACK_IMPORTED_MODULE_5__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://dash_calendar_timeline/./src/ts/styles/selected-item.css?\n}");

/***/ }),

/***/ "react":
/*!****************************************************************************************************!*\
  !*** external {"commonjs":"react","commonjs2":"react","amd":"react","umd":"react","root":"React"} ***!
  \****************************************************************************************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE_react__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/ts/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});